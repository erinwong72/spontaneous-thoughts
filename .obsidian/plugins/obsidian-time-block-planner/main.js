/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/obsidian-daily-notes-interface/dist/main.js
var require_main = __commonJS({
  "node_modules/obsidian-daily-notes-interface/dist/main.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var obsidian = require("obsidian");
    var DEFAULT_DAILY_NOTE_FORMAT = "YYYY-MM-DD";
    var DEFAULT_WEEKLY_NOTE_FORMAT = "gggg-[W]ww";
    var DEFAULT_MONTHLY_NOTE_FORMAT = "YYYY-MM";
    var DEFAULT_QUARTERLY_NOTE_FORMAT = "YYYY-[Q]Q";
    var DEFAULT_YEARLY_NOTE_FORMAT = "YYYY";
    function shouldUsePeriodicNotesSettings(periodicity) {
      var _a, _b;
      const periodicNotes = window.app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a[periodicity]) == null ? void 0 : _b.enabled);
    }
    function getDailyNoteSettings() {
      var _a, _b, _c, _d;
      try {
        const { internalPlugins, plugins } = window.app;
        if (shouldUsePeriodicNotesSettings("daily")) {
          const { format: format2, folder: folder2, template: template2 } = ((_b = (_a = plugins.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.daily) || {};
          return {
            format: format2 || DEFAULT_DAILY_NOTE_FORMAT,
            folder: (folder2 == null ? void 0 : folder2.trim()) || "",
            template: (template2 == null ? void 0 : template2.trim()) || ""
          };
        }
        const { folder, format, template } = ((_d = (_c = internalPlugins.getPluginById("daily-notes")) == null ? void 0 : _c.instance) == null ? void 0 : _d.options) || {};
        return {
          format: format || DEFAULT_DAILY_NOTE_FORMAT,
          folder: (folder == null ? void 0 : folder.trim()) || "",
          template: (template == null ? void 0 : template.trim()) || ""
        };
      } catch (err) {
        console.info("No custom daily note settings found!", err);
      }
    }
    function getWeeklyNoteSettings() {
      var _a, _b, _c, _d, _e, _f, _g;
      try {
        const pluginManager = window.app.plugins;
        const calendarSettings = (_a = pluginManager.getPlugin("calendar")) == null ? void 0 : _a.options;
        const periodicNotesSettings = (_c = (_b = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _b.settings) == null ? void 0 : _c.weekly;
        if (shouldUsePeriodicNotesSettings("weekly")) {
          return {
            format: periodicNotesSettings.format || DEFAULT_WEEKLY_NOTE_FORMAT,
            folder: ((_d = periodicNotesSettings.folder) == null ? void 0 : _d.trim()) || "",
            template: ((_e = periodicNotesSettings.template) == null ? void 0 : _e.trim()) || ""
          };
        }
        const settings2 = calendarSettings || {};
        return {
          format: settings2.weeklyNoteFormat || DEFAULT_WEEKLY_NOTE_FORMAT,
          folder: ((_f = settings2.weeklyNoteFolder) == null ? void 0 : _f.trim()) || "",
          template: ((_g = settings2.weeklyNoteTemplate) == null ? void 0 : _g.trim()) || ""
        };
      } catch (err) {
        console.info("No custom weekly note settings found!", err);
      }
    }
    function getMonthlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings2 = shouldUsePeriodicNotesSettings("monthly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.monthly) || {};
        return {
          format: settings2.format || DEFAULT_MONTHLY_NOTE_FORMAT,
          folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom monthly note settings found!", err);
      }
    }
    function getQuarterlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings2 = shouldUsePeriodicNotesSettings("quarterly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.quarterly) || {};
        return {
          format: settings2.format || DEFAULT_QUARTERLY_NOTE_FORMAT,
          folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom quarterly note settings found!", err);
      }
    }
    function getYearlyNoteSettings() {
      var _a, _b, _c, _d;
      const pluginManager = window.app.plugins;
      try {
        const settings2 = shouldUsePeriodicNotesSettings("yearly") && ((_b = (_a = pluginManager.getPlugin("periodic-notes")) == null ? void 0 : _a.settings) == null ? void 0 : _b.yearly) || {};
        return {
          format: settings2.format || DEFAULT_YEARLY_NOTE_FORMAT,
          folder: ((_c = settings2.folder) == null ? void 0 : _c.trim()) || "",
          template: ((_d = settings2.template) == null ? void 0 : _d.trim()) || ""
        };
      } catch (err) {
        console.info("No custom yearly note settings found!", err);
      }
    }
    function join(...partSegments) {
      let parts = [];
      for (let i = 0, l = partSegments.length; i < l; i++) {
        parts = parts.concat(partSegments[i].split("/"));
      }
      const newParts = [];
      for (let i = 0, l = parts.length; i < l; i++) {
        const part = parts[i];
        if (!part || part === ".")
          continue;
        else
          newParts.push(part);
      }
      if (parts[0] === "")
        newParts.unshift("");
      return newParts.join("/");
    }
    function basename(fullPath) {
      let base = fullPath.substring(fullPath.lastIndexOf("/") + 1);
      if (base.lastIndexOf(".") != -1)
        base = base.substring(0, base.lastIndexOf("."));
      return base;
    }
    async function ensureFolderExists(path) {
      const dirs = path.replace(/\\/g, "/").split("/");
      dirs.pop();
      if (dirs.length) {
        const dir = join(...dirs);
        if (!window.app.vault.getAbstractFileByPath(dir)) {
          await window.app.vault.createFolder(dir);
        }
      }
    }
    async function getNotePath(directory, filename) {
      if (!filename.endsWith(".md")) {
        filename += ".md";
      }
      const path = obsidian.normalizePath(join(directory, filename));
      await ensureFolderExists(path);
      return path;
    }
    async function getTemplateInfo(template) {
      const { metadataCache, vault } = window.app;
      const templatePath = obsidian.normalizePath(template);
      if (templatePath === "/") {
        return Promise.resolve(["", null]);
      }
      try {
        const templateFile = metadataCache.getFirstLinkpathDest(templatePath, "");
        const contents = await vault.cachedRead(templateFile);
        const IFoldInfo = window.app.foldManager.load(templateFile);
        return [contents, IFoldInfo];
      } catch (err) {
        console.error(`Failed to read the daily note template '${templatePath}'`, err);
        new obsidian.Notice("Failed to read the daily note template");
        return ["", null];
      }
    }
    function getDateUID(date, granularity = "day") {
      const ts = date.clone().startOf(granularity).format();
      return `${granularity}-${ts}`;
    }
    function removeEscapedCharacters(format) {
      return format.replace(/\[[^\]]*\]/g, "");
    }
    function isFormatAmbiguous(format, granularity) {
      if (granularity === "week") {
        const cleanFormat = removeEscapedCharacters(format);
        return /w{1,2}/i.test(cleanFormat) && (/M{1,4}/.test(cleanFormat) || /D{1,4}/.test(cleanFormat));
      }
      return false;
    }
    function getDateFromFile(file, granularity) {
      return getDateFromFilename(file.basename, granularity);
    }
    function getDateFromPath(path, granularity) {
      return getDateFromFilename(basename(path), granularity);
    }
    function getDateFromFilename(filename, granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      };
      const format = getSettings[granularity]().format.split("/").pop();
      const noteDate = window.moment(filename, format, true);
      if (!noteDate.isValid()) {
        return null;
      }
      if (isFormatAmbiguous(format, granularity)) {
        if (granularity === "week") {
          const cleanFormat = removeEscapedCharacters(format);
          if (/w{1,2}/i.test(cleanFormat)) {
            return window.moment(
              filename,
              // If format contains week, remove day & month formatting
              format.replace(/M{1,4}/g, "").replace(/D{1,4}/g, ""),
              false
            );
          }
        }
      }
      return noteDate;
    }
    var DailyNotesFolderMissingError = class extends Error {
    };
    async function createDailyNote2(date) {
      const app = window.app;
      const { vault } = app;
      const moment2 = window.moment;
      const { template, format, folder } = getDailyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, moment2().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = moment2();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*yesterday\s*}}/gi, date.clone().subtract(1, "day").format(format)).replace(/{{\s*tomorrow\s*}}/gi, date.clone().add(1, "d").format(format)));
        app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getDailyNote3(date, dailyNotes) {
      var _a;
      return (_a = dailyNotes[getDateUID(date, "day")]) != null ? _a : null;
    }
    function getAllDailyNotes3() {
      const { vault } = window.app;
      const { folder } = getDailyNoteSettings();
      const dailyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!dailyNotesFolder) {
        throw new DailyNotesFolderMissingError("Failed to find daily notes folder");
      }
      const dailyNotes = {};
      obsidian.Vault.recurseChildren(dailyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "day");
          if (date) {
            const dateString = getDateUID(date, "day");
            dailyNotes[dateString] = note;
          }
        }
      });
      return dailyNotes;
    }
    var WeeklyNotesFolderMissingError = class extends Error {
    };
    function getDaysOfWeek() {
      const { moment: moment2 } = window;
      let weekStart = moment2.localeData()._week.dow;
      const daysOfWeek = [
        "sunday",
        "monday",
        "tuesday",
        "wednesday",
        "thursday",
        "friday",
        "saturday"
      ];
      while (weekStart) {
        daysOfWeek.push(daysOfWeek.shift());
        weekStart--;
      }
      return daysOfWeek;
    }
    function getDayOfWeekNumericalValue(dayOfWeekName) {
      return getDaysOfWeek().indexOf(dayOfWeekName.toLowerCase());
    }
    async function createWeeklyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getWeeklyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*title\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*(sunday|monday|tuesday|wednesday|thursday|friday|saturday)\s*:(.*?)}}/gi, (_, dayOfWeek, momentFormat) => {
          const day = getDayOfWeekNumericalValue(dayOfWeek);
          return date.weekday(day).format(momentFormat.trim());
        }));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getWeeklyNote(date, weeklyNotes) {
      var _a;
      return (_a = weeklyNotes[getDateUID(date, "week")]) != null ? _a : null;
    }
    function getAllWeeklyNotes() {
      const weeklyNotes = {};
      if (!appHasWeeklyNotesPluginLoaded()) {
        return weeklyNotes;
      }
      const { vault } = window.app;
      const { folder } = getWeeklyNoteSettings();
      const weeklyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!weeklyNotesFolder) {
        throw new WeeklyNotesFolderMissingError("Failed to find weekly notes folder");
      }
      obsidian.Vault.recurseChildren(weeklyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "week");
          if (date) {
            const dateString = getDateUID(date, "week");
            weeklyNotes[dateString] = note;
          }
        }
      });
      return weeklyNotes;
    }
    var MonthlyNotesFolderMissingError = class extends Error {
    };
    async function createMonthlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getMonthlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getMonthlyNote(date, monthlyNotes) {
      var _a;
      return (_a = monthlyNotes[getDateUID(date, "month")]) != null ? _a : null;
    }
    function getAllMonthlyNotes() {
      const monthlyNotes = {};
      if (!appHasMonthlyNotesPluginLoaded()) {
        return monthlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getMonthlyNoteSettings();
      const monthlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!monthlyNotesFolder) {
        throw new MonthlyNotesFolderMissingError("Failed to find monthly notes folder");
      }
      obsidian.Vault.recurseChildren(monthlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "month");
          if (date) {
            const dateString = getDateUID(date, "month");
            monthlyNotes[dateString] = note;
          }
        }
      });
      return monthlyNotes;
    }
    var QuarterlyNotesFolderMissingError = class extends Error {
    };
    async function createQuarterlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getQuarterlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getQuarterlyNote(date, quarterly) {
      var _a;
      return (_a = quarterly[getDateUID(date, "quarter")]) != null ? _a : null;
    }
    function getAllQuarterlyNotes() {
      const quarterly = {};
      if (!appHasQuarterlyNotesPluginLoaded()) {
        return quarterly;
      }
      const { vault } = window.app;
      const { folder } = getQuarterlyNoteSettings();
      const quarterlyFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!quarterlyFolder) {
        throw new QuarterlyNotesFolderMissingError("Failed to find quarterly notes folder");
      }
      obsidian.Vault.recurseChildren(quarterlyFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "quarter");
          if (date) {
            const dateString = getDateUID(date, "quarter");
            quarterly[dateString] = note;
          }
        }
      });
      return quarterly;
    }
    var YearlyNotesFolderMissingError = class extends Error {
    };
    async function createYearlyNote(date) {
      const { vault } = window.app;
      const { template, format, folder } = getYearlyNoteSettings();
      const [templateContents, IFoldInfo] = await getTemplateInfo(template);
      const filename = date.format(format);
      const normalizedPath = await getNotePath(folder, filename);
      try {
        const createdFile = await vault.create(normalizedPath, templateContents.replace(/{{\s*(date|time)\s*(([+-]\d+)([yqmwdhs]))?\s*(:.+?)?}}/gi, (_, _timeOrDate, calc, timeDelta, unit, momentFormat) => {
          const now2 = window.moment();
          const currentDate = date.clone().set({
            hour: now2.get("hour"),
            minute: now2.get("minute"),
            second: now2.get("second")
          });
          if (calc) {
            currentDate.add(parseInt(timeDelta, 10), unit);
          }
          if (momentFormat) {
            return currentDate.format(momentFormat.substring(1).trim());
          }
          return currentDate.format(format);
        }).replace(/{{\s*date\s*}}/gi, filename).replace(/{{\s*time\s*}}/gi, window.moment().format("HH:mm")).replace(/{{\s*title\s*}}/gi, filename));
        window.app.foldManager.save(createdFile, IFoldInfo);
        return createdFile;
      } catch (err) {
        console.error(`Failed to create file: '${normalizedPath}'`, err);
        new obsidian.Notice("Unable to create new file.");
      }
    }
    function getYearlyNote(date, yearlyNotes) {
      var _a;
      return (_a = yearlyNotes[getDateUID(date, "year")]) != null ? _a : null;
    }
    function getAllYearlyNotes() {
      const yearlyNotes = {};
      if (!appHasYearlyNotesPluginLoaded()) {
        return yearlyNotes;
      }
      const { vault } = window.app;
      const { folder } = getYearlyNoteSettings();
      const yearlyNotesFolder = vault.getAbstractFileByPath(obsidian.normalizePath(folder));
      if (!yearlyNotesFolder) {
        throw new YearlyNotesFolderMissingError("Failed to find yearly notes folder");
      }
      obsidian.Vault.recurseChildren(yearlyNotesFolder, (note) => {
        if (note instanceof obsidian.TFile) {
          const date = getDateFromFile(note, "year");
          if (date) {
            const dateString = getDateUID(date, "year");
            yearlyNotes[dateString] = note;
          }
        }
      });
      return yearlyNotes;
    }
    function appHasDailyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const dailyNotesPlugin = app.internalPlugins.plugins["daily-notes"];
      if (dailyNotesPlugin && dailyNotesPlugin.enabled) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.daily) == null ? void 0 : _b.enabled);
    }
    function appHasWeeklyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      if (app.plugins.getPlugin("calendar")) {
        return true;
      }
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.weekly) == null ? void 0 : _b.enabled);
    }
    function appHasMonthlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.monthly) == null ? void 0 : _b.enabled);
    }
    function appHasQuarterlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.quarterly) == null ? void 0 : _b.enabled);
    }
    function appHasYearlyNotesPluginLoaded() {
      var _a, _b;
      const { app } = window;
      const periodicNotes = app.plugins.getPlugin("periodic-notes");
      return periodicNotes && ((_b = (_a = periodicNotes.settings) == null ? void 0 : _a.yearly) == null ? void 0 : _b.enabled);
    }
    function getPeriodicNoteSettings(granularity) {
      const getSettings = {
        day: getDailyNoteSettings,
        week: getWeeklyNoteSettings,
        month: getMonthlyNoteSettings,
        quarter: getQuarterlyNoteSettings,
        year: getYearlyNoteSettings
      }[granularity];
      return getSettings();
    }
    function createPeriodicNote(granularity, date) {
      const createFn = {
        day: createDailyNote2,
        month: createMonthlyNote,
        week: createWeeklyNote
      };
      return createFn[granularity](date);
    }
    exports.DEFAULT_DAILY_NOTE_FORMAT = DEFAULT_DAILY_NOTE_FORMAT;
    exports.DEFAULT_MONTHLY_NOTE_FORMAT = DEFAULT_MONTHLY_NOTE_FORMAT;
    exports.DEFAULT_QUARTERLY_NOTE_FORMAT = DEFAULT_QUARTERLY_NOTE_FORMAT;
    exports.DEFAULT_WEEKLY_NOTE_FORMAT = DEFAULT_WEEKLY_NOTE_FORMAT;
    exports.DEFAULT_YEARLY_NOTE_FORMAT = DEFAULT_YEARLY_NOTE_FORMAT;
    exports.appHasDailyNotesPluginLoaded = appHasDailyNotesPluginLoaded;
    exports.appHasMonthlyNotesPluginLoaded = appHasMonthlyNotesPluginLoaded;
    exports.appHasQuarterlyNotesPluginLoaded = appHasQuarterlyNotesPluginLoaded;
    exports.appHasWeeklyNotesPluginLoaded = appHasWeeklyNotesPluginLoaded;
    exports.appHasYearlyNotesPluginLoaded = appHasYearlyNotesPluginLoaded;
    exports.createDailyNote = createDailyNote2;
    exports.createMonthlyNote = createMonthlyNote;
    exports.createPeriodicNote = createPeriodicNote;
    exports.createQuarterlyNote = createQuarterlyNote;
    exports.createWeeklyNote = createWeeklyNote;
    exports.createYearlyNote = createYearlyNote;
    exports.getAllDailyNotes = getAllDailyNotes3;
    exports.getAllMonthlyNotes = getAllMonthlyNotes;
    exports.getAllQuarterlyNotes = getAllQuarterlyNotes;
    exports.getAllWeeklyNotes = getAllWeeklyNotes;
    exports.getAllYearlyNotes = getAllYearlyNotes;
    exports.getDailyNote = getDailyNote3;
    exports.getDailyNoteSettings = getDailyNoteSettings;
    exports.getDateFromFile = getDateFromFile;
    exports.getDateFromPath = getDateFromPath;
    exports.getDateUID = getDateUID;
    exports.getMonthlyNote = getMonthlyNote;
    exports.getMonthlyNoteSettings = getMonthlyNoteSettings;
    exports.getPeriodicNoteSettings = getPeriodicNoteSettings;
    exports.getQuarterlyNote = getQuarterlyNote;
    exports.getQuarterlyNoteSettings = getQuarterlyNoteSettings;
    exports.getTemplateInfo = getTemplateInfo;
    exports.getWeeklyNote = getWeeklyNote;
    exports.getWeeklyNoteSettings = getWeeklyNoteSettings;
    exports.getYearlyNote = getYearlyNote;
    exports.getYearlyNoteSettings = getYearlyNoteSettings;
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => DayPlanner
});
module.exports = __toCommonJS(main_exports);
var import_obsidian7 = require("obsidian");
var import_obsidian_daily_notes_interface2 = __toESM(require_main());

// node_modules/svelte/internal/index.mjs
function noop() {
}
var identity = (x) => x;
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return tar;
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || (a && typeof a === "object" || typeof a === "function");
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function set_store_value(store, ret, value) {
  store.set(value);
  return ret;
}
var is_client = typeof window !== "undefined";
var now = is_client ? () => window.performance.now() : () => Date.now();
var raf = is_client ? (cb) => requestAnimationFrame(cb) : noop;
var tasks = /* @__PURE__ */ new Set();
function run_tasks(now2) {
  tasks.forEach((task) => {
    if (!task.c(now2)) {
      tasks.delete(task);
      task.f();
    }
  });
  if (tasks.size !== 0)
    raf(run_tasks);
}
function loop(callback) {
  let task;
  if (tasks.size === 0)
    raf(run_tasks);
  return {
    promise: new Promise((fulfill) => {
      tasks.add(task = { c: callback, f: fulfill });
    }),
    abort() {
      tasks.delete(task);
    }
  };
}
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : global;
var ResizeObserverSingleton = class _ResizeObserverSingleton {
  constructor(options) {
    this.options = options;
    this._listeners = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
  }
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  _getObserver() {
    var _a;
    return (_a = this._observer) !== null && _a !== void 0 ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        _ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && root.host) {
    return root;
  }
  return node.ownerDocument;
}
function append_empty_stylesheet(node) {
  const style_element = element("style");
  append_stylesheet(get_root_for_style(node), style_element);
  return style_element.sheet;
}
function append_stylesheet(node, style) {
  append(node.head || node, style);
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function stop_propagation(fn) {
  return function(event) {
    event.stopPropagation();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text2, data) {
  data = "" + data;
  if (text2.data === data)
    return;
  text2.data = data;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList[toggle ? "add" : "remove"](name);
}
function custom_event(type, detail, { bubbles = false, cancelable = false } = {}) {
  const e = document.createEvent("CustomEvent");
  e.initCustomEvent(type, bubbles, cancelable, detail);
  return e;
}
var managed_styles = /* @__PURE__ */ new Map();
var active = 0;
function hash(str) {
  let hash2 = 5381;
  let i = str.length;
  while (i--)
    hash2 = (hash2 << 5) - hash2 ^ str.charCodeAt(i);
  return hash2 >>> 0;
}
function create_style_information(doc, node) {
  const info = { stylesheet: append_empty_stylesheet(node), rules: {} };
  managed_styles.set(doc, info);
  return info;
}
function create_rule(node, a, b, duration, delay, ease, fn, uid = 0) {
  const step = 16.666 / duration;
  let keyframes = "{\n";
  for (let p = 0; p <= 1; p += step) {
    const t = a + (b - a) * ease(p);
    keyframes += p * 100 + `%{${fn(t, 1 - t)}}
`;
  }
  const rule = keyframes + `100% {${fn(b, 1 - b)}}
}`;
  const name = `__svelte_${hash(rule)}_${uid}`;
  const doc = get_root_for_style(node);
  const { stylesheet, rules } = managed_styles.get(doc) || create_style_information(doc, node);
  if (!rules[name]) {
    rules[name] = true;
    stylesheet.insertRule(`@keyframes ${name} ${rule}`, stylesheet.cssRules.length);
  }
  const animation = node.style.animation || "";
  node.style.animation = `${animation ? `${animation}, ` : ""}${name} ${duration}ms linear ${delay}ms 1 both`;
  active += 1;
  return name;
}
function delete_rule(node, name) {
  const previous = (node.style.animation || "").split(", ");
  const next = previous.filter(
    name ? (anim) => anim.indexOf(name) < 0 : (anim) => anim.indexOf("__svelte") === -1
    // remove all Svelte animations
  );
  const deleted = previous.length - next.length;
  if (deleted) {
    node.style.animation = next.join(", ");
    active -= deleted;
    if (!active)
      clear_rules();
  }
}
function clear_rules() {
  raf(() => {
    if (active)
      return;
    managed_styles.forEach((info) => {
      const { ownerNode } = info.stylesheet;
      if (ownerNode)
        detach(ownerNode);
    });
    managed_styles.clear();
  });
}
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}
function onDestroy(fn) {
  get_current_component().$$.on_destroy.push(fn);
}
function bubble(component, event) {
  const callbacks = component.$$.callbacks[event.type];
  if (callbacks) {
    callbacks.slice().forEach((fn) => fn.call(this, event));
  }
}
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}
var promise;
function wait() {
  if (!promise) {
    promise = Promise.resolve();
    promise.then(() => {
      promise = null;
    });
  }
  return promise;
}
function dispatch(node, direction, kind) {
  node.dispatchEvent(custom_event(`${direction ? "intro" : "outro"}${kind}`));
}
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}
var null_transition = { duration: 0 };
function create_bidirectional_transition(node, fn, params, intro) {
  const options = { direction: "both" };
  let config = fn(node, params, options);
  let t = intro ? 0 : 1;
  let running_program = null;
  let pending_program = null;
  let animation_name = null;
  function clear_animation() {
    if (animation_name)
      delete_rule(node, animation_name);
  }
  function init2(program, duration) {
    const d = program.b - t;
    duration *= Math.abs(d);
    return {
      a: t,
      b: program.b,
      d,
      duration,
      start: program.start,
      end: program.start + duration,
      group: program.group
    };
  }
  function go(b) {
    const { delay = 0, duration = 300, easing = identity, tick: tick2 = noop, css } = config || null_transition;
    const program = {
      start: now() + delay,
      b
    };
    if (!b) {
      program.group = outros;
      outros.r += 1;
    }
    if (running_program || pending_program) {
      pending_program = program;
    } else {
      if (css) {
        clear_animation();
        animation_name = create_rule(node, t, b, duration, delay, easing, css);
      }
      if (b)
        tick2(0, 1);
      running_program = init2(program, duration);
      add_render_callback(() => dispatch(node, b, "start"));
      loop((now2) => {
        if (pending_program && now2 > pending_program.start) {
          running_program = init2(pending_program, duration);
          pending_program = null;
          dispatch(node, running_program.b, "start");
          if (css) {
            clear_animation();
            animation_name = create_rule(node, t, running_program.b, running_program.duration, 0, easing, config.css);
          }
        }
        if (running_program) {
          if (now2 >= running_program.end) {
            tick2(t = running_program.b, 1 - t);
            dispatch(node, running_program.b, "end");
            if (!pending_program) {
              if (running_program.b) {
                clear_animation();
              } else {
                if (!--running_program.group.r)
                  run_all(running_program.group.c);
              }
            }
            running_program = null;
          } else if (now2 >= running_program.start) {
            const p = now2 - running_program.start;
            t = running_program.a + running_program.d * easing(p / running_program.duration);
            tick2(t, 1 - t);
          }
        }
        return !!(running_program || pending_program);
      });
    }
  }
  return {
    run(b) {
      if (is_function(config)) {
        wait().then(() => {
          config = config(options);
          go(b);
        });
      } else {
        go(b);
      }
    },
    end() {
      clear_animation();
      running_program = pending_program = null;
    }
  };
}
function outro_and_destroy_block(block, lookup) {
  transition_out(block, 1, 1, () => {
    lookup.delete(block.key);
  });
}
function update_keyed_each(old_blocks, dirty, get_key, dynamic, ctx, list, lookup, node, destroy, create_each_block5, next, get_context) {
  let o = old_blocks.length;
  let n = list.length;
  let i = o;
  const old_indexes = {};
  while (i--)
    old_indexes[old_blocks[i].key] = i;
  const new_blocks = [];
  const new_lookup = /* @__PURE__ */ new Map();
  const deltas = /* @__PURE__ */ new Map();
  const updates = [];
  i = n;
  while (i--) {
    const child_ctx = get_context(ctx, list, i);
    const key = get_key(child_ctx);
    let block = lookup.get(key);
    if (!block) {
      block = create_each_block5(key, child_ctx);
      block.c();
    } else if (dynamic) {
      updates.push(() => block.p(child_ctx, dirty));
    }
    new_lookup.set(key, new_blocks[i] = block);
    if (key in old_indexes)
      deltas.set(key, Math.abs(i - old_indexes[key]));
  }
  const will_move = /* @__PURE__ */ new Set();
  const did_move = /* @__PURE__ */ new Set();
  function insert2(block) {
    transition_in(block, 1);
    block.m(node, next);
    lookup.set(block.key, block);
    next = block.first;
    n--;
  }
  while (o && n) {
    const new_block = new_blocks[n - 1];
    const old_block = old_blocks[o - 1];
    const new_key = new_block.key;
    const old_key = old_block.key;
    if (new_block === old_block) {
      next = new_block.first;
      o--;
      n--;
    } else if (!new_lookup.has(old_key)) {
      destroy(old_block, lookup);
      o--;
    } else if (!lookup.has(new_key) || will_move.has(new_key)) {
      insert2(new_block);
    } else if (did_move.has(old_key)) {
      o--;
    } else if (deltas.get(new_key) > deltas.get(old_key)) {
      did_move.add(new_key);
      insert2(new_block);
    } else {
      will_move.add(old_key);
      o--;
    }
  }
  while (o--) {
    const old_block = old_blocks[o];
    if (!new_lookup.has(old_block.key))
      destroy(old_block, lookup);
  }
  while (n)
    insert2(new_blocks[n - 1]);
  run_all(updates);
  return new_blocks;
}
function get_spread_update(levels, updates) {
  const update2 = {};
  const to_null_out = {};
  const accounted_for = { $$scope: 1 };
  let i = levels.length;
  while (i--) {
    const o = levels[i];
    const n = updates[i];
    if (n) {
      for (const key in o) {
        if (!(key in n))
          to_null_out[key] = 1;
      }
      for (const key in n) {
        if (!accounted_for[key]) {
          update2[key] = n[key];
          accounted_for[key] = 1;
        }
      }
      levels[i] = n;
    } else {
      for (const key in o) {
        accounted_for[key] = 1;
      }
    }
  }
  for (const key in to_null_out) {
    if (!(key in update2))
      update2[key] = void 0;
  }
  return update2;
}
function get_spread_object(spread_props) {
  return typeof spread_props === "object" && spread_props !== null ? spread_props : {};
}
var _boolean_attributes = [
  "allowfullscreen",
  "allowpaymentrequest",
  "async",
  "autofocus",
  "autoplay",
  "checked",
  "controls",
  "default",
  "defer",
  "disabled",
  "formnovalidate",
  "hidden",
  "inert",
  "ismap",
  "loop",
  "multiple",
  "muted",
  "nomodule",
  "novalidate",
  "open",
  "playsinline",
  "readonly",
  "required",
  "reversed",
  "selected"
];
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor, customElement) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  if (!customElement) {
    add_render_callback(() => {
      const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
      if (component.$$.on_destroy) {
        component.$$.on_destroy.push(...new_on_destroy);
      } else {
        run_all(new_on_destroy);
      }
      component.$$.on_mount = [];
    });
  }
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init(component, options, instance10, create_fragment10, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance10 ? instance10(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment10 ? create_fragment10($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor, options.customElement);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor() {
      super();
      this.attachShadow({ mode: "open" });
    }
    connectedCallback() {
      const { on_mount } = this.$$;
      this.$$.on_disconnect = on_mount.map(run).filter(is_function);
      for (const key in this.$$.slotted) {
        this.appendChild(this.$$.slotted[key]);
      }
    }
    attributeChangedCallback(attr2, _oldValue, newValue) {
      this[attr2] = newValue;
    }
    disconnectedCallback() {
      run_all(this.$$.on_disconnect);
    }
    $destroy() {
      destroy_component(this, 1);
      this.$destroy = noop;
    }
    $on(type, callback) {
      if (!is_function(callback)) {
        return noop;
      }
      const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
      callbacks.push(callback);
      return () => {
        const index = callbacks.indexOf(callback);
        if (index !== -1)
          callbacks.splice(index, 1);
      };
    }
    $set($$props) {
      if (this.$$set && !is_empty($$props)) {
        this.$$.skip_bound = true;
        this.$$set($$props);
        this.$$.skip_bound = false;
      }
    }
  };
}
var SvelteComponent = class {
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  $set($$props) {
    if (this.$$set && !is_empty($$props)) {
      this.$$.skip_bound = true;
      this.$$set($$props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/store/index.mjs
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update2(fn) {
    set(fn(value));
  }
  function subscribe2(run2, invalidate = noop) {
    const subscriber = [run2, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set) || noop;
    }
    run2(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set, update: update2, subscribe: subscribe2 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  const auto = fn.length < 2;
  return readable(initial_value, (set) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set);
      if (auto) {
        set(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map((store, i) => subscribe(store, (value) => {
      values[i] = value;
      pending &= ~(1 << i);
      if (started) {
        sync();
      }
    }, () => {
      pending |= 1 << i;
    }));
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/constants.ts
var VIEW_TYPE_TIMELINE = "timeline";
var DEFAULT_DURATION_MINUTES = 30;
var SNAP_STEP_MINUTES = 10;
var ICONS = [
  "any-key",
  "audio-file",
  "blocks",
  "broken-link",
  "bullet-list",
  "calendar-with-checkmark",
  "checkmark",
  "create-new",
  "cross",
  "cross-in-box",
  "crossed-star",
  "dice",
  "document",
  "documents",
  "dot-network",
  "enter",
  "expand-vertically",
  "filled-pin",
  "folder",
  "gear",
  "go-to-file",
  "hashtag",
  "help",
  "horizontal-split",
  "image-file",
  "info",
  "install",
  "languages",
  "left-arrow",
  "left-arrow-with-tail",
  "lines-of-text",
  "link",
  "logo-crystal",
  "magnifying-glass",
  "microphone",
  "microphone-filled",
  "open-vault",
  "pane-layout",
  "paper-plane",
  "pdf-file",
  "pencil",
  "pin",
  "popup-open",
  "presentation",
  "reset",
  "right-arrow",
  "right-arrow-with-tail",
  "right-triangle",
  "search",
  "sheets-in-box",
  "star",
  "star-list",
  "switch",
  "three-horizontal-bars",
  "trash",
  "two-columns",
  "up-and-down-arrows",
  "uppercase-lowercase-a",
  "vault",
  "vertical-split",
  "vertical-three-dots"
];

// src/regexp.ts
var ulToken = `[-*+]`;
var olToken = `\\d+\\.`;
var listToken = `(${ulToken}|${olToken})\\s+`;
var checkbox = `\\[(?<completion>[^\\]])]\\s+`;
var checkboxOrNothing = `(${checkbox})?`;
var durationSeparator = `\\s*-{1,2}\\s*`;
var hours = `\\d{1,2}`;
var minutes = `\\d{2}`;
var hourMinuteSeparator = `[:. ]`;
var time = `(${hours})(?:${hourMinuteSeparator}?(${minutes}))?\\s*([ap]m)?`;
var timeRegExp = new RegExp(time);
var timestampRegExp = new RegExp(
  `^(?<listTokens>${listToken}${checkboxOrNothing})(?<times>(?<start>${time})(?:${durationSeparator}(?<end>${time}))?)(?<text>.+)$`,
  "im"
);

// src/util/moment.ts
var moment = window.moment;
function getMinutesSinceMidnight() {
  return moment().diff(moment().startOf("day"), "minutes");
}
function getMinutesSinceMidnightTo(someMoment) {
  return getDiffInMinutes(someMoment, moment().startOf("day"));
}
function getDiffInMinutes(a, b) {
  return Math.abs(a.diff(b, "minutes"));
}
function minutesToMoment(minutesSinceMidnight) {
  return moment().startOf("day").add(minutesSinceMidnight, "minutes");
}
function addMinutes(moment2, minutes2) {
  return moment2.clone().add(minutes2, "minutes");
}

// src/timestamp/timestamp.ts
function parseTimestamp(asText) {
  if (!asText) {
    return null;
  }
  const result = timeRegExp.exec(asText);
  if (result === null) {
    throw new Error(`${asText} is not a valid timestamp`);
  }
  const [, hours2, minutes2, ampm] = result;
  let parsedHours = parseInt(hours2);
  if (isNaN(parsedHours)) {
    throw new Error(`${asText} is not a valid timestamp`);
  }
  const parsedMinutes = parseInt(minutes2) || 0;
  if ((ampm == null ? void 0 : ampm.toLowerCase()) === "pm" && parsedHours < 12) {
    parsedHours += 12;
  }
  return window.moment({ hours: parsedHours, minutes: parsedMinutes });
}
function replaceTimestamp(planItem, { startMinutes, durationMinutes }) {
  return `${planItem.listTokens}${createTimestamp(
    startMinutes,
    durationMinutes
  )} ${planItem.text}`;
}
function createTimestamp(startMinutes, durationMinutes) {
  const start = minutesToMoment(startMinutes);
  const end = addMinutes(start, durationMinutes);
  return `${formatTimestamp(start)} - ${formatTimestamp(end)}`;
}
function formatTimestamp(moment2) {
  return moment2.format("HH:mm");
}

// obsidian-metadata-utils/src/position.ts
var getTextAtPosition = (textInput, pos) => textInput.substring(pos.start.offset, pos.end.offset);

// obsidian-metadata-utils/src/list.ts
function isTopLevelListItem(listItem) {
  return listItem.parent < 0;
}

// src/store/settings.ts
var settings = writable({
  zoomLevel: 2,
  startHour: 0,
  centerNeedle: true,
  timelineDateFormat: "LLLL",
  plannerHeading: "Day planner",
  plannerHeadingLevel: 1
});

// src/store/timeline-store.ts
var appStore = writable();
var tasks2 = writable([]);
var hourSize = derived(
  settings,
  ($settings) => $settings.zoomLevel * 60
);
var visibleHours = derived(
  settings,
  ($settings) => [...Array(24).keys()].slice($settings.startHour)
);
var hiddenHoursSize = derived(
  [settings, hourSize],
  ([$settings, $hourSize]) => $settings.startHour * $hourSize
);
var timeToTimelineOffset = derived(
  [settings, hiddenHoursSize],
  ([$settings, $hiddenHoursSize]) => (minutes2) => minutes2 * $settings.zoomLevel - $hiddenHoursSize
);
function roundToSnapStep(coords) {
  const { zoomLevel } = get_store_value(settings);
  return coords - coords % (SNAP_STEP_MINUTES * zoomLevel);
}
function getTimeFromYOffset(yCoords) {
  const { zoomLevel } = get_store_value(settings);
  return (yCoords + get_store_value(hiddenHoursSize)) / zoomLevel;
}
function sizeToDuration(size) {
  const { zoomLevel } = get_store_value(settings);
  return size / zoomLevel;
}
var durationToSize = derived(settings, ($settings) => {
  return (duration) => {
    const { zoomLevel } = $settings;
    return duration * zoomLevel;
  };
});

// src/util/daily-notes.ts
var import_obsidian_daily_notes_interface = __toESM(require_main());
async function createDailyNoteIfNeeded() {
  return getDailyNoteForToday() || (0, import_obsidian_daily_notes_interface.createDailyNote)(window.moment());
}
function getDailyNoteForToday() {
  return (0, import_obsidian_daily_notes_interface.getDailyNote)(window.moment(), (0, import_obsidian_daily_notes_interface.getAllDailyNotes)());
}
function dailyNoteExists() {
  return Boolean((0, import_obsidian_daily_notes_interface.getDailyNote)(window.moment(), (0, import_obsidian_daily_notes_interface.getAllDailyNotes)()));
}

// src/parser/parser.ts
function calculateDefaultDuration(item, next) {
  if (item.endTime) {
    return getDiffInMinutes(item.startTime, item.endTime);
  }
  if (next) {
    const minutesUntilNext = getDiffInMinutes(next.startTime, item.startTime);
    if (minutesUntilNext < DEFAULT_DURATION_MINUTES) {
      return minutesUntilNext;
    }
  }
  return DEFAULT_DURATION_MINUTES;
}
function parsePlanItems(content, metadata, planHeadingContent, path) {
  const listItemsUnderPlan = getListItemsUnderHeading(
    metadata,
    planHeadingContent
  );
  if (!listItemsUnderPlan) {
    return [];
  }
  const listItemsWithContent = getListItemContent(content, listItemsUnderPlan);
  return listItemsWithContent.map(
    (li) => createPlanItem({
      line: li.listItemLineContent,
      location: { path, line: li.line }
    })
  ).filter((item) => item !== null).map((item, index, items) => {
    const next = items[index + 1];
    const durationMinutes = calculateDefaultDuration(item, next);
    const endTime = item.endTime || item.startTime.clone().add(durationMinutes, "minutes");
    return {
      ...item,
      endTime,
      startMinutes: getMinutesSinceMidnightTo(item.startTime),
      endMinutes: getMinutesSinceMidnightTo(endTime),
      durationMinutes
    };
  });
}
function getListItemsUnderHeading(metadata, heading) {
  var _a;
  const { headings } = metadata;
  if (!headings) {
    return [];
  }
  const planHeadingIndex = headings.findIndex((h) => h.heading === heading);
  if (planHeadingIndex < 0) {
    return [];
  }
  const planHeading = headings[planHeadingIndex];
  const nextHeadingOfSameLevel = headings.slice(planHeadingIndex + 1).find((heading2) => heading2.level <= planHeading.level);
  return (_a = metadata.listItems) == null ? void 0 : _a.filter((li) => {
    const isBelowPlan = li.position.start.line > planHeading.position.start.line;
    const isAboveNextHeadingIfItExists = !nextHeadingOfSameLevel || li.position.start.line < nextHeadingOfSameLevel.position.start.line;
    return isBelowPlan && isAboveNextHeadingIfItExists;
  });
}
function getHeadingByText(metadata, text2) {
  const { headings } = metadata;
  return headings == null ? void 0 : headings.find((h) => h.heading === text2);
}
function createPlanItem({
  line,
  location
}) {
  const match = timestampRegExp.exec(line.trim());
  if (!match) {
    return null;
  }
  const {
    groups: { listTokens, start, end, text: text2 }
  } = match;
  return {
    listTokens,
    startTime: parseTimestamp(start),
    endTime: parseTimestamp(end),
    rawStartTime: start,
    rawEndTime: end,
    text: text2,
    location
  };
}
function groupTopListItemsWithDescendants(listItems) {
  return listItems.reduce((result, current) => {
    if (isTopLevelListItem(current)) {
      result.push({ root: current, descendants: [] });
    } else {
      const previousTopListItem = result[result.length - 1];
      previousTopListItem.descendants.push(current);
    }
    return result;
  }, []);
}
function getListItemContent(content, listItems) {
  return groupTopListItemsWithDescendants(listItems).map(
    ({ root, descendants }) => {
      var _a, _b;
      const lastDescendantPosition = (_b = (_a = descendants == null ? void 0 : descendants[descendants.length - 1]) == null ? void 0 : _a.position) == null ? void 0 : _b.end;
      const betweenRootAndLastDescendant = {
        start: root.position.start,
        end: lastDescendantPosition || root.position.end
      };
      return {
        line: root.position.start.line,
        listItemLineContent: getTextAtPosition(content, root.position),
        listItemCompleteContent: getTextAtPosition(
          content,
          betweenRootAndLastDescendant
        )
      };
    }
  );
}
function createPlanItemFromTimeline(pointerYOffset) {
  const startMinutes = getTimeFromYOffset(roundToSnapStep(pointerYOffset));
  const endMinutes = startMinutes + DEFAULT_DURATION_MINUTES;
  return {
    startMinutes,
    durationMinutes: DEFAULT_DURATION_MINUTES,
    endMinutes,
    text: "New item",
    startTime: minutesToMoment(startMinutes),
    endTime: minutesToMoment(endMinutes),
    // todo: no hardcode
    listTokens: "- ",
    location: {
      path: getDailyNoteForToday().path
    }
  };
}

// src/settings.ts
var DayPlannerSettings = class {
  constructor() {
    this.circularProgress = false;
    this.nowAndNextInStatusBar = false;
    this.showTaskNotification = false;
    this.zoomLevel = 2;
    this.timelineIcon = "calendar-with-checkmark";
    this.endLabel = "All done";
    this.startHour = 6;
    this.timelineDateFormat = "LLLL";
    this.centerNeedle = true;
    this.plannerHeading = "Day planner";
    this.plannerHeadingLevel = 1;
  }
};

// src/ui/settings-tab.ts
var import_obsidian = require("obsidian");
var DayPlannerSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Status Bar - Circular Progress").setDesc("Display a circular progress bar in the status bar").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.circularProgress).onChange((value) => {
        this.plugin.settings.circularProgress = value;
        this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Status Bar - Now and Next").setDesc("Display now and next tasks in the status bar").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.nowAndNextInStatusBar).onChange((value) => {
        this.plugin.settings.nowAndNextInStatusBar = value;
        this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Task Notification").setDesc("Display a notification when a new task is started").addToggle(
      (toggle) => toggle.setValue(this.plugin.settings.showTaskNotification).onChange((value) => {
        this.plugin.settings.showTaskNotification = value;
        this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Timeline Zoom Level").setDesc(
      "The zoom level to display the timeline. The higher the number, the more vertical space each task will take up."
    ).addSlider(
      (slider) => {
        var _a;
        return slider.setLimits(1, 5, 1).setValue((_a = Number(this.plugin.settings.zoomLevel)) != null ? _a : 4).setDynamicTooltip().onChange(async (value) => {
          settings.update((settings2) => ({ ...settings2, zoomLevel: value }));
          this.plugin.settings.zoomLevel = value;
          await this.plugin.saveData(this.plugin.settings);
        });
      }
    );
    new import_obsidian.Setting(containerEl).setName("Timeline Icon").setDesc(
      "The icon of the timeline pane. Reopen timeline pane or restart obsidian to see the change."
    ).addDropdown((dropdown) => {
      var _a;
      ICONS.forEach((icon) => dropdown.addOption(icon, icon));
      return dropdown.setValue(
        (_a = this.plugin.settings.timelineIcon) != null ? _a : "calendar-with-checkmark"
      ).onChange((value) => {
        this.plugin.settings.timelineIcon = value;
        this.plugin.saveData(this.plugin.settings);
      });
    });
    new import_obsidian.Setting(containerEl).setName("Start Hour").setDesc("The planner is going to start at this hour each day").addDropdown(
      (component) => component.addOptions({
        "0": "0",
        "1": "1",
        "2": "2",
        "3": "3",
        "4": "4",
        "5": "5",
        "6": "6",
        "7": "7",
        "8": "8",
        "9": "9",
        "10": "10",
        "11": "11",
        "12": "12"
      }).setValue(String(this.plugin.settings.startHour)).onChange(async (value) => {
        const asNumber = Number(value);
        settings.update((previous) => ({
          ...previous,
          startHour: asNumber
        }));
        this.plugin.settings.startHour = asNumber;
        await this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Date Format in Timeline Header").then((component) => {
      component.setDesc(
        createFragment((fragment) => {
          fragment.appendText("Your current syntax looks like this: ");
          component.addMomentFormat(
            (momentFormat) => momentFormat.setValue(this.plugin.settings.timelineDateFormat).setSampleEl(fragment.createSpan()).onChange(async (value) => {
              settings.update((previous) => ({
                ...previous,
                timelineDateFormat: value
              }));
              this.plugin.settings.timelineDateFormat = value;
              await this.plugin.saveData(this.plugin.settings);
            })
          );
          fragment.append(
            createEl("br"),
            createEl(
              "a",
              {
                text: "format reference",
                href: "https://momentjs.com/docs/#/displaying/format/"
              },
              (a) => {
                a.setAttr("target", "_blank");
              }
            )
          );
        })
      );
    });
    new import_obsidian.Setting(containerEl).setName("Center the Pointer in the Timeline View").setDesc(
      "Should the pointer continuously get scrolled to the center of the view"
    ).addToggle((component) => {
      component.setValue(this.plugin.settings.centerNeedle).onChange(async (value) => {
        settings.update((previous) => ({
          ...previous,
          centerNeedle: value
        }));
        this.plugin.settings.centerNeedle = value;
        await this.plugin.saveData(this.plugin.settings);
      });
    });
    new import_obsidian.Setting(containerEl).setName("Planner Heading").setDesc(
      `When you create a planner, this text is going to be in the heading.
When you open a file, the plugin will search for this heading to detect a day plan`
    ).addText(
      (component) => component.setValue(this.plugin.settings.plannerHeading).onChange(async (value) => {
        settings.update((previous) => ({
          ...previous,
          plannerHeading: value
        }));
        this.plugin.settings.plannerHeading = value;
        await this.plugin.saveData(this.plugin.settings);
      })
    );
    new import_obsidian.Setting(containerEl).setName("Planner heading level").setDesc(
      "When you create a planner in a file, this level of heading is going to be used"
    ).addSlider(
      (component) => component.setLimits(1, 6, 1).setDynamicTooltip().setValue(this.plugin.settings.plannerHeadingLevel).onChange(async (value) => {
        settings.update((previous) => ({
          ...previous,
          plannerHeadingLevel: value
        }));
        this.plugin.settings.plannerHeadingLevel = value;
        await this.plugin.saveData(this.plugin.settings);
      })
    );
  }
  modeDescriptionContent() {
    const descEl = document.createDocumentFragment();
    descEl.appendText("Choose between 3 modes to use the Day Planner plugin:");
    descEl.appendChild(document.createElement("br"));
    descEl.appendChild(document.createElement("strong")).appendText("File mode");
    descEl.appendChild(document.createElement("br"));
    descEl.appendText(
      "Plugin automatically generates day planner notes for each day within a Day Planners folder."
    );
    descEl.appendChild(document.createElement("br"));
    descEl.appendChild(document.createElement("strong")).appendText("Command mode");
    descEl.appendChild(document.createElement("br"));
    descEl.appendText(
      "Command used to insert a Day Planner for today within the current note."
    );
    descEl.appendChild(document.createElement("br"));
    descEl.appendChild(document.createElement("strong")).appendText("Daily mode");
    descEl.appendChild(document.createElement("br"));
    descEl.appendText(
      "Plugin automatically links to the current daily note. Daily notes plugin must be enabled."
    );
    descEl.appendChild(document.createElement("br"));
    this.addDocsLink(descEl);
    return descEl;
  }
  addDocsLink(descEl) {
    const a = document.createElement("a");
    a.href = "https://github.com/lynchjames/obsidian-day-planner/blob/main/README.md";
    a.text = "plugin README";
    a.target = "_blank";
    descEl.appendChild(a);
    descEl.appendChild(document.createElement("br"));
  }
};

// src/ui/status-bar.ts
var StatusBar = class {
  constructor(settings2, containerEl, workspace) {
    this.settings = settings2;
    this.containerEl = containerEl;
    this.workspace = workspace;
    this.containerEl.addClass("day-planner");
    this.setupCard();
    this.statusBarText = this.containerEl.createEl("span", {
      cls: ["status-bar-item-segment", "day-planner-status-bar-text"]
    });
    this.setupCircularProgressBar();
    this.setupHorizontalProgressBar();
    this.nextText = this.containerEl.createEl("span", {
      cls: ["status-bar-item-segment", "day-planner-status-bar-text"]
    });
    this.setupStatusBarEvents();
  }
  async update(planItems) {
    this.containerEl.show();
    if (planItems.length > 0) {
      this.updateProgress(planItems);
    } else {
      this.setEmpty();
    }
  }
  setEmpty() {
    this.setText("No plan for today");
  }
  setText(text2) {
    this.statusBarText.textContent = text2;
  }
  setupStatusBarEvents() {
    this.containerEl.onClickEvent(async () => {
    });
    this.containerEl.on("mouseenter", ".day-planner", () => {
      this.card.show();
    });
    this.containerEl.on("mouseleave", ".day-planner", () => {
      this.card.hide();
    });
  }
  hideProgress() {
    this.statusBarProgress.hide();
    this.circle.hide();
    this.nextText.hide();
  }
  updateProgress(planItems) {
    const now2 = window.moment();
    const currentItemIndex = planItems.findIndex(
      (item) => item.startTime.isBefore(now2) && item.endTime.isAfter(now2)
    );
    if (currentItemIndex < 0) {
      this.hideProgress();
      this.statusBarText.innerText = this.settings.endLabel;
      return;
    }
    const currentItem = planItems[currentItemIndex];
    const nextItem = planItems[currentItemIndex + 1];
    const minutesFromStart = getDiffInMinutes(currentItem.startTime, now2);
    const percentageComplete = minutesFromStart / (currentItem.durationMinutes / 100);
    this.updateStatusBarText(currentItem, nextItem);
    if (nextItem) {
      this.setStatusText(
        getDiffInMinutes(now2, nextItem.startTime),
        currentItem,
        nextItem,
        percentageComplete
      );
    }
    if (this.settings.circularProgress) {
      this.statusBarProgress.hide();
      this.progressCircle(percentageComplete);
    } else {
      this.circle.hide();
      this.progressBar(percentageComplete);
    }
  }
  progressBar(percentageComplete) {
    this.statusBarCurrentProgress.style.width = `${percentageComplete}%`;
    this.statusBarProgress.show();
  }
  progressCircle(percentageComplete) {
    this.circle.setAttr("data-value", percentageComplete.toFixed(0));
    this.circle.show();
  }
  setStatusText(minsUntilNext, current, next, percentageComplete) {
    const minsUntilNextText = minsUntilNext === 0 ? "1" : minsUntilNext;
    const minsText = `${minsUntilNextText} min${minsUntilNextText === "1" ? "" : "s"}`;
    const percent = percentageComplete.toFixed(0);
    const currentTaskStatus = `Current Task (${percent}% complete)`;
    const currentTaskTimeAndText = `${current.rawStartTime} ${current.text}`;
    const nextTask = `Next Task (in ${minsText})`;
    const nextTaskTimeAndText = `${next.rawStartTime} ${next.text}`;
    this.cardCurrent.textContent = `${currentTaskStatus}: ${currentTaskTimeAndText}`;
    this.cardNext.textContent = `${nextTask}: ${nextTaskTimeAndText}`;
    this.taskNotification(
      current,
      currentTaskTimeAndText,
      nextTask,
      nextTaskTimeAndText
    );
  }
  updateStatusBarText(currentItem, nextItem) {
    if (this.settings.nowAndNextInStatusBar) {
      this.statusBarText.textContent = `Now: ${currentItem.rawStartTime} ${this.ellipsis(currentItem.text, 15)}`;
      if (nextItem) {
        this.nextText.textContent = `Next: ${nextItem.rawStartTime} ${this.ellipsis(nextItem.text, 15)}`;
        this.nextText.show();
      }
      this.nextText.hide();
    } else {
      this.nextText.hide();
      const minutesLeft = getDiffInMinutes(
        currentItem.endTime,
        window.moment()
      );
      this.statusBarText.textContent = `Minutes left: ${minutesLeft}`;
    }
  }
  taskNotification(current, currentTaskTimeAndText, nextTask, nextTaskText) {
    if (this.settings.showTaskNotification && this.currentTime !== void 0 && this.currentTime !== current.startTime.toString()) {
      new Notification(`Task started, ${currentTaskTimeAndText}`, {
        body: `${nextTask}: ${nextTaskText}`,
        requireInteraction: true
      });
    }
    this.currentTime = current.startTime.toString();
  }
  // todo: this doesn't belong to the class
  ellipsis(input, limit) {
    if (input.length <= limit) {
      return input;
    }
    return input.substring(0, limit) + "...";
  }
  setupHorizontalProgressBar() {
    this.statusBarProgress = this.containerEl.createEl("div", {
      cls: ["status-bar-item-segment", "day-planner-progress-bar"]
    });
    this.statusBarProgress.hide();
    this.statusBarCurrentProgress = this.statusBarProgress.createEl("div", {
      cls: "day-planner-progress-value"
    });
  }
  setupCircularProgressBar() {
    this.circle = this.containerEl.createEl("div", {
      cls: ["status-bar-item-segment", "progress-pie day-planner"]
    });
  }
  setupCard() {
    this.card = this.containerEl.createEl("div", {
      cls: "day-planner-status-card"
    });
    this.cardCurrent = this.card.createEl("span");
    this.card.createEl("br");
    this.card.createEl("br");
    this.cardNext = this.card.createEl("span");
    this.card.createEl("div", { cls: "arrow-down" });
  }
};

// src/ui/timeline-view.ts
var import_obsidian6 = require("obsidian");

// src/ui/components/ruler.svelte
function add_css(target) {
  append_styles(target, "svelte-1jithf5", ".hours-container.svelte-1jithf5.svelte-1jithf5{display:flex;flex:0 0 40px;flex-direction:column}.hour.svelte-1jithf5.svelte-1jithf5{display:flex;flex-grow:1;flex-shrink:0}.hour-guide.svelte-1jithf5.svelte-1jithf5{flex:0 0 10px}.hour.svelte-1jithf5:not(:first-child) .hour-guide.svelte-1jithf5{border-top:1px solid var(--background-modifier-border)}.hour-number-container.svelte-1jithf5.svelte-1jithf5{position:sticky;top:10px;display:flex;flex:0 0 30px;align-self:flex-start;justify-content:center;color:var(--text-faint)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[2] = list[i];
  return child_ctx;
}
function create_each_block(ctx) {
  let div2;
  let div0;
  let t0_value = (
    /*hour*/
    ctx[2] + ""
  );
  let t0;
  let t1;
  let div1;
  let t2;
  let style_height = `${/*$hourSize*/
  ctx[1]}px`;
  return {
    c() {
      div2 = element("div");
      div0 = element("div");
      t0 = text(t0_value);
      t1 = space();
      div1 = element("div");
      t2 = space();
      attr(div0, "class", "hour-number-container svelte-1jithf5");
      set_style(div0, "transform", `translateY(-10px)`);
      attr(div1, "class", "hour-guide svelte-1jithf5");
      attr(div2, "class", "hour svelte-1jithf5");
      set_style(div2, "height", style_height);
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append(div2, div0);
      append(div0, t0);
      append(div2, t1);
      append(div2, div1);
      append(div2, t2);
    },
    p(ctx2, dirty) {
      if (dirty & /*visibleHours*/
      1 && t0_value !== (t0_value = /*hour*/
      ctx2[2] + ""))
        set_data(t0, t0_value);
      if (dirty & /*$hourSize*/
      2 && style_height !== (style_height = `${/*$hourSize*/
      ctx2[1]}px`)) {
        set_style(div2, "height", style_height);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div2);
    }
  };
}
function create_fragment(ctx) {
  let div;
  let each_value = (
    /*visibleHours*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "hours-container svelte-1jithf5");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$hourSize, visibleHours*/
      3) {
        each_value = /*visibleHours*/
        ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $hourSize;
  component_subscribe($$self, hourSize, ($$value) => $$invalidate(1, $hourSize = $$value));
  let { visibleHours: visibleHours2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("visibleHours" in $$props2)
      $$invalidate(0, visibleHours2 = $$props2.visibleHours);
  };
  return [visibleHours2, $hourSize];
}
var Ruler = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance, create_fragment, safe_not_equal, { visibleHours: 0 }, add_css);
  }
};
var ruler_default = Ruler;

// src/ui/components/column.svelte
function add_css2(target) {
  append_styles(target, "svelte-1s9ai9w", ".task-grid.svelte-1s9ai9w{position:relative;flex:1 0 0}.time-grid-block.svelte-1s9ai9w{flex-grow:1;flex-shrink:0;border-left:1px solid var(--background-modifier-border)}.half-hour-separator.svelte-1s9ai9w{border-bottom:1px dashed var(--background-modifier-border)}.time-grid-block.svelte-1s9ai9w:not(:nth-child(2)){border-top:1px solid var(--background-modifier-border)}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[4] = list[i];
  return child_ctx;
}
function create_each_block2(ctx) {
  let div1;
  let div0;
  let style_height = `${/*$hourSize*/
  ctx[1] / 2}px`;
  let t;
  let style_height_1 = `${/*$hourSize*/
  ctx[1]}px`;
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      t = space();
      attr(div0, "class", "half-hour-separator svelte-1s9ai9w");
      set_style(div0, "height", style_height);
      attr(div1, "class", "time-grid-block svelte-1s9ai9w");
      set_style(div1, "height", style_height_1);
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div1, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$hourSize*/
      2 && style_height !== (style_height = `${/*$hourSize*/
      ctx2[1] / 2}px`)) {
        set_style(div0, "height", style_height);
      }
      if (dirty & /*$hourSize*/
      2 && style_height_1 !== (style_height_1 = `${/*$hourSize*/
      ctx2[1]}px`)) {
        set_style(div1, "height", style_height_1);
      }
    },
    d(detaching) {
      if (detaching)
        detach(div1);
    }
  };
}
function create_fragment2(ctx) {
  let div;
  let t;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[3].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[2],
    null
  );
  let each_value = (
    /*visibleHours*/
    ctx[0]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      if (default_slot)
        default_slot.c();
      t = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "task-grid svelte-1s9ai9w");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (default_slot) {
        default_slot.m(div, null);
      }
      append(div, t);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        4)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[2],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[2]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[2],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (dirty & /*$hourSize, visibleHours*/
      3) {
        each_value = /*visibleHours*/
        ctx2[0];
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div);
      if (default_slot)
        default_slot.d(detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let $hourSize;
  component_subscribe($$self, hourSize, ($$value) => $$invalidate(1, $hourSize = $$value));
  let { $$slots: slots = {}, $$scope } = $$props;
  let { visibleHours: visibleHours2 } = $$props;
  $$self.$$set = ($$props2) => {
    if ("visibleHours" in $$props2)
      $$invalidate(0, visibleHours2 = $$props2.visibleHours);
    if ("$$scope" in $$props2)
      $$invalidate(2, $$scope = $$props2.$$scope);
  };
  return [visibleHours2, $hourSize, $$scope, slots];
}
var Column = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance2, create_fragment2, safe_not_equal, { visibleHours: 0 }, add_css2);
  }
};
var column_default = Column;

// src/ui/components/needle.svelte
function add_css3(target) {
  append_styles(target, "svelte-1hw295n", ".needle.svelte-1hw295n{height:4px;background-color:var(--color-accent)}");
}
function create_fragment3(ctx) {
  let div;
  let style_transform = `translateY(${/*coords*/
  ctx[1]}px)`;
  return {
    c() {
      div = element("div");
      attr(div, "class", "needle absolute-stretch-x svelte-1hw295n");
      set_style(div, "transform", style_transform);
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[4](div);
    },
    p(ctx2, [dirty]) {
      if (dirty & /*coords*/
      2 && style_transform !== (style_transform = `translateY(${/*coords*/
      ctx2[1]}px)`)) {
        set_style(div, "transform", style_transform);
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[4](null);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let coords;
  let $timeToTimelineOffset;
  let $settings;
  component_subscribe($$self, timeToTimelineOffset, ($$value) => $$invalidate(3, $timeToTimelineOffset = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(5, $settings = $$value));
  let { scrollBlockedByUser = false } = $$props;
  let el;
  function scrollIntoView() {
    if ($settings.centerNeedle && !scrollBlockedByUser) {
      el === null || el === void 0 ? void 0 : el.scrollIntoView({ behavior: "smooth", block: "center" });
    }
  }
  onMount(() => {
    const interval = setInterval(
      () => {
        $$invalidate(1, coords = $timeToTimelineOffset(getMinutesSinceMidnight()));
        scrollIntoView();
      },
      2e3
    );
    return () => clearInterval(interval);
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("scrollBlockedByUser" in $$props2)
      $$invalidate(2, scrollBlockedByUser = $$props2.scrollBlockedByUser);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*$timeToTimelineOffset*/
    8) {
      $:
        $$invalidate(1, coords = $timeToTimelineOffset(getMinutesSinceMidnight()));
    }
  };
  return [el, coords, scrollBlockedByUser, $timeToTimelineOffset, div_binding];
}
var Needle = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance3, create_fragment3, safe_not_equal, { scrollBlockedByUser: 2 }, add_css3);
  }
};
var needle_default = Needle;

// src/ui/components/rendered-markdown.svelte
var import_obsidian2 = require("obsidian");
function add_css4(target) {
  append_styles(target, "svelte-1lk5xxv", ".rendered-markdown.svelte-1lk5xxv p{margin-block-start:0;margin-block-end:0}");
}
function create_fragment4(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      attr(div, "class", "rendered-markdown svelte-1lk5xxv");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      ctx[4](div);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      ctx[4](null);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let $appStore;
  component_subscribe($$self, appStore, ($$value) => $$invalidate(3, $appStore = $$value));
  let { text: text2 } = $$props;
  let markdownLifecycleManager = new import_obsidian2.Component();
  let renderedMarkdown;
  onDestroy(() => {
    markdownLifecycleManager.unload();
  });
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      renderedMarkdown = $$value;
      $$invalidate(0, renderedMarkdown);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(1, text2 = $$props2.text);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*renderedMarkdown, markdownLifecycleManager, $appStore, text*/
    15) {
      $:
        if (renderedMarkdown) {
          markdownLifecycleManager.unload();
          $$invalidate(2, markdownLifecycleManager = new import_obsidian2.Component());
          renderedMarkdown.empty();
          import_obsidian2.MarkdownRenderer.render($appStore, text2, renderedMarkdown, "", markdownLifecycleManager);
          markdownLifecycleManager.load();
        }
    }
  };
  return [renderedMarkdown, text2, markdownLifecycleManager, $appStore, div_binding];
}
var Rendered_markdown = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance4, create_fragment4, safe_not_equal, { text: 1 }, add_css4);
  }
};
var rendered_markdown_default = Rendered_markdown;

// node_modules/svelte/transition/index.mjs
function fade(node, { delay = 0, duration = 400, easing = identity } = {}) {
  const o = +getComputedStyle(node).opacity;
  return {
    delay,
    duration,
    easing,
    css: (t) => `opacity: ${t * o}`
  };
}

// src/store/update-timestamp.ts
var import_obsidian3 = require("obsidian");
async function updateTimestamps(id, timestamp) {
  tasks2.update((previous) => {
    return previous.map((task) => {
      if (task.text !== id) {
        return task;
      }
      updateDurationInDailyNote(task, timestamp);
      return {
        ...task,
        ...timestamp
      };
    });
  });
}
async function updateDurationInDailyNote(task, startAndDuration) {
  const file = get_store_value(appStore).vault.getAbstractFileByPath(task.location.path);
  if (!(file instanceof import_obsidian3.TFile)) {
    throw new Error("Something is wrong");
  }
  const contents = await get_store_value(appStore).vault.read(file);
  const updated = contents.split("\n").map((line, i) => {
    if (i === task.location.line) {
      return replaceTimestamp(task, startAndDuration);
    }
    return line;
  }).join("\n");
  await get_store_value(appStore).vault.modify(file, updated);
}

// src/ui/hooks/use-drag.ts
function useDrag() {
  const dragging = writable(false);
  const pointerYOffsetToTaskStart = writable();
  function handleMoveStart(event) {
    dragging.set(true);
    pointerYOffsetToTaskStart.set(event.offsetY);
  }
  function handleMoveCancel() {
    dragging.set(false);
  }
  async function handleMoveConfirm(offset, text2, durationMinutes) {
    dragging.set(false);
    const newStartMinutes = getTimeFromYOffset(offset);
    await updateTimestamps(text2, {
      startMinutes: newStartMinutes,
      durationMinutes
    });
  }
  return {
    pointerYOffsetToTaskStart,
    dragging,
    handleMoveStart,
    handleMoveCancel,
    handleMoveConfirm
  };
}

// src/ui/hooks/use-resize.ts
function useResize() {
  const resizing = writable(false);
  function handleResizeStart() {
    resizing.set(true);
  }
  function handleResizeCancel() {
    resizing.set(false);
  }
  async function handleResizeConfirm(text2, taskHeight, startMinutes) {
    if (!get_store_value(resizing)) {
      return;
    }
    resizing.set(false);
    const newDurationMinutes = sizeToDuration(taskHeight);
    await updateTimestamps(text2, {
      startMinutes,
      durationMinutes: newDurationMinutes
    });
  }
  return {
    resizing,
    handleResizeStart,
    handleResizeConfirm,
    handleResizeCancel
  };
}

// src/ui/components/task.svelte
function add_css5(target) {
  append_styles(target, "svelte-oj0pyr", ".task.svelte-oj0pyr{overflow:visible;display:flex;align-items:flex-start;justify-content:flex-start;padding:5px;font-size:var(--font-ui-medium);color:var(--text-muted);text-align:left;white-space:normal;background-color:var(--background-primary);border:1px solid var(--color-accent);border-radius:var(--radius-s);box-shadow:none;transition-property:height, transform;transition:0.05s linear}.is-ghost.svelte-oj0pyr{opacity:60%}.task.svelte-oj0pyr:hover{cursor:grab}.resize-handle.svelte-oj0pyr{bottom:-15px;height:30px;cursor:s-resize}");
}
function create_fragment5(ctx) {
  let t0;
  let div1;
  let renderedmarkdown;
  let t1;
  let div0;
  let div1_transition;
  let style_height = `${/*height*/
  ctx[6]}px`;
  let style_transform = `translateY(${/*offset*/
  ctx[7]}px)`;
  let current;
  let mounted;
  let dispose;
  renderedmarkdown = new rendered_markdown_default({ props: { text: (
    /*text*/
    ctx[0]
  ) } });
  return {
    c() {
      t0 = space();
      div1 = element("div");
      create_component(renderedmarkdown.$$.fragment);
      t1 = space();
      div0 = element("div");
      attr(div0, "class", "resize-handle absolute-stretch-x svelte-oj0pyr");
      attr(div1, "class", "task absolute-stretch-x svelte-oj0pyr");
      toggle_class(
        div1,
        "is-ghost",
        /*isGhost*/
        ctx[4]
      );
      set_style(div1, "height", style_height);
      set_style(div1, "transform", style_transform);
      set_style(
        div1,
        "cursor",
        /*cursor*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      mount_component(renderedmarkdown, div1, null);
      append(div1, t1);
      append(div1, div0);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            document.body,
            "mouseup",
            /*handleCancel*/
            ctx[15]
          ),
          listen(div0, "mousedown", stop_propagation(
            /*handleResizeStart*/
            ctx[13]
          )),
          listen(
            div0,
            "mouseup",
            /*mouseup_handler*/
            ctx[25]
          ),
          listen(div1, "mousedown", stop_propagation(
            /*handleMoveStart*/
            ctx[10]
          )),
          listen(
            div1,
            "mouseup",
            /*mouseup_handler_1*/
            ctx[26]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const renderedmarkdown_changes = {};
      if (dirty & /*text*/
      1)
        renderedmarkdown_changes.text = /*text*/
        ctx2[0];
      renderedmarkdown.$set(renderedmarkdown_changes);
      if (!current || dirty & /*isGhost*/
      16) {
        toggle_class(
          div1,
          "is-ghost",
          /*isGhost*/
          ctx2[4]
        );
      }
      if (dirty & /*height*/
      64 && style_height !== (style_height = `${/*height*/
      ctx2[6]}px`)) {
        set_style(div1, "height", style_height);
      }
      if (dirty & /*offset*/
      128 && style_transform !== (style_transform = `translateY(${/*offset*/
      ctx2[7]}px)`)) {
        set_style(div1, "transform", style_transform);
      }
      if (dirty & /*cursor*/
      32) {
        set_style(
          div1,
          "cursor",
          /*cursor*/
          ctx2[5]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(renderedmarkdown.$$.fragment, local);
      add_render_callback(() => {
        if (!current)
          return;
        if (!div1_transition)
          div1_transition = create_bidirectional_transition(div1, fade, { duration: 100 }, true);
        div1_transition.run(1);
      });
      current = true;
    },
    o(local) {
      transition_out(renderedmarkdown.$$.fragment, local);
      if (!div1_transition)
        div1_transition = create_bidirectional_transition(div1, fade, { duration: 100 }, false);
      div1_transition.run(0);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      destroy_component(renderedmarkdown);
      if (detaching && div1_transition)
        div1_transition.end();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let initialOffset;
  let offset;
  let offsetToPointer;
  let height;
  let cursor;
  let $dragging;
  let $durationToSize;
  let $settings;
  let $resizing;
  let $pointerYOffset, $$unsubscribe_pointerYOffset = noop, $$subscribe_pointerYOffset = () => ($$unsubscribe_pointerYOffset(), $$unsubscribe_pointerYOffset = subscribe(pointerYOffset, ($$value) => $$invalidate(22, $pointerYOffset = $$value)), pointerYOffset);
  let $pointerYOffsetToTaskStart;
  let $timeToTimelineOffset;
  component_subscribe($$self, durationToSize, ($$value) => $$invalidate(19, $durationToSize = $$value));
  component_subscribe($$self, settings, ($$value) => $$invalidate(20, $settings = $$value));
  component_subscribe($$self, timeToTimelineOffset, ($$value) => $$invalidate(24, $timeToTimelineOffset = $$value));
  $$self.$$.on_destroy.push(() => $$unsubscribe_pointerYOffset());
  let { text: text2 } = $$props;
  let { startMinutes = void 0 } = $$props;
  let { durationMinutes } = $$props;
  let { pointerYOffset } = $$props;
  $$subscribe_pointerYOffset();
  let { isGhost = false } = $$props;
  const { dragging, pointerYOffsetToTaskStart, handleMoveStart, handleMoveCancel, handleMoveConfirm } = useDrag();
  component_subscribe($$self, dragging, (value) => $$invalidate(18, $dragging = value));
  component_subscribe($$self, pointerYOffsetToTaskStart, (value) => $$invalidate(23, $pointerYOffsetToTaskStart = value));
  const { resizing, handleResizeStart, handleResizeCancel, handleResizeConfirm } = useResize();
  component_subscribe($$self, resizing, (value) => $$invalidate(21, $resizing = value));
  function handleCancel() {
    handleMoveCancel();
    handleResizeCancel();
  }
  const mouseup_handler = () => handleResizeConfirm(text2, height, startMinutes);
  const mouseup_handler_1 = () => handleMoveConfirm(Math.floor(offset), text2, durationMinutes);
  $$self.$$set = ($$props2) => {
    if ("text" in $$props2)
      $$invalidate(0, text2 = $$props2.text);
    if ("startMinutes" in $$props2)
      $$invalidate(1, startMinutes = $$props2.startMinutes);
    if ("durationMinutes" in $$props2)
      $$invalidate(2, durationMinutes = $$props2.durationMinutes);
    if ("pointerYOffset" in $$props2)
      $$subscribe_pointerYOffset($$invalidate(3, pointerYOffset = $$props2.pointerYOffset));
    if ("isGhost" in $$props2)
      $$invalidate(4, isGhost = $$props2.isGhost);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*isGhost, $pointerYOffset, $timeToTimelineOffset, startMinutes*/
    20971538) {
      $:
        $$invalidate(17, initialOffset = isGhost ? roundToSnapStep($pointerYOffset) : $timeToTimelineOffset(startMinutes));
    }
    if ($$self.$$.dirty & /*$dragging, $pointerYOffset, $pointerYOffsetToTaskStart, initialOffset*/
    12976128) {
      $:
        $$invalidate(7, offset = $dragging ? roundToSnapStep($pointerYOffset - $pointerYOffsetToTaskStart) : initialOffset);
    }
    if ($$self.$$.dirty & /*$pointerYOffset, initialOffset*/
    4325376) {
      $:
        $$invalidate(16, offsetToPointer = $pointerYOffset - initialOffset);
    }
    if ($$self.$$.dirty & /*$resizing, offsetToPointer, $settings, $durationToSize, durationMinutes*/
    3735556) {
      $:
        $$invalidate(6, height = $resizing ? roundToSnapStep(offsetToPointer) + SNAP_STEP_MINUTES * $settings.zoomLevel : $durationToSize(durationMinutes));
    }
    if ($$self.$$.dirty & /*$dragging*/
    262144) {
      $:
        $$invalidate(5, cursor = $dragging ? "grabbing" : "grab");
    }
  };
  return [
    text2,
    startMinutes,
    durationMinutes,
    pointerYOffset,
    isGhost,
    cursor,
    height,
    offset,
    dragging,
    pointerYOffsetToTaskStart,
    handleMoveStart,
    handleMoveConfirm,
    resizing,
    handleResizeStart,
    handleResizeConfirm,
    handleCancel,
    offsetToPointer,
    initialOffset,
    $dragging,
    $durationToSize,
    $settings,
    $resizing,
    $pointerYOffset,
    $pointerYOffsetToTaskStart,
    $timeToTimelineOffset,
    mouseup_handler,
    mouseup_handler_1
  ];
}
var Task = class extends SvelteComponent {
  constructor(options) {
    super();
    init(
      this,
      options,
      instance5,
      create_fragment5,
      safe_not_equal,
      {
        text: 0,
        startMinutes: 1,
        durationMinutes: 2,
        pointerYOffset: 3,
        isGhost: 4
      },
      add_css5
    );
  }
};
var task_default = Task;

// src/util/obsidian.ts
var import_obsidian4 = require("obsidian");
async function openFileInEditor(file) {
  var _a;
  const app = get_store_value(appStore);
  const leaf = app.workspace.getLeaf(false);
  await leaf.openFile(file);
  return (_a = app.workspace.activeEditor) == null ? void 0 : _a.editor;
}
async function getFileByPath(path) {
  const app = get_store_value(appStore);
  const file = app.vault.getAbstractFileByPath(path);
  if (!(file instanceof import_obsidian4.TFile)) {
    throw new Error(`Unable to open file: ${path}`);
  }
  return file;
}

// src/util/editor.ts
function selectText(editor, text2) {
  const startOffset = editor.getValue().lastIndexOf(text2);
  const endOffset = startOffset + text2.length;
  editor.setSelection(
    editor.offsetToPos(startOffset),
    editor.offsetToPos(endOffset)
  );
}

// src/plan.ts
function createPlannerHeading() {
  const { plannerHeading, plannerHeadingLevel } = get_store_value(settings);
  const headingTokens = "#".repeat(plannerHeadingLevel);
  return `${headingTokens} ${plannerHeading}`;
}
async function appendToPlan(path, planItem) {
  const app = get_store_value(appStore);
  const { plannerHeading } = get_store_value(settings);
  const file = await getFileByPath(path);
  const metadata = app.metadataCache.getFileCache(file);
  const editor = await openFileInEditor(file);
  let result = replaceTimestamp(planItem, { ...planItem });
  const headingLine = getHeadingByText(metadata, plannerHeading);
  let line = editor.lastLine();
  if (!headingLine) {
    result = `${createPlannerHeading()}

${result}`;
  } else {
    line = headingLine.position.start.line;
  }
  const listItems = getListItemsUnderHeading(metadata, plannerHeading);
  if ((listItems == null ? void 0 : listItems.length) > 0) {
    const lastListItem = listItems[listItems.length - 1];
    line = lastListItem.position.start.line;
  } else if (headingLine) {
    result = `
${result}`;
  }
  const ch = editor.getLine(line).length;
  editor.replaceRange(`
${result}`, { line, ch });
  selectText(editor, planItem.text);
}

// src/ui/hooks/use-create.ts
function useCreate() {
  const creating = writable(false);
  function startCreation() {
    creating.set(true);
  }
  function cancelCreation() {
    creating.set(false);
  }
  async function confirmCreation(pointerYOffset) {
    if (!get_store_value(creating)) {
      return;
    }
    creating.set(false);
    const newPlanItem = createPlanItemFromTimeline(pointerYOffset);
    tasks2.update((previous) => [...previous, newPlanItem]);
    await appendToPlan(getDailyNoteForToday().path, newPlanItem);
  }
  return {
    creating,
    startCreation,
    cancelCreation,
    confirmCreation
  };
}

// src/ui/components/task-container.svelte
function add_css6(target) {
  append_styles(target, "svelte-75n1s6", ".task-container.svelte-75n1s6{top:0;bottom:0;display:flex;flex-direction:column;margin-right:10px;margin-left:20px}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
function create_each_block3(key_1, ctx) {
  let first;
  let task;
  let current;
  const task_spread_levels = [
    /*taskProps*/
    ctx[12],
    {
      pointerYOffset: (
        /*pointerYOffset*/
        ctx[8]
      )
    }
  ];
  let task_props = {};
  for (let i = 0; i < task_spread_levels.length; i += 1) {
    task_props = assign(task_props, task_spread_levels[i]);
  }
  task = new task_default({ props: task_props });
  return {
    key: key_1,
    first: null,
    c() {
      first = empty();
      create_component(task.$$.fragment);
      this.first = first;
    },
    m(target, anchor) {
      insert(target, first, anchor);
      mount_component(task, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const task_changes = dirty & /*$tasks, pointerYOffset*/
      260 ? get_spread_update(task_spread_levels, [
        dirty & /*$tasks*/
        4 && get_spread_object(
          /*taskProps*/
          ctx[12]
        ),
        dirty & /*pointerYOffset*/
        256 && {
          pointerYOffset: (
            /*pointerYOffset*/
            ctx[8]
          )
        }
      ]) : {};
      task.$set(task_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(task.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(task.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(first);
      destroy_component(task, detaching);
    }
  };
}
function create_if_block(ctx) {
  let task;
  let current;
  task = new task_default({
    props: {
      isGhost: true,
      text: cancelMessage,
      durationMinutes: defaultDurationForNewTask,
      pointerYOffset: (
        /*pointerYOffset*/
        ctx[8]
      )
    }
  });
  return {
    c() {
      create_component(task.$$.fragment);
    },
    m(target, anchor) {
      mount_component(task, target, anchor);
      current = true;
    },
    p: noop,
    i(local) {
      if (current)
        return;
      transition_in(task.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(task.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(task, detaching);
    }
  };
}
function create_fragment6(ctx) {
  let t0;
  let div;
  let each_blocks = [];
  let each_1_lookup = /* @__PURE__ */ new Map();
  let t1;
  let current;
  let mounted;
  let dispose;
  let each_value = (
    /*$tasks*/
    ctx[2]
  );
  const get_key = (ctx2) => (
    /*taskProps*/
    ctx2[12].text
  );
  for (let i = 0; i < each_value.length; i += 1) {
    let child_ctx = get_each_context3(ctx, each_value, i);
    let key = get_key(child_ctx);
    each_1_lookup.set(key, each_blocks[i] = create_each_block3(key, child_ctx));
  }
  let if_block = (
    /*$creating*/
    ctx[3] && create_if_block(ctx)
  );
  return {
    c() {
      t0 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t1 = space();
      if (if_block)
        if_block.c();
      attr(div, "class", "task-container absolute-stretch-x svelte-75n1s6");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append(div, t1);
      if (if_block)
        if_block.m(div, null);
      ctx[10](div);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            document,
            "mouseup",
            /*cancelCreation*/
            ctx[6]
          ),
          listen(
            div,
            "mousemove",
            /*handleMousemove*/
            ctx[9]
          ),
          listen(
            div,
            "mousedown",
            /*startCreation*/
            ctx[5]
          ),
          listen(
            div,
            "mouseup",
            /*mouseup_handler*/
            ctx[11]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$tasks, pointerYOffset*/
      260) {
        each_value = /*$tasks*/
        ctx2[2];
        group_outros();
        each_blocks = update_keyed_each(each_blocks, dirty, get_key, 1, ctx2, each_value, each_1_lookup, div, outro_and_destroy_block, create_each_block3, t1, get_each_context3);
        check_outros();
      }
      if (
        /*$creating*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*$creating*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(div, null);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block);
      current = true;
    },
    o(local) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div);
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].d();
      }
      if (if_block)
        if_block.d();
      ctx[10](null);
      mounted = false;
      run_all(dispose);
    }
  };
}
var cancelMessage = "Release outside timeline to cancel";
var defaultDurationForNewTask = 30;
function instance6($$self, $$props, $$invalidate) {
  let $pointerYOffset;
  let $tasks;
  let $creating;
  component_subscribe($$self, tasks2, ($$value) => $$invalidate(2, $tasks = $$value));
  const { creating, startCreation, cancelCreation, confirmCreation } = useCreate();
  component_subscribe($$self, creating, (value) => $$invalidate(3, $creating = value));
  const pointerYOffset = writable();
  component_subscribe($$self, pointerYOffset, (value) => $$invalidate(1, $pointerYOffset = value));
  let el;
  function handleMousemove(event) {
    pointerYOffset.set(event.clientY - el.getBoundingClientRect().top);
  }
  function div_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      el = $$value;
      $$invalidate(0, el);
    });
  }
  const mouseup_handler = () => confirmCreation($pointerYOffset);
  return [
    el,
    $pointerYOffset,
    $tasks,
    $creating,
    creating,
    startCreation,
    cancelCreation,
    confirmCreation,
    pointerYOffset,
    handleMousemove,
    div_binding,
    mouseup_handler
  ];
}
var Task_container = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance6, create_fragment6, safe_not_equal, {}, add_css6);
  }
};
var task_container_default = Task_container;

// src/ui/components/settings-button.svelte
function add_css7(target) {
  append_styles(target, "svelte-eweyv0", ".clickable-icon.svelte-eweyv0{flex-basis:var(--input-height);align-self:center}");
}
function create_fragment7(ctx) {
  let div;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<svg class="svg-icon lucide-sliders-horizontal" fill="none" height="24" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="2" viewBox="0 0 24 24" width="24" xmlns="http://www.w3.org/2000/svg"><line x1="21" x2="14" y1="4" y2="4"></line><line x1="10" x2="3" y1="4" y2="4"></line><line x1="21" x2="12" y1="12" y2="12"></line><line x1="8" x2="3" y1="12" y2="12"></line><line x1="21" x2="16" y1="20" y2="20"></line><line x1="12" x2="3" y1="20" y2="20"></line><line x1="14" x2="14" y1="2" y2="6"></line><line x1="8" x2="8" y1="10" y2="14"></line><line x1="16" x2="16" y1="18" y2="22"></line></svg>`;
      attr(div, "aria-label", "Settings");
      attr(div, "class", "clickable-icon is-active svelte-eweyv0");
      toggle_class(
        div,
        "is-active",
        /*isActive*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      if (!mounted) {
        dispose = listen(
          div,
          "click",
          /*click_handler*/
          ctx[1]
        );
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*isActive*/
      1) {
        toggle_class(
          div,
          "is-active",
          /*isActive*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching)
        detach(div);
      mounted = false;
      dispose();
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { isActive = false } = $$props;
  function click_handler(event) {
    bubble.call(this, $$self, event);
  }
  $$self.$$set = ($$props2) => {
    if ("isActive" in $$props2)
      $$invalidate(0, isActive = $$props2.isActive);
  };
  return [isActive, click_handler];
}
var Settings_button = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance7, create_fragment7, safe_not_equal, { isActive: 0 }, add_css7);
  }
};
var settings_button_default = Settings_button;

// src/ui/components/controls.svelte
function add_css8(target) {
  append_styles(target, "svelte-n81brb", ".date.svelte-n81brb{display:flex;flex:1 0 0;justify-content:center;font-size:1.2em;color:var(--text-muted)}.settings.svelte-n81brb{margin:var(--size-4-1) var(--size-4-4)}.setting-item.svelte-n81brb{padding:var(--size-2-3) 0;border:none}.setting-item-name.svelte-n81brb{font-size:var(--font-ui-small)}.controls.svelte-n81brb{display:flex;flex-direction:column;border-bottom:1px solid var(--background-modifier-border)}.header.svelte-n81brb{display:flex;margin:var(--size-4-2)}");
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[7] = list[i];
  return child_ctx;
}
function create_if_block2(ctx) {
  let div9;
  let div3;
  let div1;
  let t1;
  let div2;
  let select;
  let t2;
  let div8;
  let div5;
  let t4;
  let div7;
  let div6;
  let mounted;
  let dispose;
  let each_value = ["1", "2", "3", "4"];
  let each_blocks = [];
  for (let i = 0; i < 4; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      div9 = element("div");
      div3 = element("div");
      div1 = element("div");
      div1.innerHTML = `<div class="setting-item-name svelte-n81brb">Zoom</div>`;
      t1 = space();
      div2 = element("div");
      select = element("select");
      for (let i = 0; i < 4; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      div8 = element("div");
      div5 = element("div");
      div5.innerHTML = `<div class="setting-item-name svelte-n81brb">Auto-scroll to now</div>`;
      t4 = space();
      div7 = element("div");
      div6 = element("div");
      div6.innerHTML = `<input type="checkbox" tabindex="0"/>`;
      attr(div1, "class", "setting-item-info");
      attr(select, "class", "dropdown");
      if (
        /*$settings*/
        ctx[2].zoomLevel === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[4].call(select)
        ));
      attr(div2, "class", "setting-item-control");
      attr(div3, "class", "setting-item svelte-n81brb");
      attr(div5, "class", "setting-item-info");
      attr(div6, "class", "checkbox-container mod-small");
      toggle_class(
        div6,
        "is-enabled",
        /*$settings*/
        ctx[2].centerNeedle
      );
      attr(div7, "class", "setting-item-control");
      attr(div8, "class", "setting-item mod-toggle svelte-n81brb");
      attr(div9, "class", "settings svelte-n81brb");
    },
    m(target, anchor) {
      insert(target, div9, anchor);
      append(div9, div3);
      append(div3, div1);
      append(div3, t1);
      append(div3, div2);
      append(div2, select);
      for (let i = 0; i < 4; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*$settings*/
        ctx[2].zoomLevel,
        true
      );
      append(div9, t2);
      append(div9, div8);
      append(div8, div5);
      append(div8, t4);
      append(div8, div7);
      append(div7, div6);
      if (!mounted) {
        dispose = [
          listen(
            select,
            "change",
            /*select_change_handler*/
            ctx[4]
          ),
          listen(
            div6,
            "click",
            /*click_handler*/
            ctx[5]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*$settings*/
      4) {
        select_option(
          select,
          /*$settings*/
          ctx2[2].zoomLevel
        );
      }
      if (dirty & /*$settings*/
      4) {
        toggle_class(
          div6,
          "is-enabled",
          /*$settings*/
          ctx2[2].centerNeedle
        );
      }
    },
    d(detaching) {
      if (detaching)
        detach(div9);
      destroy_each(each_blocks, detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block4(ctx) {
  let option;
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(
        /*level*/
        ctx[7]
      );
      option.__value = option_value_value = /*level*/
      ctx[7];
      option.value = option.__value;
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching)
        detach(option);
    }
  };
}
function create_fragment8(ctx) {
  let div1;
  let div0;
  let span;
  let t0;
  let t1;
  let settingsbutton;
  let t2;
  let current;
  settingsbutton = new settings_button_default({
    props: { isActive: (
      /*settingsVisible*/
      ctx[0]
    ) }
  });
  settingsbutton.$on(
    "click",
    /*toggleSettings*/
    ctx[3]
  );
  let if_block = (
    /*settingsVisible*/
    ctx[0] && create_if_block2(ctx)
  );
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      span = element("span");
      t0 = text(
        /*date*/
        ctx[1]
      );
      t1 = space();
      create_component(settingsbutton.$$.fragment);
      t2 = space();
      if (if_block)
        if_block.c();
      attr(span, "class", "date svelte-n81brb");
      attr(div0, "class", "header svelte-n81brb");
      attr(div1, "class", "controls svelte-n81brb");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append(div1, div0);
      append(div0, span);
      append(span, t0);
      append(div0, t1);
      mount_component(settingsbutton, div0, null);
      append(div1, t2);
      if (if_block)
        if_block.m(div1, null);
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*date*/
      2)
        set_data(
          t0,
          /*date*/
          ctx2[1]
        );
      const settingsbutton_changes = {};
      if (dirty & /*settingsVisible*/
      1)
        settingsbutton_changes.isActive = /*settingsVisible*/
        ctx2[0];
      settingsbutton.$set(settingsbutton_changes);
      if (
        /*settingsVisible*/
        ctx2[0]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block2(ctx2);
          if_block.c();
          if_block.m(div1, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(settingsbutton.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(settingsbutton.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching)
        detach(div1);
      destroy_component(settingsbutton);
      if (if_block)
        if_block.d();
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let $settings;
  component_subscribe($$self, settings, ($$value) => $$invalidate(2, $settings = $$value));
  let settingsVisible = false;
  function toggleSettings() {
    $$invalidate(0, settingsVisible = !settingsVisible);
  }
  function getFormattedDate() {
    return window.moment().format($settings.timelineDateFormat);
  }
  let date = getFormattedDate();
  onMount(() => {
    const interval = setInterval(
      () => {
        $$invalidate(1, date = getFormattedDate());
      },
      5e3
    );
    return () => clearInterval(interval);
  });
  function select_change_handler() {
    $settings.zoomLevel = select_value(this);
    settings.set($settings);
  }
  const click_handler = () => {
    set_store_value(settings, $settings.centerNeedle = !$settings.centerNeedle, $settings);
  };
  return [
    settingsVisible,
    date,
    $settings,
    toggleSettings,
    select_change_handler,
    click_handler
  ];
}
var Controls = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance8, create_fragment8, safe_not_equal, {}, add_css8);
  }
};
var controls_default = Controls;

// src/ui/components/timeline.svelte
function add_css9(target) {
  append_styles(target, "svelte-vjrxw4", ".scroller.svelte-vjrxw4{overflow:auto;height:100%}.scale-with-days.svelte-vjrxw4{display:flex}");
}
function create_default_slot(ctx) {
  let needle;
  let t;
  let taskcontainer;
  let current;
  needle = new needle_default({
    props: {
      scrollBlockedByUser: (
        /*userHoversOverScroller*/
        ctx[0]
      )
    }
  });
  taskcontainer = new task_container_default({});
  return {
    c() {
      create_component(needle.$$.fragment);
      t = space();
      create_component(taskcontainer.$$.fragment);
    },
    m(target, anchor) {
      mount_component(needle, target, anchor);
      insert(target, t, anchor);
      mount_component(taskcontainer, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const needle_changes = {};
      if (dirty & /*userHoversOverScroller*/
      1)
        needle_changes.scrollBlockedByUser = /*userHoversOverScroller*/
        ctx2[0];
      needle.$set(needle_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(needle.$$.fragment, local);
      transition_in(taskcontainer.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(needle.$$.fragment, local);
      transition_out(taskcontainer.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(needle, detaching);
      if (detaching)
        detach(t);
      destroy_component(taskcontainer, detaching);
    }
  };
}
function create_fragment9(ctx) {
  let controls;
  let t0;
  let div1;
  let div0;
  let ruler;
  let t1;
  let column;
  let current;
  let mounted;
  let dispose;
  controls = new controls_default({});
  ruler = new ruler_default({
    props: { visibleHours: (
      /*$visibleHours*/
      ctx[1]
    ) }
  });
  column = new column_default({
    props: {
      visibleHours: (
        /*$visibleHours*/
        ctx[1]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(controls.$$.fragment);
      t0 = space();
      div1 = element("div");
      div0 = element("div");
      create_component(ruler.$$.fragment);
      t1 = space();
      create_component(column.$$.fragment);
      attr(div0, "class", "scale-with-days svelte-vjrxw4");
      attr(div1, "class", "scroller svelte-vjrxw4");
    },
    m(target, anchor) {
      mount_component(controls, target, anchor);
      insert(target, t0, anchor);
      insert(target, div1, anchor);
      append(div1, div0);
      mount_component(ruler, div0, null);
      append(div0, t1);
      mount_component(column, div0, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            div1,
            "mouseenter",
            /*handleMouseEnter*/
            ctx[2]
          ),
          listen(
            div1,
            "mouseleave",
            /*handleMouseLeave*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      const ruler_changes = {};
      if (dirty & /*$visibleHours*/
      2)
        ruler_changes.visibleHours = /*$visibleHours*/
        ctx2[1];
      ruler.$set(ruler_changes);
      const column_changes = {};
      if (dirty & /*$visibleHours*/
      2)
        column_changes.visibleHours = /*$visibleHours*/
        ctx2[1];
      if (dirty & /*$$scope, userHoversOverScroller*/
      17) {
        column_changes.$$scope = { dirty, ctx: ctx2 };
      }
      column.$set(column_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(controls.$$.fragment, local);
      transition_in(ruler.$$.fragment, local);
      transition_in(column.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(controls.$$.fragment, local);
      transition_out(ruler.$$.fragment, local);
      transition_out(column.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(controls, detaching);
      if (detaching)
        detach(t0);
      if (detaching)
        detach(div1);
      destroy_component(ruler);
      destroy_component(column);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let $visibleHours;
  component_subscribe($$self, visibleHours, ($$value) => $$invalidate(1, $visibleHours = $$value));
  let userHoversOverScroller = false;
  function handleMouseEnter() {
    $$invalidate(0, userHoversOverScroller = true);
  }
  function handleMouseLeave() {
    $$invalidate(0, userHoversOverScroller = false);
  }
  return [userHoversOverScroller, $visibleHours, handleMouseEnter, handleMouseLeave];
}
var Timeline = class extends SvelteComponent {
  constructor(options) {
    super();
    init(this, options, instance9, create_fragment9, safe_not_equal, {}, add_css9);
  }
};
var timeline_default = Timeline;

// src/ui/timeline-view.ts
var TimelineView = class extends import_obsidian6.ItemView {
  constructor(leaf, settings2, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.settings = settings2;
  }
  getViewType() {
    return VIEW_TYPE_TIMELINE;
  }
  getDisplayText() {
    return "Day Planner Timeline";
  }
  getIcon() {
    return this.settings.timelineIcon;
  }
  async onOpen() {
    this.initStore();
    const contentEl = this.containerEl.children[1];
    this.timeline = new timeline_default({
      target: contentEl
    });
  }
  initStore() {
    appStore.set(this.app);
    const {
      zoomLevel,
      centerNeedle,
      startHour,
      timelineDateFormat,
      plannerHeading,
      plannerHeadingLevel
    } = this.settings;
    settings.set({
      zoomLevel,
      centerNeedle,
      startHour,
      timelineDateFormat,
      plannerHeading,
      plannerHeadingLevel
    });
    settings.subscribe(async (newValue) => {
      this.plugin.settings = { ...this.plugin.settings, ...newValue };
      await this.plugin.saveData(this.plugin.settings);
    });
  }
  async onClose() {
    var _a;
    (_a = this.timeline) == null ? void 0 : _a.$destroy();
  }
};

// src/main.ts
var DayPlanner = class extends import_obsidian7.Plugin {
  constructor() {
    super(...arguments);
    this.updateStatusBar = async () => {
      if (dailyNoteExists()) {
        await this.statusBar.update(get_store_value(tasks2));
      } else {
        this.statusBar.setEmpty();
      }
    };
  }
  async onload() {
    this.settings = Object.assign(
      new DayPlannerSettings(),
      await this.loadData()
    );
    this.statusBar = new StatusBar(
      this.settings,
      this.addStatusBarItem(),
      this.app.workspace
    );
    this.addCommand({
      id: "show-day-planner-timeline",
      name: "Show the Day Planner Timeline",
      callback: async () => await this.initLeaf()
    });
    this.addCommand({
      id: "show-day-planner-today-note",
      name: "Open today's Day Planner",
      callback: async () => this.app.workspace.getLeaf(false).openFile(await createDailyNoteIfNeeded())
    });
    this.addCommand({
      id: "insert-planner-heading-at-cursor",
      name: "Insert Planner Heading at Cursor",
      editorCallback: (editor) => editor.replaceSelection(createPlannerHeading())
    });
    this.registerView(
      VIEW_TYPE_TIMELINE,
      (leaf) => new TimelineView(leaf, this.settings, this)
    );
    this.addSettingTab(new DayPlannerSettingsTab(this.app, this));
    this.app.workspace.onLayoutReady(async () => {
      await this.refreshPlanItemsInStore();
    });
    this.app.metadataCache.on("changed", async (file) => {
      if (file === getDailyNoteForToday()) {
        await this.refreshPlanItemsInStore();
      }
    });
    this.registerInterval(
      window.setInterval(
        () => this.updateStatusBarOnFailed(this.updateStatusBar),
        1e3
      )
    );
  }
  onunload() {
    this.detachTimelineLeaves();
  }
  async updateStatusBarOnFailed(fn) {
    try {
      await fn();
    } catch (error) {
      this.statusBar.setText(`\u26A0\uFE0F Planner update failed (see console)`);
      console.error(error);
    }
  }
  async refreshPlanItemsInStore() {
    const parsedPlanItems = await this.getPlanItems();
    tasks2.update(() => parsedPlanItems);
  }
  async getPlanItems() {
    const dailyNote = (0, import_obsidian_daily_notes_interface2.getDailyNote)(window.moment(), (0, import_obsidian_daily_notes_interface2.getAllDailyNotes)());
    if (!dailyNote) {
      return [];
    }
    const fileContents = await this.app.vault.cachedRead(dailyNote);
    const metadata = this.app.metadataCache.getFileCache(dailyNote);
    return parsePlanItems(
      fileContents,
      metadata,
      this.settings.plannerHeading,
      dailyNote.path
    );
  }
  async initLeaf() {
    this.detachTimelineLeaves();
    await this.app.workspace.getRightLeaf(false).setViewState({
      type: VIEW_TYPE_TIMELINE,
      active: true
    });
  }
  detachTimelineLeaves() {
    this.app.workspace.getLeavesOfType(VIEW_TYPE_TIMELINE).forEach((leaf) => leaf.detach());
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL29ic2lkaWFuLWRhaWx5LW5vdGVzLWludGVyZmFjZS9kaXN0L21haW4uanMiLCAic3JjL21haW4udHMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9pbnRlcm5hbC9pbmRleC5tanMiLCAibm9kZV9tb2R1bGVzL3N2ZWx0ZS9zdG9yZS9pbmRleC5tanMiLCAic3JjL2NvbnN0YW50cy50cyIsICJzcmMvcmVnZXhwLnRzIiwgInNyYy91dGlsL21vbWVudC50cyIsICJzcmMvdGltZXN0YW1wL3RpbWVzdGFtcC50cyIsICJvYnNpZGlhbi1tZXRhZGF0YS11dGlscy9zcmMvcG9zaXRpb24udHMiLCAib2JzaWRpYW4tbWV0YWRhdGEtdXRpbHMvc3JjL2xpc3QudHMiLCAic3JjL3N0b3JlL3NldHRpbmdzLnRzIiwgInNyYy9zdG9yZS90aW1lbGluZS1zdG9yZS50cyIsICJzcmMvdXRpbC9kYWlseS1ub3Rlcy50cyIsICJzcmMvcGFyc2VyL3BhcnNlci50cyIsICJzcmMvc2V0dGluZ3MudHMiLCAic3JjL3VpL3NldHRpbmdzLXRhYi50cyIsICJzcmMvdWkvc3RhdHVzLWJhci50cyIsICJzcmMvdWkvdGltZWxpbmUtdmlldy50cyIsICJzcmMvdWkvY29tcG9uZW50cy9ydWxlci5zdmVsdGUiLCAic3JjL3VpL2NvbXBvbmVudHMvY29sdW1uLnN2ZWx0ZSIsICJzcmMvdWkvY29tcG9uZW50cy9uZWVkbGUuc3ZlbHRlIiwgInNyYy91aS9jb21wb25lbnRzL3JlbmRlcmVkLW1hcmtkb3duLnN2ZWx0ZSIsICJub2RlX21vZHVsZXMvc3ZlbHRlL3RyYW5zaXRpb24vaW5kZXgubWpzIiwgInNyYy9zdG9yZS91cGRhdGUtdGltZXN0YW1wLnRzIiwgInNyYy91aS9ob29rcy91c2UtZHJhZy50cyIsICJzcmMvdWkvaG9va3MvdXNlLXJlc2l6ZS50cyIsICJzcmMvdWkvY29tcG9uZW50cy90YXNrLnN2ZWx0ZSIsICJzcmMvdXRpbC9vYnNpZGlhbi50cyIsICJzcmMvdXRpbC9lZGl0b3IudHMiLCAic3JjL3BsYW4udHMiLCAic3JjL3VpL2hvb2tzL3VzZS1jcmVhdGUudHMiLCAic3JjL3VpL2NvbXBvbmVudHMvdGFzay1jb250YWluZXIuc3ZlbHRlIiwgInNyYy91aS9jb21wb25lbnRzL3NldHRpbmdzLWJ1dHRvbi5zdmVsdGUiLCAic3JjL3VpL2NvbXBvbmVudHMvY29udHJvbHMuc3ZlbHRlIiwgInNyYy91aS9jb21wb25lbnRzL3RpbWVsaW5lLnN2ZWx0ZSJdLAogICJzb3VyY2VzQ29udGVudCI6IFsiJ3VzZSBzdHJpY3QnO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuXG52YXIgb2JzaWRpYW4gPSByZXF1aXJlKCdvYnNpZGlhbicpO1xuXG5jb25zdCBERUZBVUxUX0RBSUxZX05PVEVfRk9STUFUID0gXCJZWVlZLU1NLUREXCI7XG5jb25zdCBERUZBVUxUX1dFRUtMWV9OT1RFX0ZPUk1BVCA9IFwiZ2dnZy1bV113d1wiO1xuY29uc3QgREVGQVVMVF9NT05USExZX05PVEVfRk9STUFUID0gXCJZWVlZLU1NXCI7XG5jb25zdCBERUZBVUxUX1FVQVJURVJMWV9OT1RFX0ZPUk1BVCA9IFwiWVlZWS1bUV1RXCI7XG5jb25zdCBERUZBVUxUX1lFQVJMWV9OT1RFX0ZPUk1BVCA9IFwiWVlZWVwiO1xuXG5mdW5jdGlvbiBzaG91bGRVc2VQZXJpb2RpY05vdGVzU2V0dGluZ3MocGVyaW9kaWNpdHkpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHBlcmlvZGljTm90ZXMgPSB3aW5kb3cuYXBwLnBsdWdpbnMuZ2V0UGx1Z2luKFwicGVyaW9kaWMtbm90ZXNcIik7XG4gICAgcmV0dXJuIHBlcmlvZGljTm90ZXMgJiYgcGVyaW9kaWNOb3Rlcy5zZXR0aW5ncz8uW3BlcmlvZGljaXR5XT8uZW5hYmxlZDtcbn1cbi8qKlxuICogUmVhZCB0aGUgdXNlciBzZXR0aW5ncyBmb3IgdGhlIGBkYWlseS1ub3Rlc2AgcGx1Z2luXG4gKiB0byBrZWVwIGJlaGF2aW9yIG9mIGNyZWF0aW5nIGEgbmV3IG5vdGUgaW4tc3luYy5cbiAqL1xuZnVuY3Rpb24gZ2V0RGFpbHlOb3RlU2V0dGluZ3MoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgeyBpbnRlcm5hbFBsdWdpbnMsIHBsdWdpbnMgfSA9IHdpbmRvdy5hcHA7XG4gICAgICAgIGlmIChzaG91bGRVc2VQZXJpb2RpY05vdGVzU2V0dGluZ3MoXCJkYWlseVwiKSkge1xuICAgICAgICAgICAgY29uc3QgeyBmb3JtYXQsIGZvbGRlciwgdGVtcGxhdGUgfSA9IHBsdWdpbnMuZ2V0UGx1Z2luKFwicGVyaW9kaWMtbm90ZXNcIik/LnNldHRpbmdzPy5kYWlseSB8fCB7fTtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQgfHwgREVGQVVMVF9EQUlMWV9OT1RFX0ZPUk1BVCxcbiAgICAgICAgICAgICAgICBmb2xkZXI6IGZvbGRlcj8udHJpbSgpIHx8IFwiXCIsXG4gICAgICAgICAgICAgICAgdGVtcGxhdGU6IHRlbXBsYXRlPy50cmltKCkgfHwgXCJcIixcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyBmb2xkZXIsIGZvcm1hdCwgdGVtcGxhdGUgfSA9IGludGVybmFsUGx1Z2lucy5nZXRQbHVnaW5CeUlkKFwiZGFpbHktbm90ZXNcIik/Lmluc3RhbmNlPy5vcHRpb25zIHx8IHt9O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZm9ybWF0OiBmb3JtYXQgfHwgREVGQVVMVF9EQUlMWV9OT1RFX0ZPUk1BVCxcbiAgICAgICAgICAgIGZvbGRlcjogZm9sZGVyPy50cmltKCkgfHwgXCJcIixcbiAgICAgICAgICAgIHRlbXBsYXRlOiB0ZW1wbGF0ZT8udHJpbSgpIHx8IFwiXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTm8gY3VzdG9tIGRhaWx5IG5vdGUgc2V0dGluZ3MgZm91bmQhXCIsIGVycik7XG4gICAgfVxufVxuLyoqXG4gKiBSZWFkIHRoZSB1c2VyIHNldHRpbmdzIGZvciB0aGUgYHdlZWtseS1ub3Rlc2AgcGx1Z2luXG4gKiB0byBrZWVwIGJlaGF2aW9yIG9mIGNyZWF0aW5nIGEgbmV3IG5vdGUgaW4tc3luYy5cbiAqL1xuZnVuY3Rpb24gZ2V0V2Vla2x5Tm90ZVNldHRpbmdzKCkge1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIGNvbnN0IHBsdWdpbk1hbmFnZXIgPSB3aW5kb3cuYXBwLnBsdWdpbnM7XG4gICAgICAgIGNvbnN0IGNhbGVuZGFyU2V0dGluZ3MgPSBwbHVnaW5NYW5hZ2VyLmdldFBsdWdpbihcImNhbGVuZGFyXCIpPy5vcHRpb25zO1xuICAgICAgICBjb25zdCBwZXJpb2RpY05vdGVzU2V0dGluZ3MgPSBwbHVnaW5NYW5hZ2VyLmdldFBsdWdpbihcInBlcmlvZGljLW5vdGVzXCIpPy5zZXR0aW5ncz8ud2Vla2x5O1xuICAgICAgICBpZiAoc2hvdWxkVXNlUGVyaW9kaWNOb3Rlc1NldHRpbmdzKFwid2Vla2x5XCIpKSB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGZvcm1hdDogcGVyaW9kaWNOb3Rlc1NldHRpbmdzLmZvcm1hdCB8fCBERUZBVUxUX1dFRUtMWV9OT1RFX0ZPUk1BVCxcbiAgICAgICAgICAgICAgICBmb2xkZXI6IHBlcmlvZGljTm90ZXNTZXR0aW5ncy5mb2xkZXI/LnRyaW0oKSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHRlbXBsYXRlOiBwZXJpb2RpY05vdGVzU2V0dGluZ3MudGVtcGxhdGU/LnRyaW0oKSB8fCBcIlwiLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IGNhbGVuZGFyU2V0dGluZ3MgfHwge307XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IHNldHRpbmdzLndlZWtseU5vdGVGb3JtYXQgfHwgREVGQVVMVF9XRUVLTFlfTk9URV9GT1JNQVQsXG4gICAgICAgICAgICBmb2xkZXI6IHNldHRpbmdzLndlZWtseU5vdGVGb2xkZXI/LnRyaW0oKSB8fCBcIlwiLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHNldHRpbmdzLndlZWtseU5vdGVUZW1wbGF0ZT8udHJpbSgpIHx8IFwiXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTm8gY3VzdG9tIHdlZWtseSBub3RlIHNldHRpbmdzIGZvdW5kIVwiLCBlcnIpO1xuICAgIH1cbn1cbi8qKlxuICogUmVhZCB0aGUgdXNlciBzZXR0aW5ncyBmb3IgdGhlIGBwZXJpb2RpYy1ub3Rlc2AgcGx1Z2luXG4gKiB0byBrZWVwIGJlaGF2aW9yIG9mIGNyZWF0aW5nIGEgbmV3IG5vdGUgaW4tc3luYy5cbiAqL1xuZnVuY3Rpb24gZ2V0TW9udGhseU5vdGVTZXR0aW5ncygpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHBsdWdpbk1hbmFnZXIgPSB3aW5kb3cuYXBwLnBsdWdpbnM7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAoc2hvdWxkVXNlUGVyaW9kaWNOb3Rlc1NldHRpbmdzKFwibW9udGhseVwiKSAmJlxuICAgICAgICAgICAgcGx1Z2luTWFuYWdlci5nZXRQbHVnaW4oXCJwZXJpb2RpYy1ub3Rlc1wiKT8uc2V0dGluZ3M/Lm1vbnRobHkpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogc2V0dGluZ3MuZm9ybWF0IHx8IERFRkFVTFRfTU9OVEhMWV9OT1RFX0ZPUk1BVCxcbiAgICAgICAgICAgIGZvbGRlcjogc2V0dGluZ3MuZm9sZGVyPy50cmltKCkgfHwgXCJcIixcbiAgICAgICAgICAgIHRlbXBsYXRlOiBzZXR0aW5ncy50ZW1wbGF0ZT8udHJpbSgpIHx8IFwiXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTm8gY3VzdG9tIG1vbnRobHkgbm90ZSBzZXR0aW5ncyBmb3VuZCFcIiwgZXJyKTtcbiAgICB9XG59XG4vKipcbiAqIFJlYWQgdGhlIHVzZXIgc2V0dGluZ3MgZm9yIHRoZSBgcGVyaW9kaWMtbm90ZXNgIHBsdWdpblxuICogdG8ga2VlcCBiZWhhdmlvciBvZiBjcmVhdGluZyBhIG5ldyBub3RlIGluLXN5bmMuXG4gKi9cbmZ1bmN0aW9uIGdldFF1YXJ0ZXJseU5vdGVTZXR0aW5ncygpIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHBsdWdpbk1hbmFnZXIgPSB3aW5kb3cuYXBwLnBsdWdpbnM7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3Qgc2V0dGluZ3MgPSAoc2hvdWxkVXNlUGVyaW9kaWNOb3Rlc1NldHRpbmdzKFwicXVhcnRlcmx5XCIpICYmXG4gICAgICAgICAgICBwbHVnaW5NYW5hZ2VyLmdldFBsdWdpbihcInBlcmlvZGljLW5vdGVzXCIpPy5zZXR0aW5ncz8ucXVhcnRlcmx5KSB8fFxuICAgICAgICAgICAge307XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBmb3JtYXQ6IHNldHRpbmdzLmZvcm1hdCB8fCBERUZBVUxUX1FVQVJURVJMWV9OT1RFX0ZPUk1BVCxcbiAgICAgICAgICAgIGZvbGRlcjogc2V0dGluZ3MuZm9sZGVyPy50cmltKCkgfHwgXCJcIixcbiAgICAgICAgICAgIHRlbXBsYXRlOiBzZXR0aW5ncy50ZW1wbGF0ZT8udHJpbSgpIHx8IFwiXCIsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5pbmZvKFwiTm8gY3VzdG9tIHF1YXJ0ZXJseSBub3RlIHNldHRpbmdzIGZvdW5kIVwiLCBlcnIpO1xuICAgIH1cbn1cbi8qKlxuICogUmVhZCB0aGUgdXNlciBzZXR0aW5ncyBmb3IgdGhlIGBwZXJpb2RpYy1ub3Rlc2AgcGx1Z2luXG4gKiB0byBrZWVwIGJlaGF2aW9yIG9mIGNyZWF0aW5nIGEgbmV3IG5vdGUgaW4tc3luYy5cbiAqL1xuZnVuY3Rpb24gZ2V0WWVhcmx5Tm90ZVNldHRpbmdzKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgcGx1Z2luTWFuYWdlciA9IHdpbmRvdy5hcHAucGx1Z2lucztcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBzZXR0aW5ncyA9IChzaG91bGRVc2VQZXJpb2RpY05vdGVzU2V0dGluZ3MoXCJ5ZWFybHlcIikgJiZcbiAgICAgICAgICAgIHBsdWdpbk1hbmFnZXIuZ2V0UGx1Z2luKFwicGVyaW9kaWMtbm90ZXNcIik/LnNldHRpbmdzPy55ZWFybHkpIHx8XG4gICAgICAgICAgICB7fTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZvcm1hdDogc2V0dGluZ3MuZm9ybWF0IHx8IERFRkFVTFRfWUVBUkxZX05PVEVfRk9STUFULFxuICAgICAgICAgICAgZm9sZGVyOiBzZXR0aW5ncy5mb2xkZXI/LnRyaW0oKSB8fCBcIlwiLFxuICAgICAgICAgICAgdGVtcGxhdGU6IHNldHRpbmdzLnRlbXBsYXRlPy50cmltKCkgfHwgXCJcIixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmluZm8oXCJObyBjdXN0b20geWVhcmx5IG5vdGUgc2V0dGluZ3MgZm91bmQhXCIsIGVycik7XG4gICAgfVxufVxuXG4vLyBDcmVkaXQ6IEBjcmVhdGlvbml4L3BhdGguanNcbmZ1bmN0aW9uIGpvaW4oLi4ucGFydFNlZ21lbnRzKSB7XG4gICAgLy8gU3BsaXQgdGhlIGlucHV0cyBpbnRvIGEgbGlzdCBvZiBwYXRoIGNvbW1hbmRzLlxuICAgIGxldCBwYXJ0cyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBsID0gcGFydFNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBwYXJ0cyA9IHBhcnRzLmNvbmNhdChwYXJ0U2VnbWVudHNbaV0uc3BsaXQoXCIvXCIpKTtcbiAgICB9XG4gICAgLy8gSW50ZXJwcmV0IHRoZSBwYXRoIGNvbW1hbmRzIHRvIGdldCB0aGUgbmV3IHJlc29sdmVkIHBhdGguXG4gICAgY29uc3QgbmV3UGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICBjb25zdCBwYXJ0ID0gcGFydHNbaV07XG4gICAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzXG4gICAgICAgIC8vIEFsc28gcmVtb3ZlIFwiLlwiIHNlZ21lbnRzXG4gICAgICAgIGlmICghcGFydCB8fCBwYXJ0ID09PSBcIi5cIilcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAvLyBQdXNoIG5ldyBwYXRoIHNlZ21lbnRzLlxuICAgICAgICBlbHNlXG4gICAgICAgICAgICBuZXdQYXJ0cy5wdXNoKHBhcnQpO1xuICAgIH1cbiAgICAvLyBQcmVzZXJ2ZSB0aGUgaW5pdGlhbCBzbGFzaCBpZiB0aGVyZSB3YXMgb25lLlxuICAgIGlmIChwYXJ0c1swXSA9PT0gXCJcIilcbiAgICAgICAgbmV3UGFydHMudW5zaGlmdChcIlwiKTtcbiAgICAvLyBUdXJuIGJhY2sgaW50byBhIHNpbmdsZSBzdHJpbmcgcGF0aC5cbiAgICByZXR1cm4gbmV3UGFydHMuam9pbihcIi9cIik7XG59XG5mdW5jdGlvbiBiYXNlbmFtZShmdWxsUGF0aCkge1xuICAgIGxldCBiYXNlID0gZnVsbFBhdGguc3Vic3RyaW5nKGZ1bGxQYXRoLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xuICAgIGlmIChiYXNlLmxhc3RJbmRleE9mKFwiLlwiKSAhPSAtMSlcbiAgICAgICAgYmFzZSA9IGJhc2Uuc3Vic3RyaW5nKDAsIGJhc2UubGFzdEluZGV4T2YoXCIuXCIpKTtcbiAgICByZXR1cm4gYmFzZTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGVuc3VyZUZvbGRlckV4aXN0cyhwYXRoKSB7XG4gICAgY29uc3QgZGlycyA9IHBhdGgucmVwbGFjZSgvXFxcXC9nLCBcIi9cIikuc3BsaXQoXCIvXCIpO1xuICAgIGRpcnMucG9wKCk7IC8vIHJlbW92ZSBiYXNlbmFtZVxuICAgIGlmIChkaXJzLmxlbmd0aCkge1xuICAgICAgICBjb25zdCBkaXIgPSBqb2luKC4uLmRpcnMpO1xuICAgICAgICBpZiAoIXdpbmRvdy5hcHAudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKGRpcikpIHtcbiAgICAgICAgICAgIGF3YWl0IHdpbmRvdy5hcHAudmF1bHQuY3JlYXRlRm9sZGVyKGRpcik7XG4gICAgICAgIH1cbiAgICB9XG59XG5hc3luYyBmdW5jdGlvbiBnZXROb3RlUGF0aChkaXJlY3RvcnksIGZpbGVuYW1lKSB7XG4gICAgaWYgKCFmaWxlbmFtZS5lbmRzV2l0aChcIi5tZFwiKSkge1xuICAgICAgICBmaWxlbmFtZSArPSBcIi5tZFwiO1xuICAgIH1cbiAgICBjb25zdCBwYXRoID0gb2JzaWRpYW4ubm9ybWFsaXplUGF0aChqb2luKGRpcmVjdG9yeSwgZmlsZW5hbWUpKTtcbiAgICBhd2FpdCBlbnN1cmVGb2xkZXJFeGlzdHMocGF0aCk7XG4gICAgcmV0dXJuIHBhdGg7XG59XG5hc3luYyBmdW5jdGlvbiBnZXRUZW1wbGF0ZUluZm8odGVtcGxhdGUpIHtcbiAgICBjb25zdCB7IG1ldGFkYXRhQ2FjaGUsIHZhdWx0IH0gPSB3aW5kb3cuYXBwO1xuICAgIGNvbnN0IHRlbXBsYXRlUGF0aCA9IG9ic2lkaWFuLm5vcm1hbGl6ZVBhdGgodGVtcGxhdGUpO1xuICAgIGlmICh0ZW1wbGF0ZVBhdGggPT09IFwiL1wiKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoW1wiXCIsIG51bGxdKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgdGVtcGxhdGVGaWxlID0gbWV0YWRhdGFDYWNoZS5nZXRGaXJzdExpbmtwYXRoRGVzdCh0ZW1wbGF0ZVBhdGgsIFwiXCIpO1xuICAgICAgICBjb25zdCBjb250ZW50cyA9IGF3YWl0IHZhdWx0LmNhY2hlZFJlYWQodGVtcGxhdGVGaWxlKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgY29uc3QgSUZvbGRJbmZvID0gd2luZG93LmFwcC5mb2xkTWFuYWdlci5sb2FkKHRlbXBsYXRlRmlsZSk7XG4gICAgICAgIHJldHVybiBbY29udGVudHMsIElGb2xkSW5mb107XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIHJlYWQgdGhlIGRhaWx5IG5vdGUgdGVtcGxhdGUgJyR7dGVtcGxhdGVQYXRofSdgLCBlcnIpO1xuICAgICAgICBuZXcgb2JzaWRpYW4uTm90aWNlKFwiRmFpbGVkIHRvIHJlYWQgdGhlIGRhaWx5IG5vdGUgdGVtcGxhdGVcIik7XG4gICAgICAgIHJldHVybiBbXCJcIiwgbnVsbF07XG4gICAgfVxufVxuXG4vKipcbiAqIGRhdGVVSUQgaXMgYSB3YXkgb2Ygd2Vla2x5IGlkZW50aWZ5aW5nIGRhaWx5L3dlZWtseS9tb250aGx5IG5vdGVzLlxuICogVGhleSBhcmUgcHJlZml4ZWQgd2l0aCB0aGUgZ3JhbnVsYXJpdHkgdG8gYXZvaWQgYW1iaWd1aXR5LlxuICovXG5mdW5jdGlvbiBnZXREYXRlVUlEKGRhdGUsIGdyYW51bGFyaXR5ID0gXCJkYXlcIikge1xuICAgIGNvbnN0IHRzID0gZGF0ZS5jbG9uZSgpLnN0YXJ0T2YoZ3JhbnVsYXJpdHkpLmZvcm1hdCgpO1xuICAgIHJldHVybiBgJHtncmFudWxhcml0eX0tJHt0c31gO1xufVxuZnVuY3Rpb24gcmVtb3ZlRXNjYXBlZENoYXJhY3RlcnMoZm9ybWF0KSB7XG4gICAgcmV0dXJuIGZvcm1hdC5yZXBsYWNlKC9cXFtbXlxcXV0qXFxdL2csIFwiXCIpOyAvLyByZW1vdmUgZXZlcnl0aGluZyB3aXRoaW4gYnJhY2tldHNcbn1cbi8qKlxuICogWFhYOiBXaGVuIHBhcnNpbmcgZGF0ZXMgdGhhdCBjb250YWluIGJvdGggd2VlayBudW1iZXJzIGFuZCBtb250aHMsXG4gKiBNb21lbnQgY2hvc2VzIHRvIGlnbm9yZSB0aGUgd2VlayBudW1iZXJzLiBGb3IgdGhlIHdlZWsgZGF0ZVVJRCwgd2VcbiAqIHdhbnQgdGhlIG9wcG9zaXRlIGJlaGF2aW9yLiBTdHJpcCB0aGUgTU1NIGZyb20gdGhlIGZvcm1hdCB0byBwYXRjaC5cbiAqL1xuZnVuY3Rpb24gaXNGb3JtYXRBbWJpZ3VvdXMoZm9ybWF0LCBncmFudWxhcml0eSkge1xuICAgIGlmIChncmFudWxhcml0eSA9PT0gXCJ3ZWVrXCIpIHtcbiAgICAgICAgY29uc3QgY2xlYW5Gb3JtYXQgPSByZW1vdmVFc2NhcGVkQ2hhcmFjdGVycyhmb3JtYXQpO1xuICAgICAgICByZXR1cm4gKC93ezEsMn0vaS50ZXN0KGNsZWFuRm9ybWF0KSAmJlxuICAgICAgICAgICAgKC9NezEsNH0vLnRlc3QoY2xlYW5Gb3JtYXQpIHx8IC9EezEsNH0vLnRlc3QoY2xlYW5Gb3JtYXQpKSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGdldERhdGVGcm9tRmlsZShmaWxlLCBncmFudWxhcml0eSkge1xuICAgIHJldHVybiBnZXREYXRlRnJvbUZpbGVuYW1lKGZpbGUuYmFzZW5hbWUsIGdyYW51bGFyaXR5KTtcbn1cbmZ1bmN0aW9uIGdldERhdGVGcm9tUGF0aChwYXRoLCBncmFudWxhcml0eSkge1xuICAgIHJldHVybiBnZXREYXRlRnJvbUZpbGVuYW1lKGJhc2VuYW1lKHBhdGgpLCBncmFudWxhcml0eSk7XG59XG5mdW5jdGlvbiBnZXREYXRlRnJvbUZpbGVuYW1lKGZpbGVuYW1lLCBncmFudWxhcml0eSkge1xuICAgIGNvbnN0IGdldFNldHRpbmdzID0ge1xuICAgICAgICBkYXk6IGdldERhaWx5Tm90ZVNldHRpbmdzLFxuICAgICAgICB3ZWVrOiBnZXRXZWVrbHlOb3RlU2V0dGluZ3MsXG4gICAgICAgIG1vbnRoOiBnZXRNb250aGx5Tm90ZVNldHRpbmdzLFxuICAgICAgICBxdWFydGVyOiBnZXRRdWFydGVybHlOb3RlU2V0dGluZ3MsXG4gICAgICAgIHllYXI6IGdldFllYXJseU5vdGVTZXR0aW5ncyxcbiAgICB9O1xuICAgIGNvbnN0IGZvcm1hdCA9IGdldFNldHRpbmdzW2dyYW51bGFyaXR5XSgpLmZvcm1hdC5zcGxpdChcIi9cIikucG9wKCk7XG4gICAgY29uc3Qgbm90ZURhdGUgPSB3aW5kb3cubW9tZW50KGZpbGVuYW1lLCBmb3JtYXQsIHRydWUpO1xuICAgIGlmICghbm90ZURhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoaXNGb3JtYXRBbWJpZ3VvdXMoZm9ybWF0LCBncmFudWxhcml0eSkpIHtcbiAgICAgICAgaWYgKGdyYW51bGFyaXR5ID09PSBcIndlZWtcIikge1xuICAgICAgICAgICAgY29uc3QgY2xlYW5Gb3JtYXQgPSByZW1vdmVFc2NhcGVkQ2hhcmFjdGVycyhmb3JtYXQpO1xuICAgICAgICAgICAgaWYgKC93ezEsMn0vaS50ZXN0KGNsZWFuRm9ybWF0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB3aW5kb3cubW9tZW50KGZpbGVuYW1lLCBcbiAgICAgICAgICAgICAgICAvLyBJZiBmb3JtYXQgY29udGFpbnMgd2VlaywgcmVtb3ZlIGRheSAmIG1vbnRoIGZvcm1hdHRpbmdcbiAgICAgICAgICAgICAgICBmb3JtYXQucmVwbGFjZSgvTXsxLDR9L2csIFwiXCIpLnJlcGxhY2UoL0R7MSw0fS9nLCBcIlwiKSwgZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub3RlRGF0ZTtcbn1cblxuY2xhc3MgRGFpbHlOb3Rlc0ZvbGRlck1pc3NpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbi8qKlxuICogVGhpcyBmdW5jdGlvbiBtaW1pY3MgdGhlIGJlaGF2aW9yIG9mIHRoZSBkYWlseS1ub3RlcyBwbHVnaW5cbiAqIHNvIGl0IHdpbGwgcmVwbGFjZSB7e2RhdGV9fSwge3t0aXRsZX19LCBhbmQge3t0aW1lfX0gd2l0aCB0aGVcbiAqIGZvcm1hdHRlZCB0aW1lc3RhbXAuXG4gKlxuICogTm90ZTogaXQgaGFzIGFuIGFkZGVkIGJvbnVzIHRoYXQgaXQncyBub3QgJ3RvZGF5JyBzcGVjaWZpYy5cbiAqL1xuYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGFpbHlOb3RlKGRhdGUpIHtcbiAgICBjb25zdCBhcHAgPSB3aW5kb3cuYXBwO1xuICAgIGNvbnN0IHsgdmF1bHQgfSA9IGFwcDtcbiAgICBjb25zdCBtb21lbnQgPSB3aW5kb3cubW9tZW50O1xuICAgIGNvbnN0IHsgdGVtcGxhdGUsIGZvcm1hdCwgZm9sZGVyIH0gPSBnZXREYWlseU5vdGVTZXR0aW5ncygpO1xuICAgIGNvbnN0IFt0ZW1wbGF0ZUNvbnRlbnRzLCBJRm9sZEluZm9dID0gYXdhaXQgZ2V0VGVtcGxhdGVJbmZvKHRlbXBsYXRlKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGRhdGUuZm9ybWF0KGZvcm1hdCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBhd2FpdCBnZXROb3RlUGF0aChmb2xkZXIsIGZpbGVuYW1lKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjcmVhdGVkRmlsZSA9IGF3YWl0IHZhdWx0LmNyZWF0ZShub3JtYWxpemVkUGF0aCwgdGVtcGxhdGVDb250ZW50c1xuICAgICAgICAgICAgLnJlcGxhY2UoL3t7XFxzKmRhdGVcXHMqfX0vZ2ksIGZpbGVuYW1lKVxuICAgICAgICAgICAgLnJlcGxhY2UoL3t7XFxzKnRpbWVcXHMqfX0vZ2ksIG1vbWVudCgpLmZvcm1hdChcIkhIOm1tXCIpKVxuICAgICAgICAgICAgLnJlcGxhY2UoL3t7XFxzKnRpdGxlXFxzKn19L2dpLCBmaWxlbmFtZSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC97e1xccyooZGF0ZXx0aW1lKVxccyooKFsrLV1cXGQrKShbeXFtd2Roc10pKT9cXHMqKDouKz8pP319L2dpLCAoXywgX3RpbWVPckRhdGUsIGNhbGMsIHRpbWVEZWx0YSwgdW5pdCwgbW9tZW50Rm9ybWF0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBtb21lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gZGF0ZS5jbG9uZSgpLnNldCh7XG4gICAgICAgICAgICAgICAgaG91cjogbm93LmdldChcImhvdXJcIiksXG4gICAgICAgICAgICAgICAgbWludXRlOiBub3cuZ2V0KFwibWludXRlXCIpLFxuICAgICAgICAgICAgICAgIHNlY29uZDogbm93LmdldChcInNlY29uZFwiKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNhbGMpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5hZGQocGFyc2VJbnQodGltZURlbHRhLCAxMCksIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vbWVudEZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZS5mb3JtYXQobW9tZW50Rm9ybWF0LnN1YnN0cmluZygxKS50cmltKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL3t7XFxzKnllc3RlcmRheVxccyp9fS9naSwgZGF0ZS5jbG9uZSgpLnN1YnRyYWN0KDEsIFwiZGF5XCIpLmZvcm1hdChmb3JtYXQpKVxuICAgICAgICAgICAgLnJlcGxhY2UoL3t7XFxzKnRvbW9ycm93XFxzKn19L2dpLCBkYXRlLmNsb25lKCkuYWRkKDEsIFwiZFwiKS5mb3JtYXQoZm9ybWF0KSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICBhcHAuZm9sZE1hbmFnZXIuc2F2ZShjcmVhdGVkRmlsZSwgSUZvbGRJbmZvKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZWRGaWxlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgZmlsZTogJyR7bm9ybWFsaXplZFBhdGh9J2AsIGVycik7XG4gICAgICAgIG5ldyBvYnNpZGlhbi5Ob3RpY2UoXCJVbmFibGUgdG8gY3JlYXRlIG5ldyBmaWxlLlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXREYWlseU5vdGUoZGF0ZSwgZGFpbHlOb3Rlcykge1xuICAgIHJldHVybiBkYWlseU5vdGVzW2dldERhdGVVSUQoZGF0ZSwgXCJkYXlcIildID8/IG51bGw7XG59XG5mdW5jdGlvbiBnZXRBbGxEYWlseU5vdGVzKCkge1xuICAgIC8qKlxuICAgICAqIEZpbmQgYWxsIGRhaWx5IG5vdGVzIGluIHRoZSBkYWlseSBub3RlIGZvbGRlclxuICAgICAqL1xuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHdpbmRvdy5hcHA7XG4gICAgY29uc3QgeyBmb2xkZXIgfSA9IGdldERhaWx5Tm90ZVNldHRpbmdzKCk7XG4gICAgY29uc3QgZGFpbHlOb3Rlc0ZvbGRlciA9IHZhdWx0LmdldEFic3RyYWN0RmlsZUJ5UGF0aChvYnNpZGlhbi5ub3JtYWxpemVQYXRoKGZvbGRlcikpO1xuICAgIGlmICghZGFpbHlOb3Rlc0ZvbGRlcikge1xuICAgICAgICB0aHJvdyBuZXcgRGFpbHlOb3Rlc0ZvbGRlck1pc3NpbmdFcnJvcihcIkZhaWxlZCB0byBmaW5kIGRhaWx5IG5vdGVzIGZvbGRlclwiKTtcbiAgICB9XG4gICAgY29uc3QgZGFpbHlOb3RlcyA9IHt9O1xuICAgIG9ic2lkaWFuLlZhdWx0LnJlY3Vyc2VDaGlsZHJlbihkYWlseU5vdGVzRm9sZGVyLCAobm90ZSkgPT4ge1xuICAgICAgICBpZiAobm90ZSBpbnN0YW5jZW9mIG9ic2lkaWFuLlRGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZ2V0RGF0ZUZyb21GaWxlKG5vdGUsIFwiZGF5XCIpO1xuICAgICAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlU3RyaW5nID0gZ2V0RGF0ZVVJRChkYXRlLCBcImRheVwiKTtcbiAgICAgICAgICAgICAgICBkYWlseU5vdGVzW2RhdGVTdHJpbmddID0gbm90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBkYWlseU5vdGVzO1xufVxuXG5jbGFzcyBXZWVrbHlOb3Rlc0ZvbGRlck1pc3NpbmdFcnJvciBleHRlbmRzIEVycm9yIHtcbn1cbmZ1bmN0aW9uIGdldERheXNPZldlZWsoKSB7XG4gICAgY29uc3QgeyBtb21lbnQgfSA9IHdpbmRvdztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGxldCB3ZWVrU3RhcnQgPSBtb21lbnQubG9jYWxlRGF0YSgpLl93ZWVrLmRvdztcbiAgICBjb25zdCBkYXlzT2ZXZWVrID0gW1xuICAgICAgICBcInN1bmRheVwiLFxuICAgICAgICBcIm1vbmRheVwiLFxuICAgICAgICBcInR1ZXNkYXlcIixcbiAgICAgICAgXCJ3ZWRuZXNkYXlcIixcbiAgICAgICAgXCJ0aHVyc2RheVwiLFxuICAgICAgICBcImZyaWRheVwiLFxuICAgICAgICBcInNhdHVyZGF5XCIsXG4gICAgXTtcbiAgICB3aGlsZSAod2Vla1N0YXJ0KSB7XG4gICAgICAgIGRheXNPZldlZWsucHVzaChkYXlzT2ZXZWVrLnNoaWZ0KCkpO1xuICAgICAgICB3ZWVrU3RhcnQtLTtcbiAgICB9XG4gICAgcmV0dXJuIGRheXNPZldlZWs7XG59XG5mdW5jdGlvbiBnZXREYXlPZldlZWtOdW1lcmljYWxWYWx1ZShkYXlPZldlZWtOYW1lKSB7XG4gICAgcmV0dXJuIGdldERheXNPZldlZWsoKS5pbmRleE9mKGRheU9mV2Vla05hbWUudG9Mb3dlckNhc2UoKSk7XG59XG5hc3luYyBmdW5jdGlvbiBjcmVhdGVXZWVrbHlOb3RlKGRhdGUpIHtcbiAgICBjb25zdCB7IHZhdWx0IH0gPSB3aW5kb3cuYXBwO1xuICAgIGNvbnN0IHsgdGVtcGxhdGUsIGZvcm1hdCwgZm9sZGVyIH0gPSBnZXRXZWVrbHlOb3RlU2V0dGluZ3MoKTtcbiAgICBjb25zdCBbdGVtcGxhdGVDb250ZW50cywgSUZvbGRJbmZvXSA9IGF3YWl0IGdldFRlbXBsYXRlSW5mbyh0ZW1wbGF0ZSk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBkYXRlLmZvcm1hdChmb3JtYXQpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gYXdhaXQgZ2V0Tm90ZVBhdGgoZm9sZGVyLCBmaWxlbmFtZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3JlYXRlZEZpbGUgPSBhd2FpdCB2YXVsdC5jcmVhdGUobm9ybWFsaXplZFBhdGgsIHRlbXBsYXRlQ29udGVudHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC97e1xccyooZGF0ZXx0aW1lKVxccyooKFsrLV1cXGQrKShbeXFtd2Roc10pKT9cXHMqKDouKz8pP319L2dpLCAoXywgX3RpbWVPckRhdGUsIGNhbGMsIHRpbWVEZWx0YSwgdW5pdCwgbW9tZW50Rm9ybWF0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSB3aW5kb3cubW9tZW50KCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IGRhdGUuY2xvbmUoKS5zZXQoe1xuICAgICAgICAgICAgICAgIGhvdXI6IG5vdy5nZXQoXCJob3VyXCIpLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogbm93LmdldChcIm1pbnV0ZVwiKSxcbiAgICAgICAgICAgICAgICBzZWNvbmQ6IG5vdy5nZXQoXCJzZWNvbmRcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjYWxjKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUuYWRkKHBhcnNlSW50KHRpbWVEZWx0YSwgMTApLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb21lbnRGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGUuZm9ybWF0KG1vbWVudEZvcm1hdC5zdWJzdHJpbmcoMSkudHJpbSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZS5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC97e1xccyp0aXRsZVxccyp9fS9naSwgZmlsZW5hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgve3tcXHMqdGltZVxccyp9fS9naSwgd2luZG93Lm1vbWVudCgpLmZvcm1hdChcIkhIOm1tXCIpKVxuICAgICAgICAgICAgLnJlcGxhY2UoL3t7XFxzKihzdW5kYXl8bW9uZGF5fHR1ZXNkYXl8d2VkbmVzZGF5fHRodXJzZGF5fGZyaWRheXxzYXR1cmRheSlcXHMqOiguKj8pfX0vZ2ksIChfLCBkYXlPZldlZWssIG1vbWVudEZvcm1hdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZGF5ID0gZ2V0RGF5T2ZXZWVrTnVtZXJpY2FsVmFsdWUoZGF5T2ZXZWVrKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRlLndlZWtkYXkoZGF5KS5mb3JtYXQobW9tZW50Rm9ybWF0LnRyaW0oKSk7XG4gICAgICAgIH0pKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgd2luZG93LmFwcC5mb2xkTWFuYWdlci5zYXZlKGNyZWF0ZWRGaWxlLCBJRm9sZEluZm8pO1xuICAgICAgICByZXR1cm4gY3JlYXRlZEZpbGU7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBmaWxlOiAnJHtub3JtYWxpemVkUGF0aH0nYCwgZXJyKTtcbiAgICAgICAgbmV3IG9ic2lkaWFuLk5vdGljZShcIlVuYWJsZSB0byBjcmVhdGUgbmV3IGZpbGUuXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFdlZWtseU5vdGUoZGF0ZSwgd2Vla2x5Tm90ZXMpIHtcbiAgICByZXR1cm4gd2Vla2x5Tm90ZXNbZ2V0RGF0ZVVJRChkYXRlLCBcIndlZWtcIildID8/IG51bGw7XG59XG5mdW5jdGlvbiBnZXRBbGxXZWVrbHlOb3RlcygpIHtcbiAgICBjb25zdCB3ZWVrbHlOb3RlcyA9IHt9O1xuICAgIGlmICghYXBwSGFzV2Vla2x5Tm90ZXNQbHVnaW5Mb2FkZWQoKSkge1xuICAgICAgICByZXR1cm4gd2Vla2x5Tm90ZXM7XG4gICAgfVxuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHdpbmRvdy5hcHA7XG4gICAgY29uc3QgeyBmb2xkZXIgfSA9IGdldFdlZWtseU5vdGVTZXR0aW5ncygpO1xuICAgIGNvbnN0IHdlZWtseU5vdGVzRm9sZGVyID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG9ic2lkaWFuLm5vcm1hbGl6ZVBhdGgoZm9sZGVyKSk7XG4gICAgaWYgKCF3ZWVrbHlOb3Rlc0ZvbGRlcikge1xuICAgICAgICB0aHJvdyBuZXcgV2Vla2x5Tm90ZXNGb2xkZXJNaXNzaW5nRXJyb3IoXCJGYWlsZWQgdG8gZmluZCB3ZWVrbHkgbm90ZXMgZm9sZGVyXCIpO1xuICAgIH1cbiAgICBvYnNpZGlhbi5WYXVsdC5yZWN1cnNlQ2hpbGRyZW4od2Vla2x5Tm90ZXNGb2xkZXIsIChub3RlKSA9PiB7XG4gICAgICAgIGlmIChub3RlIGluc3RhbmNlb2Ygb2JzaWRpYW4uVEZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBnZXREYXRlRnJvbUZpbGUobm90ZSwgXCJ3ZWVrXCIpO1xuICAgICAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlU3RyaW5nID0gZ2V0RGF0ZVVJRChkYXRlLCBcIndlZWtcIik7XG4gICAgICAgICAgICAgICAgd2Vla2x5Tm90ZXNbZGF0ZVN0cmluZ10gPSBub3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHdlZWtseU5vdGVzO1xufVxuXG5jbGFzcyBNb250aGx5Tm90ZXNGb2xkZXJNaXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbWltaWNzIHRoZSBiZWhhdmlvciBvZiB0aGUgZGFpbHktbm90ZXMgcGx1Z2luXG4gKiBzbyBpdCB3aWxsIHJlcGxhY2Uge3tkYXRlfX0sIHt7dGl0bGV9fSwgYW5kIHt7dGltZX19IHdpdGggdGhlXG4gKiBmb3JtYXR0ZWQgdGltZXN0YW1wLlxuICpcbiAqIE5vdGU6IGl0IGhhcyBhbiBhZGRlZCBib251cyB0aGF0IGl0J3Mgbm90ICd0b2RheScgc3BlY2lmaWMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZU1vbnRobHlOb3RlKGRhdGUpIHtcbiAgICBjb25zdCB7IHZhdWx0IH0gPSB3aW5kb3cuYXBwO1xuICAgIGNvbnN0IHsgdGVtcGxhdGUsIGZvcm1hdCwgZm9sZGVyIH0gPSBnZXRNb250aGx5Tm90ZVNldHRpbmdzKCk7XG4gICAgY29uc3QgW3RlbXBsYXRlQ29udGVudHMsIElGb2xkSW5mb10gPSBhd2FpdCBnZXRUZW1wbGF0ZUluZm8odGVtcGxhdGUpO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gZGF0ZS5mb3JtYXQoZm9ybWF0KTtcbiAgICBjb25zdCBub3JtYWxpemVkUGF0aCA9IGF3YWl0IGdldE5vdGVQYXRoKGZvbGRlciwgZmlsZW5hbWUpO1xuICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGNyZWF0ZWRGaWxlID0gYXdhaXQgdmF1bHQuY3JlYXRlKG5vcm1hbGl6ZWRQYXRoLCB0ZW1wbGF0ZUNvbnRlbnRzXG4gICAgICAgICAgICAucmVwbGFjZSgve3tcXHMqKGRhdGV8dGltZSlcXHMqKChbKy1dXFxkKykoW3lxbXdkaHNdKSk/XFxzKig6Lis/KT99fS9naSwgKF8sIF90aW1lT3JEYXRlLCBjYWxjLCB0aW1lRGVsdGEsIHVuaXQsIG1vbWVudEZvcm1hdCkgPT4ge1xuICAgICAgICAgICAgY29uc3Qgbm93ID0gd2luZG93Lm1vbWVudCgpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudERhdGUgPSBkYXRlLmNsb25lKCkuc2V0KHtcbiAgICAgICAgICAgICAgICBob3VyOiBub3cuZ2V0KFwiaG91clwiKSxcbiAgICAgICAgICAgICAgICBtaW51dGU6IG5vdy5nZXQoXCJtaW51dGVcIiksXG4gICAgICAgICAgICAgICAgc2Vjb25kOiBub3cuZ2V0KFwic2Vjb25kXCIpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoY2FsYykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnREYXRlLmFkZChwYXJzZUludCh0aW1lRGVsdGEsIDEwKSwgdW5pdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobW9tZW50Rm9ybWF0KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlLmZvcm1hdChtb21lbnRGb3JtYXQuc3Vic3RyaW5nKDEpLnRyaW0oKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGUuZm9ybWF0KGZvcm1hdCk7XG4gICAgICAgIH0pXG4gICAgICAgICAgICAucmVwbGFjZSgve3tcXHMqZGF0ZVxccyp9fS9naSwgZmlsZW5hbWUpXG4gICAgICAgICAgICAucmVwbGFjZSgve3tcXHMqdGltZVxccyp9fS9naSwgd2luZG93Lm1vbWVudCgpLmZvcm1hdChcIkhIOm1tXCIpKVxuICAgICAgICAgICAgLnJlcGxhY2UoL3t7XFxzKnRpdGxlXFxzKn19L2dpLCBmaWxlbmFtZSkpO1xuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgICAgICB3aW5kb3cuYXBwLmZvbGRNYW5hZ2VyLnNhdmUoY3JlYXRlZEZpbGUsIElGb2xkSW5mbyk7XG4gICAgICAgIHJldHVybiBjcmVhdGVkRmlsZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGBGYWlsZWQgdG8gY3JlYXRlIGZpbGU6ICcke25vcm1hbGl6ZWRQYXRofSdgLCBlcnIpO1xuICAgICAgICBuZXcgb2JzaWRpYW4uTm90aWNlKFwiVW5hYmxlIHRvIGNyZWF0ZSBuZXcgZmlsZS5cIik7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0TW9udGhseU5vdGUoZGF0ZSwgbW9udGhseU5vdGVzKSB7XG4gICAgcmV0dXJuIG1vbnRobHlOb3Rlc1tnZXREYXRlVUlEKGRhdGUsIFwibW9udGhcIildID8/IG51bGw7XG59XG5mdW5jdGlvbiBnZXRBbGxNb250aGx5Tm90ZXMoKSB7XG4gICAgY29uc3QgbW9udGhseU5vdGVzID0ge307XG4gICAgaWYgKCFhcHBIYXNNb250aGx5Tm90ZXNQbHVnaW5Mb2FkZWQoKSkge1xuICAgICAgICByZXR1cm4gbW9udGhseU5vdGVzO1xuICAgIH1cbiAgICBjb25zdCB7IHZhdWx0IH0gPSB3aW5kb3cuYXBwO1xuICAgIGNvbnN0IHsgZm9sZGVyIH0gPSBnZXRNb250aGx5Tm90ZVNldHRpbmdzKCk7XG4gICAgY29uc3QgbW9udGhseU5vdGVzRm9sZGVyID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG9ic2lkaWFuLm5vcm1hbGl6ZVBhdGgoZm9sZGVyKSk7XG4gICAgaWYgKCFtb250aGx5Tm90ZXNGb2xkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IE1vbnRobHlOb3Rlc0ZvbGRlck1pc3NpbmdFcnJvcihcIkZhaWxlZCB0byBmaW5kIG1vbnRobHkgbm90ZXMgZm9sZGVyXCIpO1xuICAgIH1cbiAgICBvYnNpZGlhbi5WYXVsdC5yZWN1cnNlQ2hpbGRyZW4obW9udGhseU5vdGVzRm9sZGVyLCAobm90ZSkgPT4ge1xuICAgICAgICBpZiAobm90ZSBpbnN0YW5jZW9mIG9ic2lkaWFuLlRGaWxlKSB7XG4gICAgICAgICAgICBjb25zdCBkYXRlID0gZ2V0RGF0ZUZyb21GaWxlKG5vdGUsIFwibW9udGhcIik7XG4gICAgICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVTdHJpbmcgPSBnZXREYXRlVUlEKGRhdGUsIFwibW9udGhcIik7XG4gICAgICAgICAgICAgICAgbW9udGhseU5vdGVzW2RhdGVTdHJpbmddID0gbm90ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBtb250aGx5Tm90ZXM7XG59XG5cbmNsYXNzIFF1YXJ0ZXJseU5vdGVzRm9sZGVyTWlzc2luZ0Vycm9yIGV4dGVuZHMgRXJyb3Ige1xufVxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIG1pbWljcyB0aGUgYmVoYXZpb3Igb2YgdGhlIGRhaWx5LW5vdGVzIHBsdWdpblxuICogc28gaXQgd2lsbCByZXBsYWNlIHt7ZGF0ZX19LCB7e3RpdGxlfX0sIGFuZCB7e3RpbWV9fSB3aXRoIHRoZVxuICogZm9ybWF0dGVkIHRpbWVzdGFtcC5cbiAqXG4gKiBOb3RlOiBpdCBoYXMgYW4gYWRkZWQgYm9udXMgdGhhdCBpdCdzIG5vdCAndG9kYXknIHNwZWNpZmljLlxuICovXG5hc3luYyBmdW5jdGlvbiBjcmVhdGVRdWFydGVybHlOb3RlKGRhdGUpIHtcbiAgICBjb25zdCB7IHZhdWx0IH0gPSB3aW5kb3cuYXBwO1xuICAgIGNvbnN0IHsgdGVtcGxhdGUsIGZvcm1hdCwgZm9sZGVyIH0gPSBnZXRRdWFydGVybHlOb3RlU2V0dGluZ3MoKTtcbiAgICBjb25zdCBbdGVtcGxhdGVDb250ZW50cywgSUZvbGRJbmZvXSA9IGF3YWl0IGdldFRlbXBsYXRlSW5mbyh0ZW1wbGF0ZSk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBkYXRlLmZvcm1hdChmb3JtYXQpO1xuICAgIGNvbnN0IG5vcm1hbGl6ZWRQYXRoID0gYXdhaXQgZ2V0Tm90ZVBhdGgoZm9sZGVyLCBmaWxlbmFtZSk7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY3JlYXRlZEZpbGUgPSBhd2FpdCB2YXVsdC5jcmVhdGUobm9ybWFsaXplZFBhdGgsIHRlbXBsYXRlQ29udGVudHNcbiAgICAgICAgICAgIC5yZXBsYWNlKC97e1xccyooZGF0ZXx0aW1lKVxccyooKFsrLV1cXGQrKShbeXFtd2Roc10pKT9cXHMqKDouKz8pP319L2dpLCAoXywgX3RpbWVPckRhdGUsIGNhbGMsIHRpbWVEZWx0YSwgdW5pdCwgbW9tZW50Rm9ybWF0KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBub3cgPSB3aW5kb3cubW9tZW50KCk7XG4gICAgICAgICAgICBjb25zdCBjdXJyZW50RGF0ZSA9IGRhdGUuY2xvbmUoKS5zZXQoe1xuICAgICAgICAgICAgICAgIGhvdXI6IG5vdy5nZXQoXCJob3VyXCIpLFxuICAgICAgICAgICAgICAgIG1pbnV0ZTogbm93LmdldChcIm1pbnV0ZVwiKSxcbiAgICAgICAgICAgICAgICBzZWNvbmQ6IG5vdy5nZXQoXCJzZWNvbmRcIiksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGlmIChjYWxjKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudERhdGUuYWRkKHBhcnNlSW50KHRpbWVEZWx0YSwgMTApLCB1bml0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb21lbnRGb3JtYXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY3VycmVudERhdGUuZm9ybWF0KG1vbWVudEZvcm1hdC5zdWJzdHJpbmcoMSkudHJpbSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZS5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgfSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC97e1xccypkYXRlXFxzKn19L2dpLCBmaWxlbmFtZSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC97e1xccyp0aW1lXFxzKn19L2dpLCB3aW5kb3cubW9tZW50KCkuZm9ybWF0KFwiSEg6bW1cIikpXG4gICAgICAgICAgICAucmVwbGFjZSgve3tcXHMqdGl0bGVcXHMqfX0vZ2ksIGZpbGVuYW1lKSk7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgICAgIHdpbmRvdy5hcHAuZm9sZE1hbmFnZXIuc2F2ZShjcmVhdGVkRmlsZSwgSUZvbGRJbmZvKTtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZWRGaWxlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEZhaWxlZCB0byBjcmVhdGUgZmlsZTogJyR7bm9ybWFsaXplZFBhdGh9J2AsIGVycik7XG4gICAgICAgIG5ldyBvYnNpZGlhbi5Ob3RpY2UoXCJVbmFibGUgdG8gY3JlYXRlIG5ldyBmaWxlLlwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBnZXRRdWFydGVybHlOb3RlKGRhdGUsIHF1YXJ0ZXJseSkge1xuICAgIHJldHVybiBxdWFydGVybHlbZ2V0RGF0ZVVJRChkYXRlLCBcInF1YXJ0ZXJcIildID8/IG51bGw7XG59XG5mdW5jdGlvbiBnZXRBbGxRdWFydGVybHlOb3RlcygpIHtcbiAgICBjb25zdCBxdWFydGVybHkgPSB7fTtcbiAgICBpZiAoIWFwcEhhc1F1YXJ0ZXJseU5vdGVzUGx1Z2luTG9hZGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIHF1YXJ0ZXJseTtcbiAgICB9XG4gICAgY29uc3QgeyB2YXVsdCB9ID0gd2luZG93LmFwcDtcbiAgICBjb25zdCB7IGZvbGRlciB9ID0gZ2V0UXVhcnRlcmx5Tm90ZVNldHRpbmdzKCk7XG4gICAgY29uc3QgcXVhcnRlcmx5Rm9sZGVyID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG9ic2lkaWFuLm5vcm1hbGl6ZVBhdGgoZm9sZGVyKSk7XG4gICAgaWYgKCFxdWFydGVybHlGb2xkZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFF1YXJ0ZXJseU5vdGVzRm9sZGVyTWlzc2luZ0Vycm9yKFwiRmFpbGVkIHRvIGZpbmQgcXVhcnRlcmx5IG5vdGVzIGZvbGRlclwiKTtcbiAgICB9XG4gICAgb2JzaWRpYW4uVmF1bHQucmVjdXJzZUNoaWxkcmVuKHF1YXJ0ZXJseUZvbGRlciwgKG5vdGUpID0+IHtcbiAgICAgICAgaWYgKG5vdGUgaW5zdGFuY2VvZiBvYnNpZGlhbi5URmlsZSkge1xuICAgICAgICAgICAgY29uc3QgZGF0ZSA9IGdldERhdGVGcm9tRmlsZShub3RlLCBcInF1YXJ0ZXJcIik7XG4gICAgICAgICAgICBpZiAoZGF0ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRhdGVTdHJpbmcgPSBnZXREYXRlVUlEKGRhdGUsIFwicXVhcnRlclwiKTtcbiAgICAgICAgICAgICAgICBxdWFydGVybHlbZGF0ZVN0cmluZ10gPSBub3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHF1YXJ0ZXJseTtcbn1cblxuY2xhc3MgWWVhcmx5Tm90ZXNGb2xkZXJNaXNzaW5nRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG59XG4vKipcbiAqIFRoaXMgZnVuY3Rpb24gbWltaWNzIHRoZSBiZWhhdmlvciBvZiB0aGUgZGFpbHktbm90ZXMgcGx1Z2luXG4gKiBzbyBpdCB3aWxsIHJlcGxhY2Uge3tkYXRlfX0sIHt7dGl0bGV9fSwgYW5kIHt7dGltZX19IHdpdGggdGhlXG4gKiBmb3JtYXR0ZWQgdGltZXN0YW1wLlxuICpcbiAqIE5vdGU6IGl0IGhhcyBhbiBhZGRlZCBib251cyB0aGF0IGl0J3Mgbm90ICd0b2RheScgc3BlY2lmaWMuXG4gKi9cbmFzeW5jIGZ1bmN0aW9uIGNyZWF0ZVllYXJseU5vdGUoZGF0ZSkge1xuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHdpbmRvdy5hcHA7XG4gICAgY29uc3QgeyB0ZW1wbGF0ZSwgZm9ybWF0LCBmb2xkZXIgfSA9IGdldFllYXJseU5vdGVTZXR0aW5ncygpO1xuICAgIGNvbnN0IFt0ZW1wbGF0ZUNvbnRlbnRzLCBJRm9sZEluZm9dID0gYXdhaXQgZ2V0VGVtcGxhdGVJbmZvKHRlbXBsYXRlKTtcbiAgICBjb25zdCBmaWxlbmFtZSA9IGRhdGUuZm9ybWF0KGZvcm1hdCk7XG4gICAgY29uc3Qgbm9ybWFsaXplZFBhdGggPSBhd2FpdCBnZXROb3RlUGF0aChmb2xkZXIsIGZpbGVuYW1lKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBjcmVhdGVkRmlsZSA9IGF3YWl0IHZhdWx0LmNyZWF0ZShub3JtYWxpemVkUGF0aCwgdGVtcGxhdGVDb250ZW50c1xuICAgICAgICAgICAgLnJlcGxhY2UoL3t7XFxzKihkYXRlfHRpbWUpXFxzKigoWystXVxcZCspKFt5cW13ZGhzXSkpP1xccyooOi4rPyk/fX0vZ2ksIChfLCBfdGltZU9yRGF0ZSwgY2FsYywgdGltZURlbHRhLCB1bml0LCBtb21lbnRGb3JtYXQpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IHdpbmRvdy5tb21lbnQoKTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnREYXRlID0gZGF0ZS5jbG9uZSgpLnNldCh7XG4gICAgICAgICAgICAgICAgaG91cjogbm93LmdldChcImhvdXJcIiksXG4gICAgICAgICAgICAgICAgbWludXRlOiBub3cuZ2V0KFwibWludXRlXCIpLFxuICAgICAgICAgICAgICAgIHNlY29uZDogbm93LmdldChcInNlY29uZFwiKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKGNhbGMpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGF0ZS5hZGQocGFyc2VJbnQodGltZURlbHRhLCAxMCksIHVuaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1vbWVudEZvcm1hdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjdXJyZW50RGF0ZS5mb3JtYXQobW9tZW50Rm9ybWF0LnN1YnN0cmluZygxKS50cmltKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnREYXRlLmZvcm1hdChmb3JtYXQpO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLnJlcGxhY2UoL3t7XFxzKmRhdGVcXHMqfX0vZ2ksIGZpbGVuYW1lKVxuICAgICAgICAgICAgLnJlcGxhY2UoL3t7XFxzKnRpbWVcXHMqfX0vZ2ksIHdpbmRvdy5tb21lbnQoKS5mb3JtYXQoXCJISDptbVwiKSlcbiAgICAgICAgICAgIC5yZXBsYWNlKC97e1xccyp0aXRsZVxccyp9fS9naSwgZmlsZW5hbWUpKTtcbiAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICAgICAgd2luZG93LmFwcC5mb2xkTWFuYWdlci5zYXZlKGNyZWF0ZWRGaWxlLCBJRm9sZEluZm8pO1xuICAgICAgICByZXR1cm4gY3JlYXRlZEZpbGU7XG4gICAgfVxuICAgIGNhdGNoIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcihgRmFpbGVkIHRvIGNyZWF0ZSBmaWxlOiAnJHtub3JtYWxpemVkUGF0aH0nYCwgZXJyKTtcbiAgICAgICAgbmV3IG9ic2lkaWFuLk5vdGljZShcIlVuYWJsZSB0byBjcmVhdGUgbmV3IGZpbGUuXCIpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFllYXJseU5vdGUoZGF0ZSwgeWVhcmx5Tm90ZXMpIHtcbiAgICByZXR1cm4geWVhcmx5Tm90ZXNbZ2V0RGF0ZVVJRChkYXRlLCBcInllYXJcIildID8/IG51bGw7XG59XG5mdW5jdGlvbiBnZXRBbGxZZWFybHlOb3RlcygpIHtcbiAgICBjb25zdCB5ZWFybHlOb3RlcyA9IHt9O1xuICAgIGlmICghYXBwSGFzWWVhcmx5Tm90ZXNQbHVnaW5Mb2FkZWQoKSkge1xuICAgICAgICByZXR1cm4geWVhcmx5Tm90ZXM7XG4gICAgfVxuICAgIGNvbnN0IHsgdmF1bHQgfSA9IHdpbmRvdy5hcHA7XG4gICAgY29uc3QgeyBmb2xkZXIgfSA9IGdldFllYXJseU5vdGVTZXR0aW5ncygpO1xuICAgIGNvbnN0IHllYXJseU5vdGVzRm9sZGVyID0gdmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKG9ic2lkaWFuLm5vcm1hbGl6ZVBhdGgoZm9sZGVyKSk7XG4gICAgaWYgKCF5ZWFybHlOb3Rlc0ZvbGRlcikge1xuICAgICAgICB0aHJvdyBuZXcgWWVhcmx5Tm90ZXNGb2xkZXJNaXNzaW5nRXJyb3IoXCJGYWlsZWQgdG8gZmluZCB5ZWFybHkgbm90ZXMgZm9sZGVyXCIpO1xuICAgIH1cbiAgICBvYnNpZGlhbi5WYXVsdC5yZWN1cnNlQ2hpbGRyZW4oeWVhcmx5Tm90ZXNGb2xkZXIsIChub3RlKSA9PiB7XG4gICAgICAgIGlmIChub3RlIGluc3RhbmNlb2Ygb2JzaWRpYW4uVEZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGUgPSBnZXREYXRlRnJvbUZpbGUobm90ZSwgXCJ5ZWFyXCIpO1xuICAgICAgICAgICAgaWYgKGRhdGUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBkYXRlU3RyaW5nID0gZ2V0RGF0ZVVJRChkYXRlLCBcInllYXJcIik7XG4gICAgICAgICAgICAgICAgeWVhcmx5Tm90ZXNbZGF0ZVN0cmluZ10gPSBub3RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHllYXJseU5vdGVzO1xufVxuXG5mdW5jdGlvbiBhcHBIYXNEYWlseU5vdGVzUGx1Z2luTG9hZGVkKCkge1xuICAgIGNvbnN0IHsgYXBwIH0gPSB3aW5kb3c7XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby1leHBsaWNpdC1hbnlcbiAgICBjb25zdCBkYWlseU5vdGVzUGx1Z2luID0gYXBwLmludGVybmFsUGx1Z2lucy5wbHVnaW5zW1wiZGFpbHktbm90ZXNcIl07XG4gICAgaWYgKGRhaWx5Tm90ZXNQbHVnaW4gJiYgZGFpbHlOb3Rlc1BsdWdpbi5lbmFibGVkKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHBlcmlvZGljTm90ZXMgPSBhcHAucGx1Z2lucy5nZXRQbHVnaW4oXCJwZXJpb2RpYy1ub3Rlc1wiKTtcbiAgICByZXR1cm4gcGVyaW9kaWNOb3RlcyAmJiBwZXJpb2RpY05vdGVzLnNldHRpbmdzPy5kYWlseT8uZW5hYmxlZDtcbn1cbi8qKlxuICogWFhYOiBcIldlZWtseSBOb3Rlc1wiIGxpdmUgaW4gZWl0aGVyIHRoZSBDYWxlbmRhciBwbHVnaW4gb3IgdGhlIHBlcmlvZGljLW5vdGVzIHBsdWdpbi5cbiAqIENoZWNrIGJvdGggdW50aWwgdGhlIHdlZWtseSBub3RlcyBmZWF0dXJlIGlzIHJlbW92ZWQgZnJvbSB0aGUgQ2FsZW5kYXIgcGx1Z2luLlxuICovXG5mdW5jdGlvbiBhcHBIYXNXZWVrbHlOb3Rlc1BsdWdpbkxvYWRlZCgpIHtcbiAgICBjb25zdCB7IGFwcCB9ID0gd2luZG93O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgaWYgKGFwcC5wbHVnaW5zLmdldFBsdWdpbihcImNhbGVuZGFyXCIpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHBlcmlvZGljTm90ZXMgPSBhcHAucGx1Z2lucy5nZXRQbHVnaW4oXCJwZXJpb2RpYy1ub3Rlc1wiKTtcbiAgICByZXR1cm4gcGVyaW9kaWNOb3RlcyAmJiBwZXJpb2RpY05vdGVzLnNldHRpbmdzPy53ZWVrbHk/LmVuYWJsZWQ7XG59XG5mdW5jdGlvbiBhcHBIYXNNb250aGx5Tm90ZXNQbHVnaW5Mb2FkZWQoKSB7XG4gICAgY29uc3QgeyBhcHAgfSA9IHdpbmRvdztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHBlcmlvZGljTm90ZXMgPSBhcHAucGx1Z2lucy5nZXRQbHVnaW4oXCJwZXJpb2RpYy1ub3Rlc1wiKTtcbiAgICByZXR1cm4gcGVyaW9kaWNOb3RlcyAmJiBwZXJpb2RpY05vdGVzLnNldHRpbmdzPy5tb250aGx5Py5lbmFibGVkO1xufVxuZnVuY3Rpb24gYXBwSGFzUXVhcnRlcmx5Tm90ZXNQbHVnaW5Mb2FkZWQoKSB7XG4gICAgY29uc3QgeyBhcHAgfSA9IHdpbmRvdztcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxuICAgIGNvbnN0IHBlcmlvZGljTm90ZXMgPSBhcHAucGx1Z2lucy5nZXRQbHVnaW4oXCJwZXJpb2RpYy1ub3Rlc1wiKTtcbiAgICByZXR1cm4gcGVyaW9kaWNOb3RlcyAmJiBwZXJpb2RpY05vdGVzLnNldHRpbmdzPy5xdWFydGVybHk/LmVuYWJsZWQ7XG59XG5mdW5jdGlvbiBhcHBIYXNZZWFybHlOb3Rlc1BsdWdpbkxvYWRlZCgpIHtcbiAgICBjb25zdCB7IGFwcCB9ID0gd2luZG93O1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55XG4gICAgY29uc3QgcGVyaW9kaWNOb3RlcyA9IGFwcC5wbHVnaW5zLmdldFBsdWdpbihcInBlcmlvZGljLW5vdGVzXCIpO1xuICAgIHJldHVybiBwZXJpb2RpY05vdGVzICYmIHBlcmlvZGljTm90ZXMuc2V0dGluZ3M/LnllYXJseT8uZW5hYmxlZDtcbn1cbmZ1bmN0aW9uIGdldFBlcmlvZGljTm90ZVNldHRpbmdzKGdyYW51bGFyaXR5KSB7XG4gICAgY29uc3QgZ2V0U2V0dGluZ3MgPSB7XG4gICAgICAgIGRheTogZ2V0RGFpbHlOb3RlU2V0dGluZ3MsXG4gICAgICAgIHdlZWs6IGdldFdlZWtseU5vdGVTZXR0aW5ncyxcbiAgICAgICAgbW9udGg6IGdldE1vbnRobHlOb3RlU2V0dGluZ3MsXG4gICAgICAgIHF1YXJ0ZXI6IGdldFF1YXJ0ZXJseU5vdGVTZXR0aW5ncyxcbiAgICAgICAgeWVhcjogZ2V0WWVhcmx5Tm90ZVNldHRpbmdzLFxuICAgIH1bZ3JhbnVsYXJpdHldO1xuICAgIHJldHVybiBnZXRTZXR0aW5ncygpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGVyaW9kaWNOb3RlKGdyYW51bGFyaXR5LCBkYXRlKSB7XG4gICAgY29uc3QgY3JlYXRlRm4gPSB7XG4gICAgICAgIGRheTogY3JlYXRlRGFpbHlOb3RlLFxuICAgICAgICBtb250aDogY3JlYXRlTW9udGhseU5vdGUsXG4gICAgICAgIHdlZWs6IGNyZWF0ZVdlZWtseU5vdGUsXG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlRm5bZ3JhbnVsYXJpdHldKGRhdGUpO1xufVxuXG5leHBvcnRzLkRFRkFVTFRfREFJTFlfTk9URV9GT1JNQVQgPSBERUZBVUxUX0RBSUxZX05PVEVfRk9STUFUO1xuZXhwb3J0cy5ERUZBVUxUX01PTlRITFlfTk9URV9GT1JNQVQgPSBERUZBVUxUX01PTlRITFlfTk9URV9GT1JNQVQ7XG5leHBvcnRzLkRFRkFVTFRfUVVBUlRFUkxZX05PVEVfRk9STUFUID0gREVGQVVMVF9RVUFSVEVSTFlfTk9URV9GT1JNQVQ7XG5leHBvcnRzLkRFRkFVTFRfV0VFS0xZX05PVEVfRk9STUFUID0gREVGQVVMVF9XRUVLTFlfTk9URV9GT1JNQVQ7XG5leHBvcnRzLkRFRkFVTFRfWUVBUkxZX05PVEVfRk9STUFUID0gREVGQVVMVF9ZRUFSTFlfTk9URV9GT1JNQVQ7XG5leHBvcnRzLmFwcEhhc0RhaWx5Tm90ZXNQbHVnaW5Mb2FkZWQgPSBhcHBIYXNEYWlseU5vdGVzUGx1Z2luTG9hZGVkO1xuZXhwb3J0cy5hcHBIYXNNb250aGx5Tm90ZXNQbHVnaW5Mb2FkZWQgPSBhcHBIYXNNb250aGx5Tm90ZXNQbHVnaW5Mb2FkZWQ7XG5leHBvcnRzLmFwcEhhc1F1YXJ0ZXJseU5vdGVzUGx1Z2luTG9hZGVkID0gYXBwSGFzUXVhcnRlcmx5Tm90ZXNQbHVnaW5Mb2FkZWQ7XG5leHBvcnRzLmFwcEhhc1dlZWtseU5vdGVzUGx1Z2luTG9hZGVkID0gYXBwSGFzV2Vla2x5Tm90ZXNQbHVnaW5Mb2FkZWQ7XG5leHBvcnRzLmFwcEhhc1llYXJseU5vdGVzUGx1Z2luTG9hZGVkID0gYXBwSGFzWWVhcmx5Tm90ZXNQbHVnaW5Mb2FkZWQ7XG5leHBvcnRzLmNyZWF0ZURhaWx5Tm90ZSA9IGNyZWF0ZURhaWx5Tm90ZTtcbmV4cG9ydHMuY3JlYXRlTW9udGhseU5vdGUgPSBjcmVhdGVNb250aGx5Tm90ZTtcbmV4cG9ydHMuY3JlYXRlUGVyaW9kaWNOb3RlID0gY3JlYXRlUGVyaW9kaWNOb3RlO1xuZXhwb3J0cy5jcmVhdGVRdWFydGVybHlOb3RlID0gY3JlYXRlUXVhcnRlcmx5Tm90ZTtcbmV4cG9ydHMuY3JlYXRlV2Vla2x5Tm90ZSA9IGNyZWF0ZVdlZWtseU5vdGU7XG5leHBvcnRzLmNyZWF0ZVllYXJseU5vdGUgPSBjcmVhdGVZZWFybHlOb3RlO1xuZXhwb3J0cy5nZXRBbGxEYWlseU5vdGVzID0gZ2V0QWxsRGFpbHlOb3RlcztcbmV4cG9ydHMuZ2V0QWxsTW9udGhseU5vdGVzID0gZ2V0QWxsTW9udGhseU5vdGVzO1xuZXhwb3J0cy5nZXRBbGxRdWFydGVybHlOb3RlcyA9IGdldEFsbFF1YXJ0ZXJseU5vdGVzO1xuZXhwb3J0cy5nZXRBbGxXZWVrbHlOb3RlcyA9IGdldEFsbFdlZWtseU5vdGVzO1xuZXhwb3J0cy5nZXRBbGxZZWFybHlOb3RlcyA9IGdldEFsbFllYXJseU5vdGVzO1xuZXhwb3J0cy5nZXREYWlseU5vdGUgPSBnZXREYWlseU5vdGU7XG5leHBvcnRzLmdldERhaWx5Tm90ZVNldHRpbmdzID0gZ2V0RGFpbHlOb3RlU2V0dGluZ3M7XG5leHBvcnRzLmdldERhdGVGcm9tRmlsZSA9IGdldERhdGVGcm9tRmlsZTtcbmV4cG9ydHMuZ2V0RGF0ZUZyb21QYXRoID0gZ2V0RGF0ZUZyb21QYXRoO1xuZXhwb3J0cy5nZXREYXRlVUlEID0gZ2V0RGF0ZVVJRDtcbmV4cG9ydHMuZ2V0TW9udGhseU5vdGUgPSBnZXRNb250aGx5Tm90ZTtcbmV4cG9ydHMuZ2V0TW9udGhseU5vdGVTZXR0aW5ncyA9IGdldE1vbnRobHlOb3RlU2V0dGluZ3M7XG5leHBvcnRzLmdldFBlcmlvZGljTm90ZVNldHRpbmdzID0gZ2V0UGVyaW9kaWNOb3RlU2V0dGluZ3M7XG5leHBvcnRzLmdldFF1YXJ0ZXJseU5vdGUgPSBnZXRRdWFydGVybHlOb3RlO1xuZXhwb3J0cy5nZXRRdWFydGVybHlOb3RlU2V0dGluZ3MgPSBnZXRRdWFydGVybHlOb3RlU2V0dGluZ3M7XG5leHBvcnRzLmdldFRlbXBsYXRlSW5mbyA9IGdldFRlbXBsYXRlSW5mbztcbmV4cG9ydHMuZ2V0V2Vla2x5Tm90ZSA9IGdldFdlZWtseU5vdGU7XG5leHBvcnRzLmdldFdlZWtseU5vdGVTZXR0aW5ncyA9IGdldFdlZWtseU5vdGVTZXR0aW5ncztcbmV4cG9ydHMuZ2V0WWVhcmx5Tm90ZSA9IGdldFllYXJseU5vdGU7XG5leHBvcnRzLmdldFllYXJseU5vdGVTZXR0aW5ncyA9IGdldFllYXJseU5vdGVTZXR0aW5ncztcbiIsICJpbXBvcnQgeyBQbHVnaW4sIFRGaWxlLCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBnZXRBbGxEYWlseU5vdGVzLCBnZXREYWlseU5vdGUgfSBmcm9tIFwib2JzaWRpYW4tZGFpbHktbm90ZXMtaW50ZXJmYWNlXCI7XG5pbXBvcnQgeyBnZXQgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG5pbXBvcnQgeyBWSUVXX1RZUEVfVElNRUxJTkUgfSBmcm9tIFwiLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IHBhcnNlUGxhbkl0ZW1zIH0gZnJvbSBcIi4vcGFyc2VyL3BhcnNlclwiO1xuaW1wb3J0IHsgRGF5UGxhbm5lclNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCB7IHRhc2tzIH0gZnJvbSBcIi4vc3RvcmUvdGltZWxpbmUtc3RvcmVcIjtcbmltcG9ydCB7IERheVBsYW5uZXJTZXR0aW5nc1RhYiB9IGZyb20gXCIuL3VpL3NldHRpbmdzLXRhYlwiO1xuaW1wb3J0IHsgU3RhdHVzQmFyIH0gZnJvbSBcIi4vdWkvc3RhdHVzLWJhclwiO1xuaW1wb3J0IFRpbWVsaW5lVmlldyBmcm9tIFwiLi91aS90aW1lbGluZS12aWV3XCI7XG5pbXBvcnQge1xuICBjcmVhdGVEYWlseU5vdGVJZk5lZWRlZCxcbiAgZGFpbHlOb3RlRXhpc3RzLFxuICBnZXREYWlseU5vdGVGb3JUb2RheSxcbn0gZnJvbSBcIi4vdXRpbC9kYWlseS1ub3Rlc1wiO1xuaW1wb3J0IHsgY3JlYXRlUGxhbm5lckhlYWRpbmcgfSBmcm9tIFwiLi9wbGFuXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERheVBsYW5uZXIgZXh0ZW5kcyBQbHVnaW4ge1xuICBzZXR0aW5nczogRGF5UGxhbm5lclNldHRpbmdzO1xuICBwcml2YXRlIHN0YXR1c0JhcjogU3RhdHVzQmFyO1xuXG4gIGFzeW5jIG9ubG9hZCgpIHtcbiAgICB0aGlzLnNldHRpbmdzID0gT2JqZWN0LmFzc2lnbihcbiAgICAgIG5ldyBEYXlQbGFubmVyU2V0dGluZ3MoKSxcbiAgICAgIGF3YWl0IHRoaXMubG9hZERhdGEoKSxcbiAgICApO1xuICAgIHRoaXMuc3RhdHVzQmFyID0gbmV3IFN0YXR1c0JhcihcbiAgICAgIHRoaXMuc2V0dGluZ3MsXG4gICAgICB0aGlzLmFkZFN0YXR1c0Jhckl0ZW0oKSxcbiAgICAgIHRoaXMuYXBwLndvcmtzcGFjZSxcbiAgICApO1xuXG4gICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgIGlkOiBcInNob3ctZGF5LXBsYW5uZXItdGltZWxpbmVcIixcbiAgICAgIG5hbWU6IFwiU2hvdyB0aGUgRGF5IFBsYW5uZXIgVGltZWxpbmVcIixcbiAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiBhd2FpdCB0aGlzLmluaXRMZWFmKCksXG4gICAgfSk7XG5cbiAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgaWQ6IFwic2hvdy1kYXktcGxhbm5lci10b2RheS1ub3RlXCIsXG4gICAgICBuYW1lOiBcIk9wZW4gdG9kYXkncyBEYXkgUGxhbm5lclwiLFxuICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+XG4gICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZVxuICAgICAgICAgIC5nZXRMZWFmKGZhbHNlKVxuICAgICAgICAgIC5vcGVuRmlsZShhd2FpdCBjcmVhdGVEYWlseU5vdGVJZk5lZWRlZCgpKSxcbiAgICB9KTtcblxuICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICBpZDogXCJpbnNlcnQtcGxhbm5lci1oZWFkaW5nLWF0LWN1cnNvclwiLFxuICAgICAgbmFtZTogXCJJbnNlcnQgUGxhbm5lciBIZWFkaW5nIGF0IEN1cnNvclwiLFxuICAgICAgZWRpdG9yQ2FsbGJhY2s6IChlZGl0b3IpID0+XG4gICAgICAgIGVkaXRvci5yZXBsYWNlU2VsZWN0aW9uKGNyZWF0ZVBsYW5uZXJIZWFkaW5nKCkpLFxuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlclZpZXcoXG4gICAgICBWSUVXX1RZUEVfVElNRUxJTkUsXG4gICAgICAobGVhZjogV29ya3NwYWNlTGVhZikgPT4gbmV3IFRpbWVsaW5lVmlldyhsZWFmLCB0aGlzLnNldHRpbmdzLCB0aGlzKSxcbiAgICApO1xuXG4gICAgdGhpcy5hZGRTZXR0aW5nVGFiKG5ldyBEYXlQbGFubmVyU2V0dGluZ3NUYWIodGhpcy5hcHAsIHRoaXMpKTtcblxuICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vbkxheW91dFJlYWR5KGFzeW5jICgpID0+IHtcbiAgICAgIGF3YWl0IHRoaXMucmVmcmVzaFBsYW5JdGVtc0luU3RvcmUoKTtcbiAgICB9KTtcblxuICAgIHRoaXMuYXBwLm1ldGFkYXRhQ2FjaGUub24oXCJjaGFuZ2VkXCIsIGFzeW5jIChmaWxlOiBURmlsZSkgPT4ge1xuICAgICAgaWYgKGZpbGUgPT09IGdldERhaWx5Tm90ZUZvclRvZGF5KCkpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5yZWZyZXNoUGxhbkl0ZW1zSW5TdG9yZSgpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdGhpcy5yZWdpc3RlckludGVydmFsKFxuICAgICAgd2luZG93LnNldEludGVydmFsKFxuICAgICAgICAoKSA9PiB0aGlzLnVwZGF0ZVN0YXR1c0Jhck9uRmFpbGVkKHRoaXMudXBkYXRlU3RhdHVzQmFyKSxcbiAgICAgICAgMTAwMCxcbiAgICAgICksXG4gICAgKTtcbiAgfVxuXG4gIG9udW5sb2FkKCkge1xuICAgIHRoaXMuZGV0YWNoVGltZWxpbmVMZWF2ZXMoKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgdXBkYXRlU3RhdHVzQmFyT25GYWlsZWQoZm46ICgpID0+IFByb21pc2U8dm9pZD4pIHtcbiAgICB0cnkge1xuICAgICAgYXdhaXQgZm4oKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdGhpcy5zdGF0dXNCYXIuc2V0VGV4dChgXHUyNkEwXHVGRTBGIFBsYW5uZXIgdXBkYXRlIGZhaWxlZCAoc2VlIGNvbnNvbGUpYCk7XG4gICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICB9XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJlZnJlc2hQbGFuSXRlbXNJblN0b3JlKCkge1xuICAgIGNvbnN0IHBhcnNlZFBsYW5JdGVtcyA9IGF3YWl0IHRoaXMuZ2V0UGxhbkl0ZW1zKCk7XG5cbiAgICB0YXNrcy51cGRhdGUoKCkgPT4gcGFyc2VkUGxhbkl0ZW1zKTtcbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlU3RhdHVzQmFyID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmIChkYWlseU5vdGVFeGlzdHMoKSkge1xuICAgICAgYXdhaXQgdGhpcy5zdGF0dXNCYXIudXBkYXRlKGdldCh0YXNrcykpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLnN0YXR1c0Jhci5zZXRFbXB0eSgpO1xuICAgIH1cbiAgfTtcblxuICBwcml2YXRlIGFzeW5jIGdldFBsYW5JdGVtcygpIHtcbiAgICBjb25zdCBkYWlseU5vdGUgPSBnZXREYWlseU5vdGUod2luZG93Lm1vbWVudCgpLCBnZXRBbGxEYWlseU5vdGVzKCkpO1xuXG4gICAgaWYgKCFkYWlseU5vdGUpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCBmaWxlQ29udGVudHMgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5jYWNoZWRSZWFkKGRhaWx5Tm90ZSk7XG4gICAgY29uc3QgbWV0YWRhdGEgPSB0aGlzLmFwcC5tZXRhZGF0YUNhY2hlLmdldEZpbGVDYWNoZShkYWlseU5vdGUpO1xuXG4gICAgcmV0dXJuIHBhcnNlUGxhbkl0ZW1zKFxuICAgICAgZmlsZUNvbnRlbnRzLFxuICAgICAgbWV0YWRhdGEsXG4gICAgICB0aGlzLnNldHRpbmdzLnBsYW5uZXJIZWFkaW5nLFxuICAgICAgZGFpbHlOb3RlLnBhdGgsXG4gICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgYXN5bmMgaW5pdExlYWYoKSB7XG4gICAgdGhpcy5kZXRhY2hUaW1lbGluZUxlYXZlcygpO1xuICAgIGF3YWl0IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRSaWdodExlYWYoZmFsc2UpLnNldFZpZXdTdGF0ZSh7XG4gICAgICB0eXBlOiBWSUVXX1RZUEVfVElNRUxJTkUsXG4gICAgICBhY3RpdmU6IHRydWUsXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIGRldGFjaFRpbWVsaW5lTGVhdmVzKCkge1xuICAgIHRoaXMuYXBwLndvcmtzcGFjZVxuICAgICAgLmdldExlYXZlc09mVHlwZShWSUVXX1RZUEVfVElNRUxJTkUpXG4gICAgICAuZm9yRWFjaCgobGVhZikgPT4gbGVhZi5kZXRhY2goKSk7XG4gIH1cbn1cbiIsICJmdW5jdGlvbiBub29wKCkgeyB9XG5jb25zdCBpZGVudGl0eSA9IHggPT4geDtcbmZ1bmN0aW9uIGFzc2lnbih0YXIsIHNyYykge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBmb3IgKGNvbnN0IGsgaW4gc3JjKVxuICAgICAgICB0YXJba10gPSBzcmNba107XG4gICAgcmV0dXJuIHRhcjtcbn1cbi8vIEFkYXB0ZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL2luZGV4LmpzXG4vLyBEaXN0cmlidXRlZCB1bmRlciBNSVQgTGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vdGhlbi9pcy1wcm9taXNlL2Jsb2IvbWFzdGVyL0xJQ0VOU0VcbmZ1bmN0aW9uIGlzX3Byb21pc2UodmFsdWUpIHtcbiAgICByZXR1cm4gISF2YWx1ZSAmJiAodHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpICYmIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gYWRkX2xvY2F0aW9uKGVsZW1lbnQsIGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhcikge1xuICAgIGVsZW1lbnQuX19zdmVsdGVfbWV0YSA9IHtcbiAgICAgICAgbG9jOiB7IGZpbGUsIGxpbmUsIGNvbHVtbiwgY2hhciB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHJ1bihmbikge1xuICAgIHJldHVybiBmbigpO1xufVxuZnVuY3Rpb24gYmxhbmtfb2JqZWN0KCkge1xuICAgIHJldHVybiBPYmplY3QuY3JlYXRlKG51bGwpO1xufVxuZnVuY3Rpb24gcnVuX2FsbChmbnMpIHtcbiAgICBmbnMuZm9yRWFjaChydW4pO1xufVxuZnVuY3Rpb24gaXNfZnVuY3Rpb24odGhpbmcpIHtcbiAgICByZXR1cm4gdHlwZW9mIHRoaW5nID09PSAnZnVuY3Rpb24nO1xufVxuZnVuY3Rpb24gc2FmZV9ub3RfZXF1YWwoYSwgYikge1xuICAgIHJldHVybiBhICE9IGEgPyBiID09IGIgOiBhICE9PSBiIHx8ICgoYSAmJiB0eXBlb2YgYSA9PT0gJ29iamVjdCcpIHx8IHR5cGVvZiBhID09PSAnZnVuY3Rpb24nKTtcbn1cbmxldCBzcmNfdXJsX2VxdWFsX2FuY2hvcjtcbmZ1bmN0aW9uIHNyY191cmxfZXF1YWwoZWxlbWVudF9zcmMsIHVybCkge1xuICAgIGlmICghc3JjX3VybF9lcXVhbF9hbmNob3IpIHtcbiAgICAgICAgc3JjX3VybF9lcXVhbF9hbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgfVxuICAgIHNyY191cmxfZXF1YWxfYW5jaG9yLmhyZWYgPSB1cmw7XG4gICAgcmV0dXJuIGVsZW1lbnRfc3JjID09PSBzcmNfdXJsX2VxdWFsX2FuY2hvci5ocmVmO1xufVxuZnVuY3Rpb24gbm90X2VxdWFsKGEsIGIpIHtcbiAgICByZXR1cm4gYSAhPSBhID8gYiA9PSBiIDogYSAhPT0gYjtcbn1cbmZ1bmN0aW9uIGlzX2VtcHR5KG9iaikge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3N0b3JlKHN0b3JlLCBuYW1lKSB7XG4gICAgaWYgKHN0b3JlICE9IG51bGwgJiYgdHlwZW9mIHN0b3JlLnN1YnNjcmliZSAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYCcke25hbWV9JyBpcyBub3QgYSBzdG9yZSB3aXRoIGEgJ3N1YnNjcmliZScgbWV0aG9kYCk7XG4gICAgfVxufVxuZnVuY3Rpb24gc3Vic2NyaWJlKHN0b3JlLCAuLi5jYWxsYmFja3MpIHtcbiAgICBpZiAoc3RvcmUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICB9XG4gICAgY29uc3QgdW5zdWIgPSBzdG9yZS5zdWJzY3JpYmUoLi4uY2FsbGJhY2tzKTtcbiAgICByZXR1cm4gdW5zdWIudW5zdWJzY3JpYmUgPyAoKSA9PiB1bnN1Yi51bnN1YnNjcmliZSgpIDogdW5zdWI7XG59XG5mdW5jdGlvbiBnZXRfc3RvcmVfdmFsdWUoc3RvcmUpIHtcbiAgICBsZXQgdmFsdWU7XG4gICAgc3Vic2NyaWJlKHN0b3JlLCBfID0+IHZhbHVlID0gXykoKTtcbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBjb21wb25lbnRfc3Vic2NyaWJlKGNvbXBvbmVudCwgc3RvcmUsIGNhbGxiYWNrKSB7XG4gICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaChzdWJzY3JpYmUoc3RvcmUsIGNhbGxiYWNrKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVfc2xvdChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb24pIHtcbiAgICAgICAgY29uc3Qgc2xvdF9jdHggPSBnZXRfc2xvdF9jb250ZXh0KGRlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZm4pO1xuICAgICAgICByZXR1cm4gZGVmaW5pdGlvblswXShzbG90X2N0eCk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0X3Nsb3RfY29udGV4dChkZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIGZuKSB7XG4gICAgcmV0dXJuIGRlZmluaXRpb25bMV0gJiYgZm5cbiAgICAgICAgPyBhc3NpZ24oJCRzY29wZS5jdHguc2xpY2UoKSwgZGVmaW5pdGlvblsxXShmbihjdHgpKSlcbiAgICAgICAgOiAkJHNjb3BlLmN0eDtcbn1cbmZ1bmN0aW9uIGdldF9zbG90X2NoYW5nZXMoZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGZuKSB7XG4gICAgaWYgKGRlZmluaXRpb25bMl0gJiYgZm4pIHtcbiAgICAgICAgY29uc3QgbGV0cyA9IGRlZmluaXRpb25bMl0oZm4oZGlydHkpKTtcbiAgICAgICAgaWYgKCQkc2NvcGUuZGlydHkgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIGxldHM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsZXRzID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgY29uc3QgbWVyZ2VkID0gW107XG4gICAgICAgICAgICBjb25zdCBsZW4gPSBNYXRoLm1heCgkJHNjb3BlLmRpcnR5Lmxlbmd0aCwgbGV0cy5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgIG1lcmdlZFtpXSA9ICQkc2NvcGUuZGlydHlbaV0gfCBsZXRzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJCRzY29wZS5kaXJ0eSB8IGxldHM7XG4gICAgfVxuICAgIHJldHVybiAkJHNjb3BlLmRpcnR5O1xufVxuZnVuY3Rpb24gdXBkYXRlX3Nsb3RfYmFzZShzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgc2xvdF9jaGFuZ2VzLCBnZXRfc2xvdF9jb250ZXh0X2ZuKSB7XG4gICAgaWYgKHNsb3RfY2hhbmdlcykge1xuICAgICAgICBjb25zdCBzbG90X2NvbnRleHQgPSBnZXRfc2xvdF9jb250ZXh0KHNsb3RfZGVmaW5pdGlvbiwgY3R4LCAkJHNjb3BlLCBnZXRfc2xvdF9jb250ZXh0X2ZuKTtcbiAgICAgICAgc2xvdC5wKHNsb3RfY29udGV4dCwgc2xvdF9jaGFuZ2VzKTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfc2xvdChzbG90LCBzbG90X2RlZmluaXRpb24sIGN0eCwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4sIGdldF9zbG90X2NvbnRleHRfZm4pIHtcbiAgICBjb25zdCBzbG90X2NoYW5nZXMgPSBnZXRfc2xvdF9jaGFuZ2VzKHNsb3RfZGVmaW5pdGlvbiwgJCRzY29wZSwgZGlydHksIGdldF9zbG90X2NoYW5nZXNfZm4pO1xuICAgIHVwZGF0ZV9zbG90X2Jhc2Uoc2xvdCwgc2xvdF9kZWZpbml0aW9uLCBjdHgsICQkc2NvcGUsIHNsb3RfY2hhbmdlcywgZ2V0X3Nsb3RfY29udGV4dF9mbik7XG59XG5mdW5jdGlvbiBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUoJCRzY29wZSkge1xuICAgIGlmICgkJHNjb3BlLmN0eC5sZW5ndGggPiAzMikge1xuICAgICAgICBjb25zdCBkaXJ0eSA9IFtdO1xuICAgICAgICBjb25zdCBsZW5ndGggPSAkJHNjb3BlLmN0eC5sZW5ndGggLyAzMjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZGlydHlbaV0gPSAtMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGlydHk7XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn1cbmZ1bmN0aW9uIGV4Y2x1ZGVfaW50ZXJuYWxfcHJvcHMocHJvcHMpIHtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gcHJvcHMpXG4gICAgICAgIGlmIChrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN1bHRba10gPSBwcm9wc1trXTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29tcHV0ZV9yZXN0X3Byb3BzKHByb3BzLCBrZXlzKSB7XG4gICAgY29uc3QgcmVzdCA9IHt9O1xuICAgIGtleXMgPSBuZXcgU2V0KGtleXMpO1xuICAgIGZvciAoY29uc3QgayBpbiBwcm9wcylcbiAgICAgICAgaWYgKCFrZXlzLmhhcyhrKSAmJiBrWzBdICE9PSAnJCcpXG4gICAgICAgICAgICByZXN0W2tdID0gcHJvcHNba107XG4gICAgcmV0dXJuIHJlc3Q7XG59XG5mdW5jdGlvbiBjb21wdXRlX3Nsb3RzKHNsb3RzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2xvdHMpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gb25jZShmbikge1xuICAgIGxldCByYW4gPSBmYWxzZTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKHJhbilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgICAgZm4uY2FsbCh0aGlzLCAuLi5hcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gbnVsbF90b19lbXB0eSh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gJycgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIHNldF9zdG9yZV92YWx1ZShzdG9yZSwgcmV0LCB2YWx1ZSkge1xuICAgIHN0b3JlLnNldCh2YWx1ZSk7XG4gICAgcmV0dXJuIHJldDtcbn1cbmNvbnN0IGhhc19wcm9wID0gKG9iaiwgcHJvcCkgPT4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG5mdW5jdGlvbiBhY3Rpb25fZGVzdHJveWVyKGFjdGlvbl9yZXN1bHQpIHtcbiAgICByZXR1cm4gYWN0aW9uX3Jlc3VsdCAmJiBpc19mdW5jdGlvbihhY3Rpb25fcmVzdWx0LmRlc3Ryb3kpID8gYWN0aW9uX3Jlc3VsdC5kZXN0cm95IDogbm9vcDtcbn1cbmZ1bmN0aW9uIHNwbGl0X2Nzc191bml0KHZhbHVlKSB7XG4gICAgY29uc3Qgc3BsaXQgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnICYmIHZhbHVlLm1hdGNoKC9eXFxzKigtP1tcXGQuXSspKFteXFxzXSopXFxzKiQvKTtcbiAgICByZXR1cm4gc3BsaXQgPyBbcGFyc2VGbG9hdChzcGxpdFsxXSksIHNwbGl0WzJdIHx8ICdweCddIDogW3ZhbHVlLCAncHgnXTtcbn1cbmNvbnN0IGNvbnRlbnRlZGl0YWJsZV90cnV0aHlfdmFsdWVzID0gWycnLCB0cnVlLCAxLCAndHJ1ZScsICdjb250ZW50ZWRpdGFibGUnXTtcblxuY29uc3QgaXNfY2xpZW50ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG5sZXQgbm93ID0gaXNfY2xpZW50XG4gICAgPyAoKSA9PiB3aW5kb3cucGVyZm9ybWFuY2Uubm93KClcbiAgICA6ICgpID0+IERhdGUubm93KCk7XG5sZXQgcmFmID0gaXNfY2xpZW50ID8gY2IgPT4gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGNiKSA6IG5vb3A7XG4vLyB1c2VkIGludGVybmFsbHkgZm9yIHRlc3RpbmdcbmZ1bmN0aW9uIHNldF9ub3coZm4pIHtcbiAgICBub3cgPSBmbjtcbn1cbmZ1bmN0aW9uIHNldF9yYWYoZm4pIHtcbiAgICByYWYgPSBmbjtcbn1cblxuY29uc3QgdGFza3MgPSBuZXcgU2V0KCk7XG5mdW5jdGlvbiBydW5fdGFza3Mobm93KSB7XG4gICAgdGFza3MuZm9yRWFjaCh0YXNrID0+IHtcbiAgICAgICAgaWYgKCF0YXNrLmMobm93KSkge1xuICAgICAgICAgICAgdGFza3MuZGVsZXRlKHRhc2spO1xuICAgICAgICAgICAgdGFzay5mKCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBpZiAodGFza3Muc2l6ZSAhPT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG59XG4vKipcbiAqIEZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkhXG4gKi9cbmZ1bmN0aW9uIGNsZWFyX2xvb3BzKCkge1xuICAgIHRhc2tzLmNsZWFyKCk7XG59XG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgdGFzayB0aGF0IHJ1bnMgb24gZWFjaCByYWYgZnJhbWVcbiAqIHVudGlsIGl0IHJldHVybnMgYSBmYWxzeSB2YWx1ZSBvciBpcyBhYm9ydGVkXG4gKi9cbmZ1bmN0aW9uIGxvb3AoY2FsbGJhY2spIHtcbiAgICBsZXQgdGFzaztcbiAgICBpZiAodGFza3Muc2l6ZSA9PT0gMClcbiAgICAgICAgcmFmKHJ1bl90YXNrcyk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcHJvbWlzZTogbmV3IFByb21pc2UoZnVsZmlsbCA9PiB7XG4gICAgICAgICAgICB0YXNrcy5hZGQodGFzayA9IHsgYzogY2FsbGJhY2ssIGY6IGZ1bGZpbGwgfSk7XG4gICAgICAgIH0pLFxuICAgICAgICBhYm9ydCgpIHtcbiAgICAgICAgICAgIHRhc2tzLmRlbGV0ZSh0YXNrKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmNvbnN0IGdsb2JhbHMgPSAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCdcbiAgICA/IHdpbmRvd1xuICAgIDogdHlwZW9mIGdsb2JhbFRoaXMgIT09ICd1bmRlZmluZWQnXG4gICAgICAgID8gZ2xvYmFsVGhpc1xuICAgICAgICA6IGdsb2JhbCk7XG5cbi8qKlxuICogUmVzaXplIG9ic2VydmVyIHNpbmdsZXRvbi5cbiAqIE9uZSBsaXN0ZW5lciBwZXIgZWxlbWVudCBvbmx5IVxuICogaHR0cHM6Ly9ncm91cHMuZ29vZ2xlLmNvbS9hL2Nocm9taXVtLm9yZy9nL2JsaW5rLWRldi9jL3o2aWVuT05VYjVBL20vRjUtVmNVWnRCQUFKXG4gKi9cbmNsYXNzIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uIHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9ICdXZWFrTWFwJyBpbiBnbG9iYWxzID8gbmV3IFdlYWtNYXAoKSA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgb2JzZXJ2ZShlbGVtZW50LCBsaXN0ZW5lcikge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMuc2V0KGVsZW1lbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5fZ2V0T2JzZXJ2ZXIoKS5vYnNlcnZlKGVsZW1lbnQsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnMuZGVsZXRlKGVsZW1lbnQpO1xuICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIudW5vYnNlcnZlKGVsZW1lbnQpOyAvLyB0aGlzIGxpbmUgY2FuIHByb2JhYmx5IGJlIHJlbW92ZWRcbiAgICAgICAgfTtcbiAgICB9XG4gICAgX2dldE9ic2VydmVyKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiAoX2EgPSB0aGlzLl9vYnNlcnZlcikgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogKHRoaXMuX29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKChlbnRyaWVzKSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVudHJ5IG9mIGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBSZXNpemVPYnNlcnZlclNpbmdsZXRvbi5lbnRyaWVzLnNldChlbnRyeS50YXJnZXQsIGVudHJ5KTtcbiAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLl9saXN0ZW5lcnMuZ2V0KGVudHJ5LnRhcmdldCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYShlbnRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKTtcbiAgICB9XG59XG4vLyBOZWVkcyB0byBiZSB3cml0dGVuIGxpa2UgdGhpcyB0byBwYXNzIHRoZSB0cmVlLXNoYWtlLXRlc3RcblJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLmVudHJpZXMgPSAnV2Vha01hcCcgaW4gZ2xvYmFscyA/IG5ldyBXZWFrTWFwKCkgOiB1bmRlZmluZWQ7XG5cbi8vIFRyYWNrIHdoaWNoIG5vZGVzIGFyZSBjbGFpbWVkIGR1cmluZyBoeWRyYXRpb24uIFVuY2xhaW1lZCBub2RlcyBjYW4gdGhlbiBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuLy8gYXQgdGhlIGVuZCBvZiBoeWRyYXRpb24gd2l0aG91dCB0b3VjaGluZyB0aGUgcmVtYWluaW5nIG5vZGVzLlxubGV0IGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xuZnVuY3Rpb24gc3RhcnRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IHRydWU7XG59XG5mdW5jdGlvbiBlbmRfaHlkcmF0aW5nKCkge1xuICAgIGlzX2h5ZHJhdGluZyA9IGZhbHNlO1xufVxuZnVuY3Rpb24gdXBwZXJfYm91bmQobG93LCBoaWdoLCBrZXksIHZhbHVlKSB7XG4gICAgLy8gUmV0dXJuIGZpcnN0IGluZGV4IG9mIHZhbHVlIGxhcmdlciB0aGFuIGlucHV0IHZhbHVlIGluIHRoZSByYW5nZSBbbG93LCBoaWdoKVxuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICAgIGNvbnN0IG1pZCA9IGxvdyArICgoaGlnaCAtIGxvdykgPj4gMSk7XG4gICAgICAgIGlmIChrZXkobWlkKSA8PSB2YWx1ZSkge1xuICAgICAgICAgICAgbG93ID0gbWlkICsgMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGhpZ2ggPSBtaWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGxvdztcbn1cbmZ1bmN0aW9uIGluaXRfaHlkcmF0ZSh0YXJnZXQpIHtcbiAgICBpZiAodGFyZ2V0Lmh5ZHJhdGVfaW5pdClcbiAgICAgICAgcmV0dXJuO1xuICAgIHRhcmdldC5oeWRyYXRlX2luaXQgPSB0cnVlO1xuICAgIC8vIFdlIGtub3cgdGhhdCBhbGwgY2hpbGRyZW4gaGF2ZSBjbGFpbV9vcmRlciB2YWx1ZXMgc2luY2UgdGhlIHVuY2xhaW1lZCBoYXZlIGJlZW4gZGV0YWNoZWQgaWYgdGFyZ2V0IGlzIG5vdCA8aGVhZD5cbiAgICBsZXQgY2hpbGRyZW4gPSB0YXJnZXQuY2hpbGROb2RlcztcbiAgICAvLyBJZiB0YXJnZXQgaXMgPGhlYWQ+LCB0aGVyZSBtYXkgYmUgY2hpbGRyZW4gd2l0aG91dCBjbGFpbV9vcmRlclxuICAgIGlmICh0YXJnZXQubm9kZU5hbWUgPT09ICdIRUFEJykge1xuICAgICAgICBjb25zdCBteUNoaWxkcmVuID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBteUNoaWxkcmVuLnB1c2gobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRyZW4gPSBteUNoaWxkcmVuO1xuICAgIH1cbiAgICAvKlxuICAgICogUmVvcmRlciBjbGFpbWVkIGNoaWxkcmVuIG9wdGltYWxseS5cbiAgICAqIFdlIGNhbiByZW9yZGVyIGNsYWltZWQgY2hpbGRyZW4gb3B0aW1hbGx5IGJ5IGZpbmRpbmcgdGhlIGxvbmdlc3Qgc3Vic2VxdWVuY2Ugb2ZcbiAgICAqIG5vZGVzIHRoYXQgYXJlIGFscmVhZHkgY2xhaW1lZCBpbiBvcmRlciBhbmQgb25seSBtb3ZpbmcgdGhlIHJlc3QuIFRoZSBsb25nZXN0XG4gICAgKiBzdWJzZXF1ZW5jZSBvZiBub2RlcyB0aGF0IGFyZSBjbGFpbWVkIGluIG9yZGVyIGNhbiBiZSBmb3VuZCBieVxuICAgICogY29tcHV0aW5nIHRoZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgLmNsYWltX29yZGVyIHZhbHVlcy5cbiAgICAqXG4gICAgKiBUaGlzIGFsZ29yaXRobSBpcyBvcHRpbWFsIGluIGdlbmVyYXRpbmcgdGhlIGxlYXN0IGFtb3VudCBvZiByZW9yZGVyIG9wZXJhdGlvbnNcbiAgICAqIHBvc3NpYmxlLlxuICAgICpcbiAgICAqIFByb29mOlxuICAgICogV2Uga25vdyB0aGF0LCBnaXZlbiBhIHNldCBvZiByZW9yZGVyaW5nIG9wZXJhdGlvbnMsIHRoZSBub2RlcyB0aGF0IGRvIG5vdCBtb3ZlXG4gICAgKiBhbHdheXMgZm9ybSBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLCBzaW5jZSB0aGV5IGRvIG5vdCBtb3ZlIGFtb25nIGVhY2ggb3RoZXJcbiAgICAqIG1lYW5pbmcgdGhhdCB0aGV5IG11c3QgYmUgYWxyZWFkeSBvcmRlcmVkIGFtb25nIGVhY2ggb3RoZXIuIFRodXMsIHRoZSBtYXhpbWFsXG4gICAgKiBzZXQgb2Ygbm9kZXMgdGhhdCBkbyBub3QgbW92ZSBmb3JtIGEgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlLlxuICAgICovXG4gICAgLy8gQ29tcHV0ZSBsb25nZXN0IGluY3JlYXNpbmcgc3Vic2VxdWVuY2VcbiAgICAvLyBtOiBzdWJzZXF1ZW5jZSBsZW5ndGggaiA9PiBpbmRleCBrIG9mIHNtYWxsZXN0IHZhbHVlIHRoYXQgZW5kcyBhbiBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIGxlbmd0aCBqXG4gICAgY29uc3QgbSA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCArIDEpO1xuICAgIC8vIFByZWRlY2Vzc29yIGluZGljZXMgKyAxXG4gICAgY29uc3QgcCA9IG5ldyBJbnQzMkFycmF5KGNoaWxkcmVuLmxlbmd0aCk7XG4gICAgbVswXSA9IC0xO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnQgPSBjaGlsZHJlbltpXS5jbGFpbV9vcmRlcjtcbiAgICAgICAgLy8gRmluZCB0aGUgbGFyZ2VzdCBzdWJzZXF1ZW5jZSBsZW5ndGggc3VjaCB0aGF0IGl0IGVuZHMgaW4gYSB2YWx1ZSBsZXNzIHRoYW4gb3VyIGN1cnJlbnQgdmFsdWVcbiAgICAgICAgLy8gdXBwZXJfYm91bmQgcmV0dXJucyBmaXJzdCBncmVhdGVyIHZhbHVlLCBzbyB3ZSBzdWJ0cmFjdCBvbmVcbiAgICAgICAgLy8gd2l0aCBmYXN0IHBhdGggZm9yIHdoZW4gd2UgYXJlIG9uIHRoZSBjdXJyZW50IGxvbmdlc3Qgc3Vic2VxdWVuY2VcbiAgICAgICAgY29uc3Qgc2VxTGVuID0gKChsb25nZXN0ID4gMCAmJiBjaGlsZHJlblttW2xvbmdlc3RdXS5jbGFpbV9vcmRlciA8PSBjdXJyZW50KSA/IGxvbmdlc3QgKyAxIDogdXBwZXJfYm91bmQoMSwgbG9uZ2VzdCwgaWR4ID0+IGNoaWxkcmVuW21baWR4XV0uY2xhaW1fb3JkZXIsIGN1cnJlbnQpKSAtIDE7XG4gICAgICAgIHBbaV0gPSBtW3NlcUxlbl0gKyAxO1xuICAgICAgICBjb25zdCBuZXdMZW4gPSBzZXFMZW4gKyAxO1xuICAgICAgICAvLyBXZSBjYW4gZ3VhcmFudGVlIHRoYXQgY3VycmVudCBpcyB0aGUgc21hbGxlc3QgdmFsdWUuIE90aGVyd2lzZSwgd2Ugd291bGQgaGF2ZSBnZW5lcmF0ZWQgYSBsb25nZXIgc2VxdWVuY2UuXG4gICAgICAgIG1bbmV3TGVuXSA9IGk7XG4gICAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuZXdMZW4sIGxvbmdlc3QpO1xuICAgIH1cbiAgICAvLyBUaGUgbG9uZ2VzdCBpbmNyZWFzaW5nIHN1YnNlcXVlbmNlIG9mIG5vZGVzIChpbml0aWFsbHkgcmV2ZXJzZWQpXG4gICAgY29uc3QgbGlzID0gW107XG4gICAgLy8gVGhlIHJlc3Qgb2YgdGhlIG5vZGVzLCBub2RlcyB0aGF0IHdpbGwgYmUgbW92ZWRcbiAgICBjb25zdCB0b01vdmUgPSBbXTtcbiAgICBsZXQgbGFzdCA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7XG4gICAgZm9yIChsZXQgY3VyID0gbVtsb25nZXN0XSArIDE7IGN1ciAhPSAwOyBjdXIgPSBwW2N1ciAtIDFdKSB7XG4gICAgICAgIGxpcy5wdXNoKGNoaWxkcmVuW2N1ciAtIDFdKTtcbiAgICAgICAgZm9yICg7IGxhc3QgPj0gY3VyOyBsYXN0LS0pIHtcbiAgICAgICAgICAgIHRvTW92ZS5wdXNoKGNoaWxkcmVuW2xhc3RdKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0LS07XG4gICAgfVxuICAgIGZvciAoOyBsYXN0ID49IDA7IGxhc3QtLSkge1xuICAgICAgICB0b01vdmUucHVzaChjaGlsZHJlbltsYXN0XSk7XG4gICAgfVxuICAgIGxpcy5yZXZlcnNlKCk7XG4gICAgLy8gV2Ugc29ydCB0aGUgbm9kZXMgYmVpbmcgbW92ZWQgdG8gZ3VhcmFudGVlIHRoYXQgdGhlaXIgaW5zZXJ0aW9uIG9yZGVyIG1hdGNoZXMgdGhlIGNsYWltIG9yZGVyXG4gICAgdG9Nb3ZlLnNvcnQoKGEsIGIpID0+IGEuY2xhaW1fb3JkZXIgLSBiLmNsYWltX29yZGVyKTtcbiAgICAvLyBGaW5hbGx5LCB3ZSBtb3ZlIHRoZSBub2Rlc1xuICAgIGZvciAobGV0IGkgPSAwLCBqID0gMDsgaSA8IHRvTW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB3aGlsZSAoaiA8IGxpcy5sZW5ndGggJiYgdG9Nb3ZlW2ldLmNsYWltX29yZGVyID49IGxpc1tqXS5jbGFpbV9vcmRlcikge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFuY2hvciA9IGogPCBsaXMubGVuZ3RoID8gbGlzW2pdIDogbnVsbDtcbiAgICAgICAgdGFyZ2V0Lmluc2VydEJlZm9yZSh0b01vdmVbaV0sIGFuY2hvcik7XG4gICAgfVxufVxuZnVuY3Rpb24gYXBwZW5kKHRhcmdldCwgbm9kZSkge1xuICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9zdHlsZXModGFyZ2V0LCBzdHlsZV9zaGVldF9pZCwgc3R5bGVzKSB7XG4gICAgY29uc3QgYXBwZW5kX3N0eWxlc190byA9IGdldF9yb290X2Zvcl9zdHlsZSh0YXJnZXQpO1xuICAgIGlmICghYXBwZW5kX3N0eWxlc190by5nZXRFbGVtZW50QnlJZChzdHlsZV9zaGVldF9pZCkpIHtcbiAgICAgICAgY29uc3Qgc3R5bGUgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBzdHlsZS5pZCA9IHN0eWxlX3NoZWV0X2lkO1xuICAgICAgICBzdHlsZS50ZXh0Q29udGVudCA9IHN0eWxlcztcbiAgICAgICAgYXBwZW5kX3N0eWxlc2hlZXQoYXBwZW5kX3N0eWxlc190bywgc3R5bGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldF9yb290X2Zvcl9zdHlsZShub2RlKSB7XG4gICAgaWYgKCFub2RlKVxuICAgICAgICByZXR1cm4gZG9jdW1lbnQ7XG4gICAgY29uc3Qgcm9vdCA9IG5vZGUuZ2V0Um9vdE5vZGUgPyBub2RlLmdldFJvb3ROb2RlKCkgOiBub2RlLm93bmVyRG9jdW1lbnQ7XG4gICAgaWYgKHJvb3QgJiYgcm9vdC5ob3N0KSB7XG4gICAgICAgIHJldHVybiByb290O1xuICAgIH1cbiAgICByZXR1cm4gbm9kZS5vd25lckRvY3VtZW50O1xufVxuZnVuY3Rpb24gYXBwZW5kX2VtcHR5X3N0eWxlc2hlZXQobm9kZSkge1xuICAgIGNvbnN0IHN0eWxlX2VsZW1lbnQgPSBlbGVtZW50KCdzdHlsZScpO1xuICAgIGFwcGVuZF9zdHlsZXNoZWV0KGdldF9yb290X2Zvcl9zdHlsZShub2RlKSwgc3R5bGVfZWxlbWVudCk7XG4gICAgcmV0dXJuIHN0eWxlX2VsZW1lbnQuc2hlZXQ7XG59XG5mdW5jdGlvbiBhcHBlbmRfc3R5bGVzaGVldChub2RlLCBzdHlsZSkge1xuICAgIGFwcGVuZChub2RlLmhlYWQgfHwgbm9kZSwgc3R5bGUpO1xuICAgIHJldHVybiBzdHlsZS5zaGVldDtcbn1cbmZ1bmN0aW9uIGFwcGVuZF9oeWRyYXRpb24odGFyZ2V0LCBub2RlKSB7XG4gICAgaWYgKGlzX2h5ZHJhdGluZykge1xuICAgICAgICBpbml0X2h5ZHJhdGUodGFyZ2V0KTtcbiAgICAgICAgaWYgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9PT0gdW5kZWZpbmVkKSB8fCAoKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkICE9PSBudWxsKSAmJiAodGFyZ2V0LmFjdHVhbF9lbmRfY2hpbGQucGFyZW50Tm9kZSAhPT0gdGFyZ2V0KSkpIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gdGFyZ2V0LmZpcnN0Q2hpbGQ7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2tpcCBub2RlcyBvZiB1bmRlZmluZWQgb3JkZXJpbmdcbiAgICAgICAgd2hpbGUgKCh0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCAhPT0gbnVsbCkgJiYgKHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLmNsYWltX29yZGVyID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgICAgICB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCA9IHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkLm5leHRTaWJsaW5nO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlICE9PSB0YXJnZXQuYWN0dWFsX2VuZF9jaGlsZCkge1xuICAgICAgICAgICAgLy8gV2Ugb25seSBpbnNlcnQgaWYgdGhlIG9yZGVyaW5nIG9mIHRoaXMgbm9kZSBzaG91bGQgYmUgbW9kaWZpZWQgb3IgdGhlIHBhcmVudCBub2RlIGlzIG5vdCB0YXJnZXRcbiAgICAgICAgICAgIGlmIChub2RlLmNsYWltX29yZGVyICE9PSB1bmRlZmluZWQgfHwgbm9kZS5wYXJlbnROb2RlICE9PSB0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRhcmdldC5hY3R1YWxfZW5kX2NoaWxkID0gbm9kZS5uZXh0U2libGluZztcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9PSBudWxsKSB7XG4gICAgICAgIHRhcmdldC5hcHBlbmRDaGlsZChub2RlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBpbnNlcnQodGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbn1cbmZ1bmN0aW9uIGluc2VydF9oeWRyYXRpb24odGFyZ2V0LCBub2RlLCBhbmNob3IpIHtcbiAgICBpZiAoaXNfaHlkcmF0aW5nICYmICFhbmNob3IpIHtcbiAgICAgICAgYXBwZW5kX2h5ZHJhdGlvbih0YXJnZXQsIG5vZGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChub2RlLnBhcmVudE5vZGUgIT09IHRhcmdldCB8fCBub2RlLm5leHRTaWJsaW5nICE9IGFuY2hvcikge1xuICAgICAgICB0YXJnZXQuaW5zZXJ0QmVmb3JlKG5vZGUsIGFuY2hvciB8fCBudWxsKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2gobm9kZSkge1xuICAgIGlmIChub2RlLnBhcmVudE5vZGUpIHtcbiAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRlc3Ryb3lfZWFjaChpdGVyYXRpb25zLCBkZXRhY2hpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZXJhdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgaWYgKGl0ZXJhdGlvbnNbaV0pXG4gICAgICAgICAgICBpdGVyYXRpb25zW2ldLmQoZGV0YWNoaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBlbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lKTtcbn1cbmZ1bmN0aW9uIGVsZW1lbnRfaXMobmFtZSwgaXMpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChuYW1lLCB7IGlzIH0pO1xufVxuZnVuY3Rpb24gb2JqZWN0X3dpdGhvdXRfcHJvcGVydGllcyhvYmosIGV4Y2x1ZGUpIHtcbiAgICBjb25zdCB0YXJnZXQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGsgaW4gb2JqKSB7XG4gICAgICAgIGlmIChoYXNfcHJvcChvYmosIGspXG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAmJiBleGNsdWRlLmluZGV4T2YoaykgPT09IC0xKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICB0YXJnZXRba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cbmZ1bmN0aW9uIHN2Z19lbGVtZW50KG5hbWUpIHtcbiAgICByZXR1cm4gZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKCdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsIG5hbWUpO1xufVxuZnVuY3Rpb24gdGV4dChkYXRhKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGRhdGEpO1xufVxuZnVuY3Rpb24gc3BhY2UoKSB7XG4gICAgcmV0dXJuIHRleHQoJyAnKTtcbn1cbmZ1bmN0aW9uIGVtcHR5KCkge1xuICAgIHJldHVybiB0ZXh0KCcnKTtcbn1cbmZ1bmN0aW9uIGNvbW1lbnQoY29udGVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gbGlzdGVuKG5vZGUsIGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbiAgICByZXR1cm4gKCkgPT4gbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVyLCBvcHRpb25zKTtcbn1cbmZ1bmN0aW9uIHByZXZlbnRfZGVmYXVsdChmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHN0b3BfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc3RvcF9pbW1lZGlhdGVfcHJvcGFnYXRpb24oZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiBmbi5jYWxsKHRoaXMsIGV2ZW50KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VsZihmbikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICBpZiAoZXZlbnQudGFyZ2V0ID09PSB0aGlzKVxuICAgICAgICAgICAgZm4uY2FsbCh0aGlzLCBldmVudCk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIHRydXN0ZWQoZm4pIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgaWYgKGV2ZW50LmlzVHJ1c3RlZClcbiAgICAgICAgICAgIGZuLmNhbGwodGhpcywgZXZlbnQpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyKG5vZGUsIGF0dHJpYnV0ZSwgdmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgbm9kZS5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlKTtcbiAgICBlbHNlIGlmIChub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGUpICE9PSB2YWx1ZSlcbiAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoYXR0cmlidXRlLCB2YWx1ZSk7XG59XG4vKipcbiAqIExpc3Qgb2YgYXR0cmlidXRlcyB0aGF0IHNob3VsZCBhbHdheXMgYmUgc2V0IHRocm91Z2ggdGhlIGF0dHIgbWV0aG9kLFxuICogYmVjYXVzZSB1cGRhdGluZyB0aGVtIHRocm91Z2ggdGhlIHByb3BlcnR5IHNldHRlciBkb2Vzbid0IHdvcmsgcmVsaWFibHkuXG4gKiBJbiB0aGUgZXhhbXBsZSBvZiBgd2lkdGhgL2BoZWlnaHRgLCB0aGUgcHJvYmxlbSBpcyB0aGF0IHRoZSBzZXR0ZXIgb25seVxuICogYWNjZXB0cyBudW1lcmljIHZhbHVlcywgYnV0IHRoZSBhdHRyaWJ1dGUgY2FuIGFsc28gYmUgc2V0IHRvIGEgc3RyaW5nIGxpa2UgYDUwJWAuXG4gKiBJZiB0aGlzIGxpc3QgYmVjb21lcyB0b28gYmlnLCByZXRoaW5rIHRoaXMgYXBwcm9hY2guXG4gKi9cbmNvbnN0IGFsd2F5c19zZXRfdGhyb3VnaF9zZXRfYXR0cmlidXRlID0gWyd3aWR0aCcsICdoZWlnaHQnXTtcbmZ1bmN0aW9uIHNldF9hdHRyaWJ1dGVzKG5vZGUsIGF0dHJpYnV0ZXMpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgY29uc3QgZGVzY3JpcHRvcnMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhub2RlLl9fcHJvdG9fXyk7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBpZiAoYXR0cmlidXRlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIG5vZGUucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnc3R5bGUnKSB7XG4gICAgICAgICAgICBub2RlLnN0eWxlLmNzc1RleHQgPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoa2V5ID09PSAnX192YWx1ZScpIHtcbiAgICAgICAgICAgIG5vZGUudmFsdWUgPSBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRvcnNba2V5XSAmJiBkZXNjcmlwdG9yc1trZXldLnNldCAmJiBhbHdheXNfc2V0X3Rocm91Z2hfc2V0X2F0dHJpYnV0ZS5pbmRleE9mKGtleSkgPT09IC0xKSB7XG4gICAgICAgICAgICBub2RlW2tleV0gPSBhdHRyaWJ1dGVzW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdmdfYXR0cmlidXRlcyhub2RlLCBhdHRyaWJ1dGVzKSB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gYXR0cmlidXRlcykge1xuICAgICAgICBhdHRyKG5vZGUsIGtleSwgYXR0cmlidXRlc1trZXldKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAobm9kZSwgZGF0YV9tYXApIHtcbiAgICBPYmplY3Qua2V5cyhkYXRhX21hcCkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgIHNldF9jdXN0b21fZWxlbWVudF9kYXRhKG5vZGUsIGtleSwgZGF0YV9tYXBba2V5XSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YShub2RlLCBwcm9wLCB2YWx1ZSkge1xuICAgIGlmIChwcm9wIGluIG5vZGUpIHtcbiAgICAgICAgbm9kZVtwcm9wXSA9IHR5cGVvZiBub2RlW3Byb3BdID09PSAnYm9vbGVhbicgJiYgdmFsdWUgPT09ICcnID8gdHJ1ZSA6IHZhbHVlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgYXR0cihub2RlLCBwcm9wLCB2YWx1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gc2V0X2R5bmFtaWNfZWxlbWVudF9kYXRhKHRhZykge1xuICAgIHJldHVybiAoLy0vLnRlc3QodGFnKSkgPyBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAgOiBzZXRfYXR0cmlidXRlcztcbn1cbmZ1bmN0aW9uIHhsaW5rX2F0dHIobm9kZSwgYXR0cmlidXRlLCB2YWx1ZSkge1xuICAgIG5vZGUuc2V0QXR0cmlidXRlTlMoJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbn1cbmZ1bmN0aW9uIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlKGdyb3VwLCBfX3ZhbHVlLCBjaGVja2VkKSB7XG4gICAgY29uc3QgdmFsdWUgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBncm91cC5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICBpZiAoZ3JvdXBbaV0uY2hlY2tlZClcbiAgICAgICAgICAgIHZhbHVlLmFkZChncm91cFtpXS5fX3ZhbHVlKTtcbiAgICB9XG4gICAgaWYgKCFjaGVja2VkKSB7XG4gICAgICAgIHZhbHVlLmRlbGV0ZShfX3ZhbHVlKTtcbiAgICB9XG4gICAgcmV0dXJuIEFycmF5LmZyb20odmFsdWUpO1xufVxuZnVuY3Rpb24gaW5pdF9iaW5kaW5nX2dyb3VwKGdyb3VwKSB7XG4gICAgbGV0IF9pbnB1dHM7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuICAgICAgICAgICAgX2lucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgIF9pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBncm91cC5wdXNoKGlucHV0KSk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qIHJlbW92ZSAqLyByKCkge1xuICAgICAgICAgICAgX2lucHV0cy5mb3JFYWNoKGlucHV0ID0+IGdyb3VwLnNwbGljZShncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGluaXRfYmluZGluZ19ncm91cF9keW5hbWljKGdyb3VwLCBpbmRleGVzKSB7XG4gICAgbGV0IF9ncm91cCA9IGdldF9iaW5kaW5nX2dyb3VwKGdyb3VwKTtcbiAgICBsZXQgX2lucHV0cztcbiAgICBmdW5jdGlvbiBnZXRfYmluZGluZ19ncm91cChncm91cCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGluZGV4ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGdyb3VwID0gZ3JvdXBbaW5kZXhlc1tpXV0gPSBncm91cFtpbmRleGVzW2ldXSB8fCBbXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHB1c2goKSB7XG4gICAgICAgIF9pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBfZ3JvdXAucHVzaChpbnB1dCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgICAgIF9pbnB1dHMuZm9yRWFjaChpbnB1dCA9PiBfZ3JvdXAuc3BsaWNlKF9ncm91cC5pbmRleE9mKGlucHV0KSwgMSkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAvKiB1cGRhdGUgKi8gdShuZXdfaW5kZXhlcykge1xuICAgICAgICAgICAgaW5kZXhlcyA9IG5ld19pbmRleGVzO1xuICAgICAgICAgICAgY29uc3QgbmV3X2dyb3VwID0gZ2V0X2JpbmRpbmdfZ3JvdXAoZ3JvdXApO1xuICAgICAgICAgICAgaWYgKG5ld19ncm91cCAhPT0gX2dyb3VwKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgX2dyb3VwID0gbmV3X2dyb3VwO1xuICAgICAgICAgICAgICAgIHB1c2goKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyogcHVzaCAqLyBwKC4uLmlucHV0cykge1xuICAgICAgICAgICAgX2lucHV0cyA9IGlucHV0cztcbiAgICAgICAgICAgIHB1c2goKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyogcmVtb3ZlICovIHI6IHJlbW92ZVxuICAgIH07XG59XG5mdW5jdGlvbiB0b19udW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPT09ICcnID8gbnVsbCA6ICt2YWx1ZTtcbn1cbmZ1bmN0aW9uIHRpbWVfcmFuZ2VzX3RvX2FycmF5KHJhbmdlcykge1xuICAgIGNvbnN0IGFycmF5ID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgYXJyYXkucHVzaCh7IHN0YXJ0OiByYW5nZXMuc3RhcnQoaSksIGVuZDogcmFuZ2VzLmVuZChpKSB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZnVuY3Rpb24gY2hpbGRyZW4oZWxlbWVudCkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGVsZW1lbnQuY2hpbGROb2Rlcyk7XG59XG5mdW5jdGlvbiBpbml0X2NsYWltX2luZm8obm9kZXMpIHtcbiAgICBpZiAobm9kZXMuY2xhaW1faW5mbyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIG5vZGVzLmNsYWltX2luZm8gPSB7IGxhc3RfaW5kZXg6IDAsIHRvdGFsX2NsYWltZWQ6IDAgfTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGFpbV9ub2RlKG5vZGVzLCBwcmVkaWNhdGUsIHByb2Nlc3NOb2RlLCBjcmVhdGVOb2RlLCBkb250VXBkYXRlTGFzdEluZGV4ID0gZmFsc2UpIHtcbiAgICAvLyBUcnkgdG8gZmluZCBub2RlcyBpbiBhbiBvcmRlciBzdWNoIHRoYXQgd2UgbGVuZ3RoZW4gdGhlIGxvbmdlc3QgaW5jcmVhc2luZyBzdWJzZXF1ZW5jZVxuICAgIGluaXRfY2xhaW1faW5mbyhub2Rlcyk7XG4gICAgY29uc3QgcmVzdWx0Tm9kZSA9ICgoKSA9PiB7XG4gICAgICAgIC8vIFdlIGZpcnN0IHRyeSB0byBmaW5kIGFuIGVsZW1lbnQgYWZ0ZXIgdGhlIHByZXZpb3VzIG9uZVxuICAgICAgICBmb3IgKGxldCBpID0gbm9kZXMuY2xhaW1faW5mby5sYXN0X2luZGV4OyBpIDwgbm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgICAgIGlmIChwcmVkaWNhdGUobm9kZSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXBsYWNlbWVudCA9IHByb2Nlc3NOb2RlKG5vZGUpO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzW2ldID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZG9udFVwZGF0ZUxhc3RJbmRleCkge1xuICAgICAgICAgICAgICAgICAgICBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIHRyeSB0byBmaW5kIG9uZSBiZWZvcmVcbiAgICAgICAgLy8gV2UgaXRlcmF0ZSBpbiByZXZlcnNlIHNvIHRoYXQgd2UgZG9uJ3QgZ28gdG9vIGZhciBiYWNrXG4gICAgICAgIGZvciAobGV0IGkgPSBub2Rlcy5jbGFpbV9pbmZvLmxhc3RfaW5kZXggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICAgICAgaWYgKHByZWRpY2F0ZShub2RlKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VtZW50ID0gcHJvY2Vzc05vZGUobm9kZSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNbaV0gPSByZXBsYWNlbWVudDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFkb250VXBkYXRlTGFzdEluZGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlcGxhY2VtZW50ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gU2luY2Ugd2Ugc3BsaWNlZCBiZWZvcmUgdGhlIGxhc3RfaW5kZXgsIHdlIGRlY3JlYXNlIGl0XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLmNsYWltX2luZm8ubGFzdF9pbmRleC0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB3ZSBjYW4ndCBmaW5kIGFueSBtYXRjaGluZyBub2RlLCB3ZSBjcmVhdGUgYSBuZXcgb25lXG4gICAgICAgIHJldHVybiBjcmVhdGVOb2RlKCk7XG4gICAgfSkoKTtcbiAgICByZXN1bHROb2RlLmNsYWltX29yZGVyID0gbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkO1xuICAgIG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZCArPSAxO1xuICAgIHJldHVybiByZXN1bHROb2RlO1xufVxuZnVuY3Rpb24gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBjcmVhdGVfZWxlbWVudCkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlTmFtZSA9PT0gbmFtZSwgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgcmVtb3ZlID0gW107XG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBub2RlLmF0dHJpYnV0ZXNbal07XG4gICAgICAgICAgICBpZiAoIWF0dHJpYnV0ZXNbYXR0cmlidXRlLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgcmVtb3ZlLnB1c2goYXR0cmlidXRlLm5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbW92ZS5mb3JFYWNoKHYgPT4gbm9kZS5yZW1vdmVBdHRyaWJ1dGUodikpO1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH0sICgpID0+IGNyZWF0ZV9lbGVtZW50KG5hbWUpKTtcbn1cbmZ1bmN0aW9uIGNsYWltX2VsZW1lbnQobm9kZXMsIG5hbWUsIGF0dHJpYnV0ZXMpIHtcbiAgICByZXR1cm4gY2xhaW1fZWxlbWVudF9iYXNlKG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzLCBlbGVtZW50KTtcbn1cbmZ1bmN0aW9uIGNsYWltX3N2Z19lbGVtZW50KG5vZGVzLCBuYW1lLCBhdHRyaWJ1dGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX2VsZW1lbnRfYmFzZShub2RlcywgbmFtZSwgYXR0cmlidXRlcywgc3ZnX2VsZW1lbnQpO1xufVxuZnVuY3Rpb24gY2xhaW1fdGV4dChub2RlcywgZGF0YSkge1xuICAgIHJldHVybiBjbGFpbV9ub2RlKG5vZGVzLCAobm9kZSkgPT4gbm9kZS5ub2RlVHlwZSA9PT0gMywgKG5vZGUpID0+IHtcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9ICcnICsgZGF0YTtcbiAgICAgICAgaWYgKG5vZGUuZGF0YS5zdGFydHNXaXRoKGRhdGFTdHIpKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5kYXRhLmxlbmd0aCAhPT0gZGF0YVN0ci5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZS5zcGxpdFRleHQoZGF0YVN0ci5sZW5ndGgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbm9kZS5kYXRhID0gZGF0YVN0cjtcbiAgICAgICAgfVxuICAgIH0sICgpID0+IHRleHQoZGF0YSksIHRydWUgLy8gVGV4dCBub2RlcyBzaG91bGQgbm90IHVwZGF0ZSBsYXN0IGluZGV4IHNpbmNlIGl0IGlzIGxpa2VseSBub3Qgd29ydGggaXQgdG8gZWxpbWluYXRlIGFuIGluY3JlYXNpbmcgc3Vic2VxdWVuY2Ugb2YgYWN0dWFsIGVsZW1lbnRzXG4gICAgKTtcbn1cbmZ1bmN0aW9uIGNsYWltX3NwYWNlKG5vZGVzKSB7XG4gICAgcmV0dXJuIGNsYWltX3RleHQobm9kZXMsICcgJyk7XG59XG5mdW5jdGlvbiBjbGFpbV9jb21tZW50KG5vZGVzLCBkYXRhKSB7XG4gICAgcmV0dXJuIGNsYWltX25vZGUobm9kZXMsIChub2RlKSA9PiBub2RlLm5vZGVUeXBlID09PSA4LCAobm9kZSkgPT4ge1xuICAgICAgICBub2RlLmRhdGEgPSAnJyArIGRhdGE7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfSwgKCkgPT4gY29tbWVudChkYXRhKSwgdHJ1ZSk7XG59XG5mdW5jdGlvbiBmaW5kX2NvbW1lbnQobm9kZXMsIHRleHQsIHN0YXJ0KSB7XG4gICAgZm9yIChsZXQgaSA9IHN0YXJ0OyBpIDwgbm9kZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBpZiAobm9kZS5ub2RlVHlwZSA9PT0gOCAvKiBjb21tZW50IG5vZGUgKi8gJiYgbm9kZS50ZXh0Q29udGVudC50cmltKCkgPT09IHRleHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBub2Rlcy5sZW5ndGg7XG59XG5mdW5jdGlvbiBjbGFpbV9odG1sX3RhZyhub2RlcywgaXNfc3ZnKSB7XG4gICAgLy8gZmluZCBodG1sIG9wZW5pbmcgdGFnXG4gICAgY29uc3Qgc3RhcnRfaW5kZXggPSBmaW5kX2NvbW1lbnQobm9kZXMsICdIVE1MX1RBR19TVEFSVCcsIDApO1xuICAgIGNvbnN0IGVuZF9pbmRleCA9IGZpbmRfY29tbWVudChub2RlcywgJ0hUTUxfVEFHX0VORCcsIHN0YXJ0X2luZGV4KTtcbiAgICBpZiAoc3RhcnRfaW5kZXggPT09IGVuZF9pbmRleCkge1xuICAgICAgICByZXR1cm4gbmV3IEh0bWxUYWdIeWRyYXRpb24odW5kZWZpbmVkLCBpc19zdmcpO1xuICAgIH1cbiAgICBpbml0X2NsYWltX2luZm8obm9kZXMpO1xuICAgIGNvbnN0IGh0bWxfdGFnX25vZGVzID0gbm9kZXMuc3BsaWNlKHN0YXJ0X2luZGV4LCBlbmRfaW5kZXggLSBzdGFydF9pbmRleCArIDEpO1xuICAgIGRldGFjaChodG1sX3RhZ19ub2Rlc1swXSk7XG4gICAgZGV0YWNoKGh0bWxfdGFnX25vZGVzW2h0bWxfdGFnX25vZGVzLmxlbmd0aCAtIDFdKTtcbiAgICBjb25zdCBjbGFpbWVkX25vZGVzID0gaHRtbF90YWdfbm9kZXMuc2xpY2UoMSwgaHRtbF90YWdfbm9kZXMubGVuZ3RoIC0gMSk7XG4gICAgZm9yIChjb25zdCBuIG9mIGNsYWltZWRfbm9kZXMpIHtcbiAgICAgICAgbi5jbGFpbV9vcmRlciA9IG5vZGVzLmNsYWltX2luZm8udG90YWxfY2xhaW1lZDtcbiAgICAgICAgbm9kZXMuY2xhaW1faW5mby50b3RhbF9jbGFpbWVkICs9IDE7XG4gICAgfVxuICAgIHJldHVybiBuZXcgSHRtbFRhZ0h5ZHJhdGlvbihjbGFpbWVkX25vZGVzLCBpc19zdmcpO1xufVxuZnVuY3Rpb24gc2V0X2RhdGEodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQuZGF0YSA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHRleHQuZGF0YSA9IGRhdGE7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQud2hvbGVUZXh0ID09PSBkYXRhKVxuICAgICAgICByZXR1cm47XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhLCBhdHRyX3ZhbHVlKSB7XG4gICAgaWYgKH5jb250ZW50ZWRpdGFibGVfdHJ1dGh5X3ZhbHVlcy5pbmRleE9mKGF0dHJfdmFsdWUpKSB7XG4gICAgICAgIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZSh0ZXh0LCBkYXRhKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHNldF9kYXRhKHRleHQsIGRhdGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9pbnB1dF92YWx1ZShpbnB1dCwgdmFsdWUpIHtcbiAgICBpbnB1dC52YWx1ZSA9IHZhbHVlID09IG51bGwgPyAnJyA6IHZhbHVlO1xufVxuZnVuY3Rpb24gc2V0X2lucHV0X3R5cGUoaW5wdXQsIHR5cGUpIHtcbiAgICB0cnkge1xuICAgICAgICBpbnB1dC50eXBlID0gdHlwZTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldF9zdHlsZShub2RlLCBrZXksIHZhbHVlLCBpbXBvcnRhbnQpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICBub2RlLnN0eWxlLnJlbW92ZVByb3BlcnR5KGtleSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBub2RlLnN0eWxlLnNldFByb3BlcnR5KGtleSwgdmFsdWUsIGltcG9ydGFudCA/ICdpbXBvcnRhbnQnIDogJycpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNlbGVjdF9vcHRpb24oc2VsZWN0LCB2YWx1ZSwgbW91bnRpbmcpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNlbGVjdC5vcHRpb25zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbiA9IHNlbGVjdC5vcHRpb25zW2ldO1xuICAgICAgICBpZiAob3B0aW9uLl9fdmFsdWUgPT09IHZhbHVlKSB7XG4gICAgICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghbW91bnRpbmcgfHwgdmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBzZWxlY3Quc2VsZWN0ZWRJbmRleCA9IC0xOyAvLyBubyBvcHRpb24gc2hvdWxkIGJlIHNlbGVjdGVkXG4gICAgfVxufVxuZnVuY3Rpb24gc2VsZWN0X29wdGlvbnMoc2VsZWN0LCB2YWx1ZSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2VsZWN0Lm9wdGlvbnMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgY29uc3Qgb3B0aW9uID0gc2VsZWN0Lm9wdGlvbnNbaV07XG4gICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IH52YWx1ZS5pbmRleE9mKG9wdGlvbi5fX3ZhbHVlKTtcbiAgICB9XG59XG5mdW5jdGlvbiBzZWxlY3RfdmFsdWUoc2VsZWN0KSB7XG4gICAgY29uc3Qgc2VsZWN0ZWRfb3B0aW9uID0gc2VsZWN0LnF1ZXJ5U2VsZWN0b3IoJzpjaGVja2VkJyk7XG4gICAgcmV0dXJuIHNlbGVjdGVkX29wdGlvbiAmJiBzZWxlY3RlZF9vcHRpb24uX192YWx1ZTtcbn1cbmZ1bmN0aW9uIHNlbGVjdF9tdWx0aXBsZV92YWx1ZShzZWxlY3QpIHtcbiAgICByZXR1cm4gW10ubWFwLmNhbGwoc2VsZWN0LnF1ZXJ5U2VsZWN0b3JBbGwoJzpjaGVja2VkJyksIG9wdGlvbiA9PiBvcHRpb24uX192YWx1ZSk7XG59XG4vLyB1bmZvcnR1bmF0ZWx5IHRoaXMgY2FuJ3QgYmUgYSBjb25zdGFudCBhcyB0aGF0IHdvdWxkbid0IGJlIHRyZWUtc2hha2VhYmxlXG4vLyBzbyB3ZSBjYWNoZSB0aGUgcmVzdWx0IGluc3RlYWRcbmxldCBjcm9zc29yaWdpbjtcbmZ1bmN0aW9uIGlzX2Nyb3Nzb3JpZ2luKCkge1xuICAgIGlmIChjcm9zc29yaWdpbiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNyb3Nzb3JpZ2luID0gZmFsc2U7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgd2luZG93LnBhcmVudCkge1xuICAgICAgICAgICAgICAgIHZvaWQgd2luZG93LnBhcmVudC5kb2N1bWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNyb3Nzb3JpZ2luID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gY3Jvc3NvcmlnaW47XG59XG5mdW5jdGlvbiBhZGRfaWZyYW1lX3Jlc2l6ZV9saXN0ZW5lcihub2RlLCBmbikge1xuICAgIGNvbnN0IGNvbXB1dGVkX3N0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBpZiAoY29tcHV0ZWRfc3R5bGUucG9zaXRpb24gPT09ICdzdGF0aWMnKSB7XG4gICAgICAgIG5vZGUuc3R5bGUucG9zaXRpb24gPSAncmVsYXRpdmUnO1xuICAgIH1cbiAgICBjb25zdCBpZnJhbWUgPSBlbGVtZW50KCdpZnJhbWUnKTtcbiAgICBpZnJhbWUuc2V0QXR0cmlidXRlKCdzdHlsZScsICdkaXNwbGF5OiBibG9jazsgcG9zaXRpb246IGFic29sdXRlOyB0b3A6IDA7IGxlZnQ6IDA7IHdpZHRoOiAxMDAlOyBoZWlnaHQ6IDEwMCU7ICcgK1xuICAgICAgICAnb3ZlcmZsb3c6IGhpZGRlbjsgYm9yZGVyOiAwOyBvcGFjaXR5OiAwOyBwb2ludGVyLWV2ZW50czogbm9uZTsgei1pbmRleDogLTE7Jyk7XG4gICAgaWZyYW1lLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAndHJ1ZScpO1xuICAgIGlmcmFtZS50YWJJbmRleCA9IC0xO1xuICAgIGNvbnN0IGNyb3Nzb3JpZ2luID0gaXNfY3Jvc3NvcmlnaW4oKTtcbiAgICBsZXQgdW5zdWJzY3JpYmU7XG4gICAgaWYgKGNyb3Nzb3JpZ2luKSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSBcImRhdGE6dGV4dC9odG1sLDxzY3JpcHQ+b25yZXNpemU9ZnVuY3Rpb24oKXtwYXJlbnQucG9zdE1lc3NhZ2UoMCwnKicpfTwvc2NyaXB0PlwiO1xuICAgICAgICB1bnN1YnNjcmliZSA9IGxpc3Rlbih3aW5kb3csICdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAoZXZlbnQuc291cmNlID09PSBpZnJhbWUuY29udGVudFdpbmRvdylcbiAgICAgICAgICAgICAgICBmbigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmcmFtZS5zcmMgPSAnYWJvdXQ6YmxhbmsnO1xuICAgICAgICBpZnJhbWUub25sb2FkID0gKCkgPT4ge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUgPSBsaXN0ZW4oaWZyYW1lLmNvbnRlbnRXaW5kb3csICdyZXNpemUnLCBmbik7XG4gICAgICAgICAgICAvLyBtYWtlIHN1cmUgYW4gaW5pdGlhbCByZXNpemUgZXZlbnQgaXMgZmlyZWQgX2FmdGVyXyB0aGUgaWZyYW1lIGlzIGxvYWRlZCAod2hpY2ggaXMgYXN5bmNocm9ub3VzKVxuICAgICAgICAgICAgLy8gc2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9zdmVsdGVqcy9zdmVsdGUvaXNzdWVzLzQyMzNcbiAgICAgICAgICAgIGZuKCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIGFwcGVuZChub2RlLCBpZnJhbWUpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChjcm9zc29yaWdpbikge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh1bnN1YnNjcmliZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgdW5zdWJzY3JpYmUoKTtcbiAgICAgICAgfVxuICAgICAgICBkZXRhY2goaWZyYW1lKTtcbiAgICB9O1xufVxuY29uc3QgcmVzaXplX29ic2VydmVyX2NvbnRlbnRfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7IGJveDogJ2NvbnRlbnQtYm94JyB9KTtcbmNvbnN0IHJlc2l6ZV9vYnNlcnZlcl9ib3JkZXJfYm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBSZXNpemVPYnNlcnZlclNpbmdsZXRvbih7IGJveDogJ2JvcmRlci1ib3gnIH0pO1xuY29uc3QgcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmVzaXplT2JzZXJ2ZXJTaW5nbGV0b24oeyBib3g6ICdkZXZpY2UtcGl4ZWwtY29udGVudC1ib3gnIH0pO1xuZnVuY3Rpb24gdG9nZ2xlX2NsYXNzKGVsZW1lbnQsIG5hbWUsIHRvZ2dsZSkge1xuICAgIGVsZW1lbnQuY2xhc3NMaXN0W3RvZ2dsZSA/ICdhZGQnIDogJ3JlbW92ZSddKG5hbWUpO1xufVxuZnVuY3Rpb24gY3VzdG9tX2V2ZW50KHR5cGUsIGRldGFpbCwgeyBidWJibGVzID0gZmFsc2UsIGNhbmNlbGFibGUgPSBmYWxzZSB9ID0ge30pIHtcbiAgICBjb25zdCBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgZS5pbml0Q3VzdG9tRXZlbnQodHlwZSwgYnViYmxlcywgY2FuY2VsYWJsZSwgZGV0YWlsKTtcbiAgICByZXR1cm4gZTtcbn1cbmZ1bmN0aW9uIHF1ZXJ5X3NlbGVjdG9yX2FsbChzZWxlY3RvciwgcGFyZW50ID0gZG9jdW1lbnQuYm9keSkge1xuICAgIHJldHVybiBBcnJheS5mcm9tKHBhcmVudC5xdWVyeVNlbGVjdG9yQWxsKHNlbGVjdG9yKSk7XG59XG5mdW5jdGlvbiBoZWFkX3NlbGVjdG9yKG5vZGVJZCwgaGVhZCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBzdGFydGVkID0gMDtcbiAgICBmb3IgKGNvbnN0IG5vZGUgb2YgaGVhZC5jaGlsZE5vZGVzKSB7XG4gICAgICAgIGlmIChub2RlLm5vZGVUeXBlID09PSA4IC8qIGNvbW1lbnQgbm9kZSAqLykge1xuICAgICAgICAgICAgY29uc3QgY29tbWVudCA9IG5vZGUudGV4dENvbnRlbnQudHJpbSgpO1xuICAgICAgICAgICAgaWYgKGNvbW1lbnQgPT09IGBIRUFEXyR7bm9kZUlkfV9FTkRgKSB7XG4gICAgICAgICAgICAgICAgc3RhcnRlZCAtPSAxO1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tbWVudCA9PT0gYEhFQURfJHtub2RlSWR9X1NUQVJUYCkge1xuICAgICAgICAgICAgICAgIHN0YXJ0ZWQgKz0gMTtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGFydGVkID4gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmNsYXNzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNfc3ZnID0gaXNfc3ZnO1xuICAgICAgICB0aGlzLmUgPSB0aGlzLm4gPSBudWxsO1xuICAgIH1cbiAgICBjKGh0bWwpIHtcbiAgICAgICAgdGhpcy5oKGh0bWwpO1xuICAgIH1cbiAgICBtKGh0bWwsIHRhcmdldCwgYW5jaG9yID0gbnVsbCkge1xuICAgICAgICBpZiAoIXRoaXMuZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuaXNfc3ZnKVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IHN2Z19lbGVtZW50KHRhcmdldC5ub2RlTmFtZSk7XG4gICAgICAgICAgICAvKiogIzczNjQgIHRhcmdldCBmb3IgPHRlbXBsYXRlPiBtYXkgYmUgcHJvdmlkZWQgYXMgI2RvY3VtZW50LWZyYWdtZW50KDExKSAqL1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIHRoaXMuZSA9IGVsZW1lbnQoKHRhcmdldC5ub2RlVHlwZSA9PT0gMTEgPyAnVEVNUExBVEUnIDogdGFyZ2V0Lm5vZGVOYW1lKSk7XG4gICAgICAgICAgICB0aGlzLnQgPSB0YXJnZXQudGFnTmFtZSAhPT0gJ1RFTVBMQVRFJyA/IHRhcmdldCA6IHRhcmdldC5jb250ZW50O1xuICAgICAgICAgICAgdGhpcy5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuaShhbmNob3IpO1xuICAgIH1cbiAgICBoKGh0bWwpIHtcbiAgICAgICAgdGhpcy5lLmlubmVySFRNTCA9IGh0bWw7XG4gICAgICAgIHRoaXMubiA9IEFycmF5LmZyb20odGhpcy5lLm5vZGVOYW1lID09PSAnVEVNUExBVEUnID8gdGhpcy5lLmNvbnRlbnQuY2hpbGROb2RlcyA6IHRoaXMuZS5jaGlsZE5vZGVzKTtcbiAgICB9XG4gICAgaShhbmNob3IpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLm4ubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluc2VydCh0aGlzLnQsIHRoaXMubltpXSwgYW5jaG9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBwKGh0bWwpIHtcbiAgICAgICAgdGhpcy5kKCk7XG4gICAgICAgIHRoaXMuaChodG1sKTtcbiAgICAgICAgdGhpcy5pKHRoaXMuYSk7XG4gICAgfVxuICAgIGQoKSB7XG4gICAgICAgIHRoaXMubi5mb3JFYWNoKGRldGFjaCk7XG4gICAgfVxufVxuY2xhc3MgSHRtbFRhZ0h5ZHJhdGlvbiBleHRlbmRzIEh0bWxUYWcge1xuICAgIGNvbnN0cnVjdG9yKGNsYWltZWRfbm9kZXMsIGlzX3N2ZyA9IGZhbHNlKSB7XG4gICAgICAgIHN1cGVyKGlzX3N2Zyk7XG4gICAgICAgIHRoaXMuZSA9IHRoaXMubiA9IG51bGw7XG4gICAgICAgIHRoaXMubCA9IGNsYWltZWRfbm9kZXM7XG4gICAgfVxuICAgIGMoaHRtbCkge1xuICAgICAgICBpZiAodGhpcy5sKSB7XG4gICAgICAgICAgICB0aGlzLm4gPSB0aGlzLmw7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzdXBlci5jKGh0bWwpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGkoYW5jaG9yKSB7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5uLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBpbnNlcnRfaHlkcmF0aW9uKHRoaXMudCwgdGhpcy5uW2ldLCBhbmNob3IpO1xuICAgICAgICB9XG4gICAgfVxufVxuZnVuY3Rpb24gYXR0cmlidXRlX3RvX29iamVjdChhdHRyaWJ1dGVzKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlcykge1xuICAgICAgICByZXN1bHRbYXR0cmlidXRlLm5hbWVdID0gYXR0cmlidXRlLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0X2N1c3RvbV9lbGVtZW50c19zbG90cyhlbGVtZW50KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZWxlbWVudC5jaGlsZE5vZGVzLmZvckVhY2goKG5vZGUpID0+IHtcbiAgICAgICAgcmVzdWx0W25vZGUuc2xvdCB8fCAnZGVmYXVsdCddID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQoY29tcG9uZW50LCBwcm9wcykge1xuICAgIHJldHVybiBuZXcgY29tcG9uZW50KHByb3BzKTtcbn1cblxuLy8gd2UgbmVlZCB0byBzdG9yZSB0aGUgaW5mb3JtYXRpb24gZm9yIG11bHRpcGxlIGRvY3VtZW50cyBiZWNhdXNlIGEgU3ZlbHRlIGFwcGxpY2F0aW9uIGNvdWxkIGFsc28gY29udGFpbiBpZnJhbWVzXG4vLyBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL2lzc3Vlcy8zNjI0XG5jb25zdCBtYW5hZ2VkX3N0eWxlcyA9IG5ldyBNYXAoKTtcbmxldCBhY3RpdmUgPSAwO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Rhcmtza3lhcHAvc3RyaW5nLWhhc2gvYmxvYi9tYXN0ZXIvaW5kZXguanNcbmZ1bmN0aW9uIGhhc2goc3RyKSB7XG4gICAgbGV0IGhhc2ggPSA1MzgxO1xuICAgIGxldCBpID0gc3RyLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBoYXNoID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgXiBzdHIuY2hhckNvZGVBdChpKTtcbiAgICByZXR1cm4gaGFzaCA+Pj4gMDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9zdHlsZV9pbmZvcm1hdGlvbihkb2MsIG5vZGUpIHtcbiAgICBjb25zdCBpbmZvID0geyBzdHlsZXNoZWV0OiBhcHBlbmRfZW1wdHlfc3R5bGVzaGVldChub2RlKSwgcnVsZXM6IHt9IH07XG4gICAgbWFuYWdlZF9zdHlsZXMuc2V0KGRvYywgaW5mbyk7XG4gICAgcmV0dXJuIGluZm87XG59XG5mdW5jdGlvbiBjcmVhdGVfcnVsZShub2RlLCBhLCBiLCBkdXJhdGlvbiwgZGVsYXksIGVhc2UsIGZuLCB1aWQgPSAwKSB7XG4gICAgY29uc3Qgc3RlcCA9IDE2LjY2NiAvIGR1cmF0aW9uO1xuICAgIGxldCBrZXlmcmFtZXMgPSAne1xcbic7XG4gICAgZm9yIChsZXQgcCA9IDA7IHAgPD0gMTsgcCArPSBzdGVwKSB7XG4gICAgICAgIGNvbnN0IHQgPSBhICsgKGIgLSBhKSAqIGVhc2UocCk7XG4gICAgICAgIGtleWZyYW1lcyArPSBwICogMTAwICsgYCV7JHtmbih0LCAxIC0gdCl9fVxcbmA7XG4gICAgfVxuICAgIGNvbnN0IHJ1bGUgPSBrZXlmcmFtZXMgKyBgMTAwJSB7JHtmbihiLCAxIC0gYil9fVxcbn1gO1xuICAgIGNvbnN0IG5hbWUgPSBgX19zdmVsdGVfJHtoYXNoKHJ1bGUpfV8ke3VpZH1gO1xuICAgIGNvbnN0IGRvYyA9IGdldF9yb290X2Zvcl9zdHlsZShub2RlKTtcbiAgICBjb25zdCB7IHN0eWxlc2hlZXQsIHJ1bGVzIH0gPSBtYW5hZ2VkX3N0eWxlcy5nZXQoZG9jKSB8fCBjcmVhdGVfc3R5bGVfaW5mb3JtYXRpb24oZG9jLCBub2RlKTtcbiAgICBpZiAoIXJ1bGVzW25hbWVdKSB7XG4gICAgICAgIHJ1bGVzW25hbWVdID0gdHJ1ZTtcbiAgICAgICAgc3R5bGVzaGVldC5pbnNlcnRSdWxlKGBAa2V5ZnJhbWVzICR7bmFtZX0gJHtydWxlfWAsIHN0eWxlc2hlZXQuY3NzUnVsZXMubGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgYW5pbWF0aW9uID0gbm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJyc7XG4gICAgbm9kZS5zdHlsZS5hbmltYXRpb24gPSBgJHthbmltYXRpb24gPyBgJHthbmltYXRpb259LCBgIDogJyd9JHtuYW1lfSAke2R1cmF0aW9ufW1zIGxpbmVhciAke2RlbGF5fW1zIDEgYm90aGA7XG4gICAgYWN0aXZlICs9IDE7XG4gICAgcmV0dXJuIG5hbWU7XG59XG5mdW5jdGlvbiBkZWxldGVfcnVsZShub2RlLCBuYW1lKSB7XG4gICAgY29uc3QgcHJldmlvdXMgPSAobm9kZS5zdHlsZS5hbmltYXRpb24gfHwgJycpLnNwbGl0KCcsICcpO1xuICAgIGNvbnN0IG5leHQgPSBwcmV2aW91cy5maWx0ZXIobmFtZVxuICAgICAgICA/IGFuaW0gPT4gYW5pbS5pbmRleE9mKG5hbWUpIDwgMCAvLyByZW1vdmUgc3BlY2lmaWMgYW5pbWF0aW9uXG4gICAgICAgIDogYW5pbSA9PiBhbmltLmluZGV4T2YoJ19fc3ZlbHRlJykgPT09IC0xIC8vIHJlbW92ZSBhbGwgU3ZlbHRlIGFuaW1hdGlvbnNcbiAgICApO1xuICAgIGNvbnN0IGRlbGV0ZWQgPSBwcmV2aW91cy5sZW5ndGggLSBuZXh0Lmxlbmd0aDtcbiAgICBpZiAoZGVsZXRlZCkge1xuICAgICAgICBub2RlLnN0eWxlLmFuaW1hdGlvbiA9IG5leHQuam9pbignLCAnKTtcbiAgICAgICAgYWN0aXZlIC09IGRlbGV0ZWQ7XG4gICAgICAgIGlmICghYWN0aXZlKVxuICAgICAgICAgICAgY2xlYXJfcnVsZXMoKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjbGVhcl9ydWxlcygpIHtcbiAgICByYWYoKCkgPT4ge1xuICAgICAgICBpZiAoYWN0aXZlKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBtYW5hZ2VkX3N0eWxlcy5mb3JFYWNoKGluZm8gPT4ge1xuICAgICAgICAgICAgY29uc3QgeyBvd25lck5vZGUgfSA9IGluZm8uc3R5bGVzaGVldDtcbiAgICAgICAgICAgIC8vIHRoZXJlIGlzIG5vIG93bmVyTm9kZSBpZiBpdCBydW5zIG9uIGpzZG9tLlxuICAgICAgICAgICAgaWYgKG93bmVyTm9kZSlcbiAgICAgICAgICAgICAgICBkZXRhY2gob3duZXJOb2RlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIG1hbmFnZWRfc3R5bGVzLmNsZWFyKCk7XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZV9hbmltYXRpb24obm9kZSwgZnJvbSwgZm4sIHBhcmFtcykge1xuICAgIGlmICghZnJvbSlcbiAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgY29uc3QgdG8gPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIGlmIChmcm9tLmxlZnQgPT09IHRvLmxlZnQgJiYgZnJvbS5yaWdodCA9PT0gdG8ucmlnaHQgJiYgZnJvbS50b3AgPT09IHRvLnRvcCAmJiBmcm9tLmJvdHRvbSA9PT0gdG8uYm90dG9tKVxuICAgICAgICByZXR1cm4gbm9vcDtcbiAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSAzMDAsIGVhc2luZyA9IGlkZW50aXR5LCBcbiAgICAvLyBAdHMtaWdub3JlIHRvZG86IHNob3VsZCB0aGlzIGJlIHNlcGFyYXRlZCBmcm9tIGRlc3RydWN0dXJpbmc/IE9yIHN0YXJ0L2VuZCBhZGRlZCB0byBwdWJsaWMgYXBpIGFuZCBkb2N1bWVudGF0aW9uP1xuICAgIHN0YXJ0OiBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheSwgXG4gICAgLy8gQHRzLWlnbm9yZSB0b2RvOlxuICAgIGVuZCA9IHN0YXJ0X3RpbWUgKyBkdXJhdGlvbiwgdGljayA9IG5vb3AsIGNzcyB9ID0gZm4obm9kZSwgeyBmcm9tLCB0byB9LCBwYXJhbXMpO1xuICAgIGxldCBydW5uaW5nID0gdHJ1ZTtcbiAgICBsZXQgc3RhcnRlZCA9IGZhbHNlO1xuICAgIGxldCBuYW1lO1xuICAgIGZ1bmN0aW9uIHN0YXJ0KCkge1xuICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICBuYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgMCwgMSwgZHVyYXRpb24sIGRlbGF5LCBlYXNpbmcsIGNzcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFkZWxheSkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gc3RvcCgpIHtcbiAgICAgICAgaWYgKGNzcylcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIG5hbWUpO1xuICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgfVxuICAgIGxvb3Aobm93ID0+IHtcbiAgICAgICAgaWYgKCFzdGFydGVkICYmIG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICBzdGFydGVkID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhcnRlZCAmJiBub3cgPj0gZW5kKSB7XG4gICAgICAgICAgICB0aWNrKDEsIDApO1xuICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghcnVubmluZykge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICBjb25zdCBwID0gbm93IC0gc3RhcnRfdGltZTtcbiAgICAgICAgICAgIGNvbnN0IHQgPSAwICsgMSAqIGVhc2luZyhwIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSk7XG4gICAgc3RhcnQoKTtcbiAgICB0aWNrKDAsIDEpO1xuICAgIHJldHVybiBzdG9wO1xufVxuZnVuY3Rpb24gZml4X3Bvc2l0aW9uKG5vZGUpIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgaWYgKHN0eWxlLnBvc2l0aW9uICE9PSAnYWJzb2x1dGUnICYmIHN0eWxlLnBvc2l0aW9uICE9PSAnZml4ZWQnKSB7XG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gc3R5bGU7XG4gICAgICAgIGNvbnN0IGEgPSBub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgbm9kZS5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgICBub2RlLnN0eWxlLmhlaWdodCA9IGhlaWdodDtcbiAgICAgICAgYWRkX3RyYW5zZm9ybShub2RlLCBhKTtcbiAgICB9XG59XG5mdW5jdGlvbiBhZGRfdHJhbnNmb3JtKG5vZGUsIGEpIHtcbiAgICBjb25zdCBiID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICBpZiAoYS5sZWZ0ICE9PSBiLmxlZnQgfHwgYS50b3AgIT09IGIudG9wKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICAgICAgY29uc3QgdHJhbnNmb3JtID0gc3R5bGUudHJhbnNmb3JtID09PSAnbm9uZScgPyAnJyA6IHN0eWxlLnRyYW5zZm9ybTtcbiAgICAgICAgbm9kZS5zdHlsZS50cmFuc2Zvcm0gPSBgJHt0cmFuc2Zvcm19IHRyYW5zbGF0ZSgke2EubGVmdCAtIGIubGVmdH1weCwgJHthLnRvcCAtIGIudG9wfXB4KWA7XG4gICAgfVxufVxuXG5sZXQgY3VycmVudF9jb21wb25lbnQ7XG5mdW5jdGlvbiBzZXRfY3VycmVudF9jb21wb25lbnQoY29tcG9uZW50KSB7XG4gICAgY3VycmVudF9jb21wb25lbnQgPSBjb21wb25lbnQ7XG59XG5mdW5jdGlvbiBnZXRfY3VycmVudF9jb21wb25lbnQoKSB7XG4gICAgaWYgKCFjdXJyZW50X2NvbXBvbmVudClcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGdW5jdGlvbiBjYWxsZWQgb3V0c2lkZSBjb21wb25lbnQgaW5pdGlhbGl6YXRpb24nKTtcbiAgICByZXR1cm4gY3VycmVudF9jb21wb25lbnQ7XG59XG4vKipcbiAqIFNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBpbW1lZGlhdGVseSBiZWZvcmUgdGhlIGNvbXBvbmVudCBpcyB1cGRhdGVkIGFmdGVyIGFueSBzdGF0ZSBjaGFuZ2UuXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIHJ1bnMgd2lsbCBiZSBiZWZvcmUgdGhlIGluaXRpYWwgYG9uTW91bnRgXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWJlZm9yZXVwZGF0ZVxuICovXG5mdW5jdGlvbiBiZWZvcmVVcGRhdGUoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5iZWZvcmVfdXBkYXRlLnB1c2goZm4pO1xufVxuLyoqXG4gKiBUaGUgYG9uTW91bnRgIGZ1bmN0aW9uIHNjaGVkdWxlcyBhIGNhbGxiYWNrIHRvIHJ1biBhcyBzb29uIGFzIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gbW91bnRlZCB0byB0aGUgRE9NLlxuICogSXQgbXVzdCBiZSBjYWxsZWQgZHVyaW5nIHRoZSBjb21wb25lbnQncyBpbml0aWFsaXNhdGlvbiAoYnV0IGRvZXNuJ3QgbmVlZCB0byBsaXZlICppbnNpZGUqIHRoZSBjb21wb25lbnQ7XG4gKiBpdCBjYW4gYmUgY2FsbGVkIGZyb20gYW4gZXh0ZXJuYWwgbW9kdWxlKS5cbiAqXG4gKiBgb25Nb3VudGAgZG9lcyBub3QgcnVuIGluc2lkZSBhIFtzZXJ2ZXItc2lkZSBjb21wb25lbnRdKC9kb2NzI3J1bi10aW1lLXNlcnZlci1zaWRlLWNvbXBvbmVudC1hcGkpLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1vbm1vdW50XG4gKi9cbmZ1bmN0aW9uIG9uTW91bnQoZm4pIHtcbiAgICBnZXRfY3VycmVudF9jb21wb25lbnQoKS4kJC5vbl9tb3VudC5wdXNoKGZuKTtcbn1cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBjb21wb25lbnQgaGFzIGJlZW4gdXBkYXRlZC5cbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgcnVucyB3aWxsIGJlIGFmdGVyIHRoZSBpbml0aWFsIGBvbk1vdW50YFxuICovXG5mdW5jdGlvbiBhZnRlclVwZGF0ZShmbikge1xuICAgIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmFmdGVyX3VwZGF0ZS5wdXNoKGZuKTtcbn1cbi8qKlxuICogU2NoZWR1bGVzIGEgY2FsbGJhY2sgdG8gcnVuIGltbWVkaWF0ZWx5IGJlZm9yZSB0aGUgY29tcG9uZW50IGlzIHVubW91bnRlZC5cbiAqXG4gKiBPdXQgb2YgYG9uTW91bnRgLCBgYmVmb3JlVXBkYXRlYCwgYGFmdGVyVXBkYXRlYCBhbmQgYG9uRGVzdHJveWAsIHRoaXMgaXMgdGhlXG4gKiBvbmx5IG9uZSB0aGF0IHJ1bnMgaW5zaWRlIGEgc2VydmVyLXNpZGUgY29tcG9uZW50LlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1vbmRlc3Ryb3lcbiAqL1xuZnVuY3Rpb24gb25EZXN0cm95KGZuKSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQub25fZGVzdHJveS5wdXNoKGZuKTtcbn1cbi8qKlxuICogQ3JlYXRlcyBhbiBldmVudCBkaXNwYXRjaGVyIHRoYXQgY2FuIGJlIHVzZWQgdG8gZGlzcGF0Y2ggW2NvbXBvbmVudCBldmVudHNdKC9kb2NzI3RlbXBsYXRlLXN5bnRheC1jb21wb25lbnQtZGlyZWN0aXZlcy1vbi1ldmVudG5hbWUpLlxuICogRXZlbnQgZGlzcGF0Y2hlcnMgYXJlIGZ1bmN0aW9ucyB0aGF0IGNhbiB0YWtlIHR3byBhcmd1bWVudHM6IGBuYW1lYCBhbmQgYGRldGFpbGAuXG4gKlxuICogQ29tcG9uZW50IGV2ZW50cyBjcmVhdGVkIHdpdGggYGNyZWF0ZUV2ZW50RGlzcGF0Y2hlcmAgY3JlYXRlIGFcbiAqIFtDdXN0b21FdmVudF0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0N1c3RvbUV2ZW50KS5cbiAqIFRoZXNlIGV2ZW50cyBkbyBub3QgW2J1YmJsZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9MZWFybi9KYXZhU2NyaXB0L0J1aWxkaW5nX2Jsb2Nrcy9FdmVudHMjRXZlbnRfYnViYmxpbmdfYW5kX2NhcHR1cmUpLlxuICogVGhlIGBkZXRhaWxgIGFyZ3VtZW50IGNvcnJlc3BvbmRzIHRvIHRoZSBbQ3VzdG9tRXZlbnQuZGV0YWlsXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvQ3VzdG9tRXZlbnQvZGV0YWlsKVxuICogcHJvcGVydHkgYW5kIGNhbiBjb250YWluIGFueSB0eXBlIG9mIGRhdGEuXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWNyZWF0ZWV2ZW50ZGlzcGF0Y2hlclxuICovXG5mdW5jdGlvbiBjcmVhdGVFdmVudERpc3BhdGNoZXIoKSB7XG4gICAgY29uc3QgY29tcG9uZW50ID0gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCk7XG4gICAgcmV0dXJuICh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSA9IGZhbHNlIH0gPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBjYWxsYmFja3MgPSBjb21wb25lbnQuJCQuY2FsbGJhY2tzW3R5cGVdO1xuICAgICAgICBpZiAoY2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGFyZSB0aGVyZSBzaXR1YXRpb25zIHdoZXJlIGV2ZW50cyBjb3VsZCBiZSBkaXNwYXRjaGVkXG4gICAgICAgICAgICAvLyBpbiBhIHNlcnZlciAobm9uLURPTSkgZW52aXJvbm1lbnQ/XG4gICAgICAgICAgICBjb25zdCBldmVudCA9IGN1c3RvbV9ldmVudCh0eXBlLCBkZXRhaWwsIHsgY2FuY2VsYWJsZSB9KTtcbiAgICAgICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4ge1xuICAgICAgICAgICAgICAgIGZuLmNhbGwoY29tcG9uZW50LCBldmVudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiAhZXZlbnQuZGVmYXVsdFByZXZlbnRlZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xufVxuLyoqXG4gKiBBc3NvY2lhdGVzIGFuIGFyYml0cmFyeSBgY29udGV4dGAgb2JqZWN0IHdpdGggdGhlIGN1cnJlbnQgY29tcG9uZW50IGFuZCB0aGUgc3BlY2lmaWVkIGBrZXlgXG4gKiBhbmQgcmV0dXJucyB0aGF0IG9iamVjdC4gVGhlIGNvbnRleHQgaXMgdGhlbiBhdmFpbGFibGUgdG8gY2hpbGRyZW4gb2YgdGhlIGNvbXBvbmVudFxuICogKGluY2x1ZGluZyBzbG90dGVkIGNvbnRlbnQpIHdpdGggYGdldENvbnRleHRgLlxuICpcbiAqIExpa2UgbGlmZWN5Y2xlIGZ1bmN0aW9ucywgdGhpcyBtdXN0IGJlIGNhbGxlZCBkdXJpbmcgY29tcG9uZW50IGluaXRpYWxpc2F0aW9uLlxuICpcbiAqIGh0dHBzOi8vc3ZlbHRlLmRldi9kb2NzI3J1bi10aW1lLXN2ZWx0ZS1zZXRjb250ZXh0XG4gKi9cbmZ1bmN0aW9uIHNldENvbnRleHQoa2V5LCBjb250ZXh0KSB7XG4gICAgZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5zZXQoa2V5LCBjb250ZXh0KTtcbiAgICByZXR1cm4gY29udGV4dDtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSBjb250ZXh0IHRoYXQgYmVsb25ncyB0byB0aGUgY2xvc2VzdCBwYXJlbnQgY29tcG9uZW50IHdpdGggdGhlIHNwZWNpZmllZCBga2V5YC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWdldGNvbnRleHRcbiAqL1xuZnVuY3Rpb24gZ2V0Q29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5nZXQoa2V5KTtcbn1cbi8qKlxuICogUmV0cmlldmVzIHRoZSB3aG9sZSBjb250ZXh0IG1hcCB0aGF0IGJlbG9uZ3MgdG8gdGhlIGNsb3Nlc3QgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uIFVzZWZ1bCwgZm9yIGV4YW1wbGUsIGlmIHlvdVxuICogcHJvZ3JhbW1hdGljYWxseSBjcmVhdGUgYSBjb21wb25lbnQgYW5kIHdhbnQgdG8gcGFzcyB0aGUgZXhpc3RpbmcgY29udGV4dCB0byBpdC5cbiAqXG4gKiBodHRwczovL3N2ZWx0ZS5kZXYvZG9jcyNydW4tdGltZS1zdmVsdGUtZ2V0YWxsY29udGV4dHNcbiAqL1xuZnVuY3Rpb24gZ2V0QWxsQ29udGV4dHMoKSB7XG4gICAgcmV0dXJuIGdldF9jdXJyZW50X2NvbXBvbmVudCgpLiQkLmNvbnRleHQ7XG59XG4vKipcbiAqIENoZWNrcyB3aGV0aGVyIGEgZ2l2ZW4gYGtleWAgaGFzIGJlZW4gc2V0IGluIHRoZSBjb250ZXh0IG9mIGEgcGFyZW50IGNvbXBvbmVudC5cbiAqIE11c3QgYmUgY2FsbGVkIGR1cmluZyBjb21wb25lbnQgaW5pdGlhbGlzYXRpb24uXG4gKlxuICogaHR0cHM6Ly9zdmVsdGUuZGV2L2RvY3MjcnVuLXRpbWUtc3ZlbHRlLWhhc2NvbnRleHRcbiAqL1xuZnVuY3Rpb24gaGFzQ29udGV4dChrZXkpIHtcbiAgICByZXR1cm4gZ2V0X2N1cnJlbnRfY29tcG9uZW50KCkuJCQuY29udGV4dC5oYXMoa2V5KTtcbn1cbi8vIFRPRE8gZmlndXJlIG91dCBpZiB3ZSBzdGlsbCB3YW50IHRvIHN1cHBvcnRcbi8vIHNob3J0aGFuZCBldmVudHMsIG9yIGlmIHdlIHdhbnQgdG8gaW1wbGVtZW50XG4vLyBhIHJlYWwgYnViYmxpbmcgbWVjaGFuaXNtXG5mdW5jdGlvbiBidWJibGUoY29tcG9uZW50LCBldmVudCkge1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IGNvbXBvbmVudC4kJC5jYWxsYmFja3NbZXZlbnQudHlwZV07XG4gICAgaWYgKGNhbGxiYWNrcykge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIGNhbGxiYWNrcy5zbGljZSgpLmZvckVhY2goZm4gPT4gZm4uY2FsbCh0aGlzLCBldmVudCkpO1xuICAgIH1cbn1cblxuY29uc3QgZGlydHlfY29tcG9uZW50cyA9IFtdO1xuY29uc3QgaW50cm9zID0geyBlbmFibGVkOiBmYWxzZSB9O1xuY29uc3QgYmluZGluZ19jYWxsYmFja3MgPSBbXTtcbmxldCByZW5kZXJfY2FsbGJhY2tzID0gW107XG5jb25zdCBmbHVzaF9jYWxsYmFja3MgPSBbXTtcbmNvbnN0IHJlc29sdmVkX3Byb21pc2UgPSAvKiBAX19QVVJFX18gKi8gUHJvbWlzZS5yZXNvbHZlKCk7XG5sZXQgdXBkYXRlX3NjaGVkdWxlZCA9IGZhbHNlO1xuZnVuY3Rpb24gc2NoZWR1bGVfdXBkYXRlKCkge1xuICAgIGlmICghdXBkYXRlX3NjaGVkdWxlZCkge1xuICAgICAgICB1cGRhdGVfc2NoZWR1bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVzb2x2ZWRfcHJvbWlzZS50aGVuKGZsdXNoKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0aWNrKCkge1xuICAgIHNjaGVkdWxlX3VwZGF0ZSgpO1xuICAgIHJldHVybiByZXNvbHZlZF9wcm9taXNlO1xufVxuZnVuY3Rpb24gYWRkX3JlbmRlcl9jYWxsYmFjayhmbikge1xuICAgIHJlbmRlcl9jYWxsYmFja3MucHVzaChmbik7XG59XG5mdW5jdGlvbiBhZGRfZmx1c2hfY2FsbGJhY2soZm4pIHtcbiAgICBmbHVzaF9jYWxsYmFja3MucHVzaChmbik7XG59XG4vLyBmbHVzaCgpIGNhbGxzIGNhbGxiYWNrcyBpbiB0aGlzIG9yZGVyOlxuLy8gMS4gQWxsIGJlZm9yZVVwZGF0ZSBjYWxsYmFja3MsIGluIG9yZGVyOiBwYXJlbnRzIGJlZm9yZSBjaGlsZHJlblxuLy8gMi4gQWxsIGJpbmQ6dGhpcyBjYWxsYmFja3MsIGluIHJldmVyc2Ugb3JkZXI6IGNoaWxkcmVuIGJlZm9yZSBwYXJlbnRzLlxuLy8gMy4gQWxsIGFmdGVyVXBkYXRlIGNhbGxiYWNrcywgaW4gb3JkZXI6IHBhcmVudHMgYmVmb3JlIGNoaWxkcmVuLiBFWENFUFRcbi8vICAgIGZvciBhZnRlclVwZGF0ZXMgY2FsbGVkIGR1cmluZyB0aGUgaW5pdGlhbCBvbk1vdW50LCB3aGljaCBhcmUgY2FsbGVkIGluXG4vLyAgICByZXZlcnNlIG9yZGVyOiBjaGlsZHJlbiBiZWZvcmUgcGFyZW50cy5cbi8vIFNpbmNlIGNhbGxiYWNrcyBtaWdodCB1cGRhdGUgY29tcG9uZW50IHZhbHVlcywgd2hpY2ggY291bGQgdHJpZ2dlciBhbm90aGVyXG4vLyBjYWxsIHRvIGZsdXNoKCksIHRoZSBmb2xsb3dpbmcgc3RlcHMgZ3VhcmQgYWdhaW5zdCB0aGlzOlxuLy8gMS4gRHVyaW5nIGJlZm9yZVVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuLy8gICAgZGlydHlfY29tcG9uZW50cyBhcnJheSBhbmQgd2lsbCBjYXVzZSBhIHJlZW50cmFudCBjYWxsIHRvIGZsdXNoKCkuIEJlY2F1c2Vcbi8vICAgIHRoZSBmbHVzaCBpbmRleCBpcyBrZXB0IG91dHNpZGUgdGhlIGZ1bmN0aW9uLCB0aGUgcmVlbnRyYW50IGNhbGwgd2lsbCBwaWNrXG4vLyAgICB1cCB3aGVyZSB0aGUgZWFybGllciBjYWxsIGxlZnQgb2ZmIGFuZCBnbyB0aHJvdWdoIGFsbCBkaXJ0eSBjb21wb25lbnRzLiBUaGVcbi8vICAgIGN1cnJlbnRfY29tcG9uZW50IHZhbHVlIGlzIHNhdmVkIGFuZCByZXN0b3JlZCBzbyB0aGF0IHRoZSByZWVudHJhbnQgY2FsbCB3aWxsXG4vLyAgICBub3QgaW50ZXJmZXJlIHdpdGggdGhlIFwicGFyZW50XCIgZmx1c2goKSBjYWxsLlxuLy8gMi4gYmluZDp0aGlzIGNhbGxiYWNrcyBjYW5ub3QgdHJpZ2dlciBuZXcgZmx1c2goKSBjYWxscy5cbi8vIDMuIER1cmluZyBhZnRlclVwZGF0ZSwgYW55IHVwZGF0ZWQgY29tcG9uZW50cyB3aWxsIE5PVCBoYXZlIHRoZWlyIGFmdGVyVXBkYXRlXG4vLyAgICBjYWxsYmFjayBjYWxsZWQgYSBzZWNvbmQgdGltZTsgdGhlIHNlZW5fY2FsbGJhY2tzIHNldCwgb3V0c2lkZSB0aGUgZmx1c2goKVxuLy8gICAgZnVuY3Rpb24sIGd1YXJhbnRlZXMgdGhpcyBiZWhhdmlvci5cbmNvbnN0IHNlZW5fY2FsbGJhY2tzID0gbmV3IFNldCgpO1xubGV0IGZsdXNoaWR4ID0gMDsgLy8gRG8gKm5vdCogbW92ZSB0aGlzIGluc2lkZSB0aGUgZmx1c2goKSBmdW5jdGlvblxuZnVuY3Rpb24gZmx1c2goKSB7XG4gICAgLy8gRG8gbm90IHJlZW50ZXIgZmx1c2ggd2hpbGUgZGlydHkgY29tcG9uZW50cyBhcmUgdXBkYXRlZCwgYXMgdGhpcyBjYW5cbiAgICAvLyByZXN1bHQgaW4gYW4gaW5maW5pdGUgbG9vcC4gSW5zdGVhZCwgbGV0IHRoZSBpbm5lciBmbHVzaCBoYW5kbGUgaXQuXG4gICAgLy8gUmVlbnRyYW5jeSBpcyBvayBhZnRlcndhcmRzIGZvciBiaW5kaW5ncyBldGMuXG4gICAgaWYgKGZsdXNoaWR4ICE9PSAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2F2ZWRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgZG8ge1xuICAgICAgICAvLyBmaXJzdCwgY2FsbCBiZWZvcmVVcGRhdGUgZnVuY3Rpb25zXG4gICAgICAgIC8vIGFuZCB1cGRhdGUgY29tcG9uZW50c1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd2hpbGUgKGZsdXNoaWR4IDwgZGlydHlfY29tcG9uZW50cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjb21wb25lbnQgPSBkaXJ0eV9jb21wb25lbnRzW2ZsdXNoaWR4XTtcbiAgICAgICAgICAgICAgICBmbHVzaGlkeCsrO1xuICAgICAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIHVwZGF0ZShjb21wb25lbnQuJCQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvLyByZXNldCBkaXJ0eSBzdGF0ZSB0byBub3QgZW5kIHVwIGluIGEgZGVhZGxvY2tlZCBzdGF0ZSBhbmQgdGhlbiByZXRocm93XG4gICAgICAgICAgICBkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICBmbHVzaGlkeCA9IDA7XG4gICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICB9XG4gICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgZGlydHlfY29tcG9uZW50cy5sZW5ndGggPSAwO1xuICAgICAgICBmbHVzaGlkeCA9IDA7XG4gICAgICAgIHdoaWxlIChiaW5kaW5nX2NhbGxiYWNrcy5sZW5ndGgpXG4gICAgICAgICAgICBiaW5kaW5nX2NhbGxiYWNrcy5wb3AoKSgpO1xuICAgICAgICAvLyB0aGVuLCBvbmNlIGNvbXBvbmVudHMgYXJlIHVwZGF0ZWQsIGNhbGxcbiAgICAgICAgLy8gYWZ0ZXJVcGRhdGUgZnVuY3Rpb25zLiBUaGlzIG1heSBjYXVzZVxuICAgICAgICAvLyBzdWJzZXF1ZW50IHVwZGF0ZXMuLi5cbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZW5kZXJfY2FsbGJhY2tzLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgICAgICBjb25zdCBjYWxsYmFjayA9IHJlbmRlcl9jYWxsYmFja3NbaV07XG4gICAgICAgICAgICBpZiAoIXNlZW5fY2FsbGJhY2tzLmhhcyhjYWxsYmFjaykpIHtcbiAgICAgICAgICAgICAgICAvLyAuLi5zbyBndWFyZCBhZ2FpbnN0IGluZmluaXRlIGxvb3BzXG4gICAgICAgICAgICAgICAgc2Vlbl9jYWxsYmFja3MuYWRkKGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlbmRlcl9jYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgICB9IHdoaWxlIChkaXJ0eV9jb21wb25lbnRzLmxlbmd0aCk7XG4gICAgd2hpbGUgKGZsdXNoX2NhbGxiYWNrcy5sZW5ndGgpIHtcbiAgICAgICAgZmx1c2hfY2FsbGJhY2tzLnBvcCgpKCk7XG4gICAgfVxuICAgIHVwZGF0ZV9zY2hlZHVsZWQgPSBmYWxzZTtcbiAgICBzZWVuX2NhbGxiYWNrcy5jbGVhcigpO1xuICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChzYXZlZF9jb21wb25lbnQpO1xufVxuZnVuY3Rpb24gdXBkYXRlKCQkKSB7XG4gICAgaWYgKCQkLmZyYWdtZW50ICE9PSBudWxsKSB7XG4gICAgICAgICQkLnVwZGF0ZSgpO1xuICAgICAgICBydW5fYWxsKCQkLmJlZm9yZV91cGRhdGUpO1xuICAgICAgICBjb25zdCBkaXJ0eSA9ICQkLmRpcnR5O1xuICAgICAgICAkJC5kaXJ0eSA9IFstMV07XG4gICAgICAgICQkLmZyYWdtZW50ICYmICQkLmZyYWdtZW50LnAoJCQuY3R4LCBkaXJ0eSk7XG4gICAgICAgICQkLmFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xuICAgIH1cbn1cbi8qKlxuICogVXNlZnVsIGZvciBleGFtcGxlIHRvIGV4ZWN1dGUgcmVtYWluaW5nIGBhZnRlclVwZGF0ZWAgY2FsbGJhY2tzIGJlZm9yZSBleGVjdXRpbmcgYGRlc3Ryb3lgLlxuICovXG5mdW5jdGlvbiBmbHVzaF9yZW5kZXJfY2FsbGJhY2tzKGZucykge1xuICAgIGNvbnN0IGZpbHRlcmVkID0gW107XG4gICAgY29uc3QgdGFyZ2V0cyA9IFtdO1xuICAgIHJlbmRlcl9jYWxsYmFja3MuZm9yRWFjaCgoYykgPT4gZm5zLmluZGV4T2YoYykgPT09IC0xID8gZmlsdGVyZWQucHVzaChjKSA6IHRhcmdldHMucHVzaChjKSk7XG4gICAgdGFyZ2V0cy5mb3JFYWNoKChjKSA9PiBjKCkpO1xuICAgIHJlbmRlcl9jYWxsYmFja3MgPSBmaWx0ZXJlZDtcbn1cblxubGV0IHByb21pc2U7XG5mdW5jdGlvbiB3YWl0KCkge1xuICAgIGlmICghcHJvbWlzZSkge1xuICAgICAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gICAgICAgIHByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBwcm9taXNlID0gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm9taXNlO1xufVxuZnVuY3Rpb24gZGlzcGF0Y2gobm9kZSwgZGlyZWN0aW9uLCBraW5kKSB7XG4gICAgbm9kZS5kaXNwYXRjaEV2ZW50KGN1c3RvbV9ldmVudChgJHtkaXJlY3Rpb24gPyAnaW50cm8nIDogJ291dHJvJ30ke2tpbmR9YCkpO1xufVxuY29uc3Qgb3V0cm9pbmcgPSBuZXcgU2V0KCk7XG5sZXQgb3V0cm9zO1xuZnVuY3Rpb24gZ3JvdXBfb3V0cm9zKCkge1xuICAgIG91dHJvcyA9IHtcbiAgICAgICAgcjogMCxcbiAgICAgICAgYzogW10sXG4gICAgICAgIHA6IG91dHJvcyAvLyBwYXJlbnQgZ3JvdXBcbiAgICB9O1xufVxuZnVuY3Rpb24gY2hlY2tfb3V0cm9zKCkge1xuICAgIGlmICghb3V0cm9zLnIpIHtcbiAgICAgICAgcnVuX2FsbChvdXRyb3MuYyk7XG4gICAgfVxuICAgIG91dHJvcyA9IG91dHJvcy5wO1xufVxuZnVuY3Rpb24gdHJhbnNpdGlvbl9pbihibG9jaywgbG9jYWwpIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2suaSkge1xuICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICBibG9jay5pKGxvY2FsKTtcbiAgICB9XG59XG5mdW5jdGlvbiB0cmFuc2l0aW9uX291dChibG9jaywgbG9jYWwsIGRldGFjaCwgY2FsbGJhY2spIHtcbiAgICBpZiAoYmxvY2sgJiYgYmxvY2subykge1xuICAgICAgICBpZiAob3V0cm9pbmcuaGFzKGJsb2NrKSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgb3V0cm9pbmcuYWRkKGJsb2NrKTtcbiAgICAgICAgb3V0cm9zLmMucHVzaCgoKSA9PiB7XG4gICAgICAgICAgICBvdXRyb2luZy5kZWxldGUoYmxvY2spO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRldGFjaClcbiAgICAgICAgICAgICAgICAgICAgYmxvY2suZCgxKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgYmxvY2subyhsb2NhbCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfVxufVxuY29uc3QgbnVsbF90cmFuc2l0aW9uID0geyBkdXJhdGlvbjogMCB9O1xuZnVuY3Rpb24gY3JlYXRlX2luX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcykge1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7IGRpcmVjdGlvbjogJ2luJyB9O1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGxldCBydW5uaW5nID0gZmFsc2U7XG4gICAgbGV0IGFuaW1hdGlvbl9uYW1lO1xuICAgIGxldCB0YXNrO1xuICAgIGxldCB1aWQgPSAwO1xuICAgIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgICAgIGlmIChhbmltYXRpb25fbmFtZSlcbiAgICAgICAgICAgIGRlbGV0ZV9ydWxlKG5vZGUsIGFuaW1hdGlvbl9uYW1lKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDAsIDEsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MsIHVpZCsrKTtcbiAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgY29uc3Qgc3RhcnRfdGltZSA9IG5vdygpICsgZGVsYXk7XG4gICAgICAgIGNvbnN0IGVuZF90aW1lID0gc3RhcnRfdGltZSArIGR1cmF0aW9uO1xuICAgICAgICBpZiAodGFzaylcbiAgICAgICAgICAgIHRhc2suYWJvcnQoKTtcbiAgICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgdHJ1ZSwgJ3N0YXJ0JykpO1xuICAgICAgICB0YXNrID0gbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMSwgMCk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHRydWUsICdlbmQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobm93ID49IHN0YXJ0X3RpbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdCA9IGVhc2luZygobm93IC0gc3RhcnRfdGltZSkgLyBkdXJhdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIHRpY2sodCwgMSAtIHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBydW5uaW5nO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbGV0IHN0YXJ0ZWQgPSBmYWxzZTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdGFydCgpIHtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSk7XG4gICAgICAgICAgICBpZiAoaXNfZnVuY3Rpb24oY29uZmlnKSkge1xuICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICB3YWl0KCkudGhlbihnbyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBpbnZhbGlkYXRlKCkge1xuICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9LFxuICAgICAgICBlbmQoKSB7XG4gICAgICAgICAgICBpZiAocnVubmluZykge1xuICAgICAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgICAgICBydW5uaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlX291dF90cmFuc2l0aW9uKG5vZGUsIGZuLCBwYXJhbXMpIHtcbiAgICBjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdvdXQnIH07XG4gICAgbGV0IGNvbmZpZyA9IGZuKG5vZGUsIHBhcmFtcywgb3B0aW9ucyk7XG4gICAgbGV0IHJ1bm5pbmcgPSB0cnVlO1xuICAgIGxldCBhbmltYXRpb25fbmFtZTtcbiAgICBjb25zdCBncm91cCA9IG91dHJvcztcbiAgICBncm91cC5yICs9IDE7XG4gICAgZnVuY3Rpb24gZ28oKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGlmIChjc3MpXG4gICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIDEsIDAsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICBjb25zdCBzdGFydF90aW1lID0gbm93KCkgKyBkZWxheTtcbiAgICAgICAgY29uc3QgZW5kX3RpbWUgPSBzdGFydF90aW1lICsgZHVyYXRpb247XG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4gZGlzcGF0Y2gobm9kZSwgZmFsc2UsICdzdGFydCcpKTtcbiAgICAgICAgbG9vcChub3cgPT4ge1xuICAgICAgICAgICAgaWYgKHJ1bm5pbmcpIHtcbiAgICAgICAgICAgICAgICBpZiAobm93ID49IGVuZF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRpY2soMCwgMSk7XG4gICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIGZhbHNlLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghLS1ncm91cC5yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIHdpbGwgcmVzdWx0IGluIGBlbmQoKWAgYmVpbmcgY2FsbGVkLFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gc28gd2UgZG9uJ3QgbmVlZCB0byBjbGVhbiB1cCBoZXJlXG4gICAgICAgICAgICAgICAgICAgICAgICBydW5fYWxsKGdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKG5vdyA+PSBzdGFydF90aW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHQgPSBlYXNpbmcoKG5vdyAtIHN0YXJ0X3RpbWUpIC8gZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICB0aWNrKDEgLSB0LCB0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcnVubmluZztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgIHdhaXQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgICAgIGdvKCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZ28oKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5kKHJlc2V0KSB7XG4gICAgICAgICAgICBpZiAocmVzZXQgJiYgY29uZmlnLnRpY2spIHtcbiAgICAgICAgICAgICAgICBjb25maWcudGljaygxLCAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChydW5uaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgICAgICAgICBkZWxldGVfcnVsZShub2RlLCBhbmltYXRpb25fbmFtZSk7XG4gICAgICAgICAgICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZV9iaWRpcmVjdGlvbmFsX3RyYW5zaXRpb24obm9kZSwgZm4sIHBhcmFtcywgaW50cm8pIHtcbiAgICBjb25zdCBvcHRpb25zID0geyBkaXJlY3Rpb246ICdib3RoJyB9O1xuICAgIGxldCBjb25maWcgPSBmbihub2RlLCBwYXJhbXMsIG9wdGlvbnMpO1xuICAgIGxldCB0ID0gaW50cm8gPyAwIDogMTtcbiAgICBsZXQgcnVubmluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICBsZXQgYW5pbWF0aW9uX25hbWUgPSBudWxsO1xuICAgIGZ1bmN0aW9uIGNsZWFyX2FuaW1hdGlvbigpIHtcbiAgICAgICAgaWYgKGFuaW1hdGlvbl9uYW1lKVxuICAgICAgICAgICAgZGVsZXRlX3J1bGUobm9kZSwgYW5pbWF0aW9uX25hbWUpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBpbml0KHByb2dyYW0sIGR1cmF0aW9uKSB7XG4gICAgICAgIGNvbnN0IGQgPSAocHJvZ3JhbS5iIC0gdCk7XG4gICAgICAgIGR1cmF0aW9uICo9IE1hdGguYWJzKGQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYTogdCxcbiAgICAgICAgICAgIGI6IHByb2dyYW0uYixcbiAgICAgICAgICAgIGQsXG4gICAgICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgICAgIHN0YXJ0OiBwcm9ncmFtLnN0YXJ0LFxuICAgICAgICAgICAgZW5kOiBwcm9ncmFtLnN0YXJ0ICsgZHVyYXRpb24sXG4gICAgICAgICAgICBncm91cDogcHJvZ3JhbS5ncm91cFxuICAgICAgICB9O1xuICAgIH1cbiAgICBmdW5jdGlvbiBnbyhiKSB7XG4gICAgICAgIGNvbnN0IHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDMwMCwgZWFzaW5nID0gaWRlbnRpdHksIHRpY2sgPSBub29wLCBjc3MgfSA9IGNvbmZpZyB8fCBudWxsX3RyYW5zaXRpb247XG4gICAgICAgIGNvbnN0IHByb2dyYW0gPSB7XG4gICAgICAgICAgICBzdGFydDogbm93KCkgKyBkZWxheSxcbiAgICAgICAgICAgIGJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFiKSB7XG4gICAgICAgICAgICAvLyBAdHMtaWdub3JlIHRvZG86IGltcHJvdmUgdHlwaW5nc1xuICAgICAgICAgICAgcHJvZ3JhbS5ncm91cCA9IG91dHJvcztcbiAgICAgICAgICAgIG91dHJvcy5yICs9IDE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pIHtcbiAgICAgICAgICAgIHBlbmRpbmdfcHJvZ3JhbSA9IHByb2dyYW07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGlzIGlzIGFuIGludHJvLCBhbmQgdGhlcmUncyBhIGRlbGF5LCB3ZSBuZWVkIHRvIGRvXG4gICAgICAgICAgICAvLyBhbiBpbml0aWFsIHRpY2sgYW5kL29yIGFwcGx5IENTUyBhbmltYXRpb24gaW1tZWRpYXRlbHlcbiAgICAgICAgICAgIGlmIChjc3MpIHtcbiAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICBhbmltYXRpb25fbmFtZSA9IGNyZWF0ZV9ydWxlKG5vZGUsIHQsIGIsIGR1cmF0aW9uLCBkZWxheSwgZWFzaW5nLCBjc3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGIpXG4gICAgICAgICAgICAgICAgdGljaygwLCAxKTtcbiAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IGluaXQocHJvZ3JhbSwgZHVyYXRpb24pO1xuICAgICAgICAgICAgYWRkX3JlbmRlcl9jYWxsYmFjaygoKSA9PiBkaXNwYXRjaChub2RlLCBiLCAnc3RhcnQnKSk7XG4gICAgICAgICAgICBsb29wKG5vdyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHBlbmRpbmdfcHJvZ3JhbSAmJiBub3cgPiBwZW5kaW5nX3Byb2dyYW0uc3RhcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgcnVubmluZ19wcm9ncmFtID0gaW5pdChwZW5kaW5nX3Byb2dyYW0sIGR1cmF0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgcGVuZGluZ19wcm9ncmFtID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgZGlzcGF0Y2gobm9kZSwgcnVubmluZ19wcm9ncmFtLmIsICdzdGFydCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY3NzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjbGVhcl9hbmltYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbl9uYW1lID0gY3JlYXRlX3J1bGUobm9kZSwgdCwgcnVubmluZ19wcm9ncmFtLmIsIHJ1bm5pbmdfcHJvZ3JhbS5kdXJhdGlvbiwgMCwgZWFzaW5nLCBjb25maWcuY3NzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub3cgPj0gcnVubmluZ19wcm9ncmFtLmVuZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0ID0gcnVubmluZ19wcm9ncmFtLmIsIDEgLSB0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BhdGNoKG5vZGUsIHJ1bm5pbmdfcHJvZ3JhbS5iLCAnZW5kJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXBlbmRpbmdfcHJvZ3JhbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlJ3JlIGRvbmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocnVubmluZ19wcm9ncmFtLmIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaW50cm8gXHUyMDE0IHdlIGNhbiB0aWR5IHVwIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsZWFyX2FuaW1hdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3V0cm8gXHUyMDE0IG5lZWRzIHRvIGJlIGNvb3JkaW5hdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghLS1ydW5uaW5nX3Byb2dyYW0uZ3JvdXAucilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ1bl9hbGwocnVubmluZ19wcm9ncmFtLmdyb3VwLmMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdfcHJvZ3JhbSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobm93ID49IHJ1bm5pbmdfcHJvZ3JhbS5zdGFydCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcCA9IG5vdyAtIHJ1bm5pbmdfcHJvZ3JhbS5zdGFydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHQgPSBydW5uaW5nX3Byb2dyYW0uYSArIHJ1bm5pbmdfcHJvZ3JhbS5kICogZWFzaW5nKHAgLyBydW5uaW5nX3Byb2dyYW0uZHVyYXRpb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGljayh0LCAxIC0gdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuICEhKHJ1bm5pbmdfcHJvZ3JhbSB8fCBwZW5kaW5nX3Byb2dyYW0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcnVuKGIpIHtcbiAgICAgICAgICAgIGlmIChpc19mdW5jdGlvbihjb25maWcpKSB7XG4gICAgICAgICAgICAgICAgd2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZyA9IGNvbmZpZyhvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgZ28oYik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBnbyhiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZW5kKCkge1xuICAgICAgICAgICAgY2xlYXJfYW5pbWF0aW9uKCk7XG4gICAgICAgICAgICBydW5uaW5nX3Byb2dyYW0gPSBwZW5kaW5nX3Byb2dyYW0gPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlX3Byb21pc2UocHJvbWlzZSwgaW5mbykge1xuICAgIGNvbnN0IHRva2VuID0gaW5mby50b2tlbiA9IHt9O1xuICAgIGZ1bmN0aW9uIHVwZGF0ZSh0eXBlLCBpbmRleCwga2V5LCB2YWx1ZSkge1xuICAgICAgICBpZiAoaW5mby50b2tlbiAhPT0gdG9rZW4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGluZm8ucmVzb2x2ZWQgPSB2YWx1ZTtcbiAgICAgICAgbGV0IGNoaWxkX2N0eCA9IGluZm8uY3R4O1xuICAgICAgICBpZiAoa2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNoaWxkX2N0eCA9IGNoaWxkX2N0eC5zbGljZSgpO1xuICAgICAgICAgICAgY2hpbGRfY3R4W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBibG9jayA9IHR5cGUgJiYgKGluZm8uY3VycmVudCA9IHR5cGUpKGNoaWxkX2N0eCk7XG4gICAgICAgIGxldCBuZWVkc19mbHVzaCA9IGZhbHNlO1xuICAgICAgICBpZiAoaW5mby5ibG9jaykge1xuICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzKSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9ja3MuZm9yRWFjaCgoYmxvY2ssIGkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgIT09IGluZGV4ICYmIGJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBncm91cF9vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zaXRpb25fb3V0KGJsb2NrLCAxLCAxLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZm8uYmxvY2tzW2ldID09PSBibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZvLmJsb2Nrc1tpXSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjaGVja19vdXRyb3MoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaW5mby5ibG9jay5kKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihibG9jaywgMSk7XG4gICAgICAgICAgICBibG9jay5tKGluZm8ubW91bnQoKSwgaW5mby5hbmNob3IpO1xuICAgICAgICAgICAgbmVlZHNfZmx1c2ggPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGluZm8uYmxvY2sgPSBibG9jaztcbiAgICAgICAgaWYgKGluZm8uYmxvY2tzKVxuICAgICAgICAgICAgaW5mby5ibG9ja3NbaW5kZXhdID0gYmxvY2s7XG4gICAgICAgIGlmIChuZWVkc19mbHVzaCkge1xuICAgICAgICAgICAgZmx1c2goKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaXNfcHJvbWlzZShwcm9taXNlKSkge1xuICAgICAgICBjb25zdCBjdXJyZW50X2NvbXBvbmVudCA9IGdldF9jdXJyZW50X2NvbXBvbmVudCgpO1xuICAgICAgICBwcm9taXNlLnRoZW4odmFsdWUgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnRoZW4sIDEsIGluZm8udmFsdWUsIHZhbHVlKTtcbiAgICAgICAgICAgIHNldF9jdXJyZW50X2NvbXBvbmVudChudWxsKTtcbiAgICAgICAgfSwgZXJyb3IgPT4ge1xuICAgICAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGN1cnJlbnRfY29tcG9uZW50KTtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLmNhdGNoLCAyLCBpbmZvLmVycm9yLCBlcnJvcik7XG4gICAgICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQobnVsbCk7XG4gICAgICAgICAgICBpZiAoIWluZm8uaGFzQ2F0Y2gpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGlmIHdlIHByZXZpb3VzbHkgaGFkIGEgdGhlbi9jYXRjaCBibG9jaywgZGVzdHJveSBpdFxuICAgICAgICBpZiAoaW5mby5jdXJyZW50ICE9PSBpbmZvLnBlbmRpbmcpIHtcbiAgICAgICAgICAgIHVwZGF0ZShpbmZvLnBlbmRpbmcsIDApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGlmIChpbmZvLmN1cnJlbnQgIT09IGluZm8udGhlbikge1xuICAgICAgICAgICAgdXBkYXRlKGluZm8udGhlbiwgMSwgaW5mby52YWx1ZSwgcHJvbWlzZSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpbmZvLnJlc29sdmVkID0gcHJvbWlzZTtcbiAgICB9XG59XG5mdW5jdGlvbiB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoKGluZm8sIGN0eCwgZGlydHkpIHtcbiAgICBjb25zdCBjaGlsZF9jdHggPSBjdHguc2xpY2UoKTtcbiAgICBjb25zdCB7IHJlc29sdmVkIH0gPSBpbmZvO1xuICAgIGlmIChpbmZvLmN1cnJlbnQgPT09IGluZm8udGhlbikge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby52YWx1ZV0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaWYgKGluZm8uY3VycmVudCA9PT0gaW5mby5jYXRjaCkge1xuICAgICAgICBjaGlsZF9jdHhbaW5mby5lcnJvcl0gPSByZXNvbHZlZDtcbiAgICB9XG4gICAgaW5mby5ibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpO1xufVxuXG5mdW5jdGlvbiBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICBibG9jay5kKDEpO1xuICAgIGxvb2t1cC5kZWxldGUoYmxvY2sua2V5KTtcbn1cbmZ1bmN0aW9uIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApIHtcbiAgICB0cmFuc2l0aW9uX291dChibG9jaywgMSwgMSwgKCkgPT4ge1xuICAgICAgICBsb29rdXAuZGVsZXRlKGJsb2NrLmtleSk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2soYmxvY2ssIGxvb2t1cCkge1xuICAgIGJsb2NrLmYoKTtcbiAgICBkZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gZml4X2FuZF9vdXRyb19hbmRfZGVzdHJveV9ibG9jayhibG9jaywgbG9va3VwKSB7XG4gICAgYmxvY2suZigpO1xuICAgIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrKGJsb2NrLCBsb29rdXApO1xufVxuZnVuY3Rpb24gdXBkYXRlX2tleWVkX2VhY2gob2xkX2Jsb2NrcywgZGlydHksIGdldF9rZXksIGR5bmFtaWMsIGN0eCwgbGlzdCwgbG9va3VwLCBub2RlLCBkZXN0cm95LCBjcmVhdGVfZWFjaF9ibG9jaywgbmV4dCwgZ2V0X2NvbnRleHQpIHtcbiAgICBsZXQgbyA9IG9sZF9ibG9ja3MubGVuZ3RoO1xuICAgIGxldCBuID0gbGlzdC5sZW5ndGg7XG4gICAgbGV0IGkgPSBvO1xuICAgIGNvbnN0IG9sZF9pbmRleGVzID0ge307XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgb2xkX2luZGV4ZXNbb2xkX2Jsb2Nrc1tpXS5rZXldID0gaTtcbiAgICBjb25zdCBuZXdfYmxvY2tzID0gW107XG4gICAgY29uc3QgbmV3X2xvb2t1cCA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkZWx0YXMgPSBuZXcgTWFwKCk7XG4gICAgY29uc3QgdXBkYXRlcyA9IFtdO1xuICAgIGkgPSBuO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgY29uc3QgY2hpbGRfY3R4ID0gZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKTtcbiAgICAgICAgY29uc3Qga2V5ID0gZ2V0X2tleShjaGlsZF9jdHgpO1xuICAgICAgICBsZXQgYmxvY2sgPSBsb29rdXAuZ2V0KGtleSk7XG4gICAgICAgIGlmICghYmxvY2spIHtcbiAgICAgICAgICAgIGJsb2NrID0gY3JlYXRlX2VhY2hfYmxvY2soa2V5LCBjaGlsZF9jdHgpO1xuICAgICAgICAgICAgYmxvY2suYygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGR5bmFtaWMpIHtcbiAgICAgICAgICAgIC8vIGRlZmVyIHVwZGF0ZXMgdW50aWwgYWxsIHRoZSBET00gc2h1ZmZsaW5nIGlzIGRvbmVcbiAgICAgICAgICAgIHVwZGF0ZXMucHVzaCgoKSA9PiBibG9jay5wKGNoaWxkX2N0eCwgZGlydHkpKTtcbiAgICAgICAgfVxuICAgICAgICBuZXdfbG9va3VwLnNldChrZXksIG5ld19ibG9ja3NbaV0gPSBibG9jayk7XG4gICAgICAgIGlmIChrZXkgaW4gb2xkX2luZGV4ZXMpXG4gICAgICAgICAgICBkZWx0YXMuc2V0KGtleSwgTWF0aC5hYnMoaSAtIG9sZF9pbmRleGVzW2tleV0pKTtcbiAgICB9XG4gICAgY29uc3Qgd2lsbF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGNvbnN0IGRpZF9tb3ZlID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIGluc2VydChibG9jaykge1xuICAgICAgICB0cmFuc2l0aW9uX2luKGJsb2NrLCAxKTtcbiAgICAgICAgYmxvY2subShub2RlLCBuZXh0KTtcbiAgICAgICAgbG9va3VwLnNldChibG9jay5rZXksIGJsb2NrKTtcbiAgICAgICAgbmV4dCA9IGJsb2NrLmZpcnN0O1xuICAgICAgICBuLS07XG4gICAgfVxuICAgIHdoaWxlIChvICYmIG4pIHtcbiAgICAgICAgY29uc3QgbmV3X2Jsb2NrID0gbmV3X2Jsb2Nrc1tuIC0gMV07XG4gICAgICAgIGNvbnN0IG9sZF9ibG9jayA9IG9sZF9ibG9ja3NbbyAtIDFdO1xuICAgICAgICBjb25zdCBuZXdfa2V5ID0gbmV3X2Jsb2NrLmtleTtcbiAgICAgICAgY29uc3Qgb2xkX2tleSA9IG9sZF9ibG9jay5rZXk7XG4gICAgICAgIGlmIChuZXdfYmxvY2sgPT09IG9sZF9ibG9jaykge1xuICAgICAgICAgICAgLy8gZG8gbm90aGluZ1xuICAgICAgICAgICAgbmV4dCA9IG5ld19ibG9jay5maXJzdDtcbiAgICAgICAgICAgIG8tLTtcbiAgICAgICAgICAgIG4tLTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghbmV3X2xvb2t1cC5oYXMob2xkX2tleSkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSBvbGQgYmxvY2tcbiAgICAgICAgICAgIGRlc3Ryb3kob2xkX2Jsb2NrLCBsb29rdXApO1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCFsb29rdXAuaGFzKG5ld19rZXkpIHx8IHdpbGxfbW92ZS5oYXMobmV3X2tleSkpIHtcbiAgICAgICAgICAgIGluc2VydChuZXdfYmxvY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRpZF9tb3ZlLmhhcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgby0tO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGRlbHRhcy5nZXQobmV3X2tleSkgPiBkZWx0YXMuZ2V0KG9sZF9rZXkpKSB7XG4gICAgICAgICAgICBkaWRfbW92ZS5hZGQobmV3X2tleSk7XG4gICAgICAgICAgICBpbnNlcnQobmV3X2Jsb2NrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHdpbGxfbW92ZS5hZGQob2xkX2tleSk7XG4gICAgICAgICAgICBvLS07XG4gICAgICAgIH1cbiAgICB9XG4gICAgd2hpbGUgKG8tLSkge1xuICAgICAgICBjb25zdCBvbGRfYmxvY2sgPSBvbGRfYmxvY2tzW29dO1xuICAgICAgICBpZiAoIW5ld19sb29rdXAuaGFzKG9sZF9ibG9jay5rZXkpKVxuICAgICAgICAgICAgZGVzdHJveShvbGRfYmxvY2ssIGxvb2t1cCk7XG4gICAgfVxuICAgIHdoaWxlIChuKVxuICAgICAgICBpbnNlcnQobmV3X2Jsb2Nrc1tuIC0gMV0pO1xuICAgIHJ1bl9hbGwodXBkYXRlcyk7XG4gICAgcmV0dXJuIG5ld19ibG9ja3M7XG59XG5mdW5jdGlvbiB2YWxpZGF0ZV9lYWNoX2tleXMoY3R4LCBsaXN0LCBnZXRfY29udGV4dCwgZ2V0X2tleSkge1xuICAgIGNvbnN0IGtleXMgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGtleSA9IGdldF9rZXkoZ2V0X2NvbnRleHQoY3R4LCBsaXN0LCBpKSk7XG4gICAgICAgIGlmIChrZXlzLmhhcyhrZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBoYXZlIGR1cGxpY2F0ZSBrZXlzIGluIGEga2V5ZWQgZWFjaCcpO1xuICAgICAgICB9XG4gICAgICAgIGtleXMuYWRkKGtleSk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc3ByZWFkX3VwZGF0ZShsZXZlbHMsIHVwZGF0ZXMpIHtcbiAgICBjb25zdCB1cGRhdGUgPSB7fTtcbiAgICBjb25zdCB0b19udWxsX291dCA9IHt9O1xuICAgIGNvbnN0IGFjY291bnRlZF9mb3IgPSB7ICQkc2NvcGU6IDEgfTtcbiAgICBsZXQgaSA9IGxldmVscy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBjb25zdCBvID0gbGV2ZWxzW2ldO1xuICAgICAgICBjb25zdCBuID0gdXBkYXRlc1tpXTtcbiAgICAgICAgaWYgKG4pIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIG8pIHtcbiAgICAgICAgICAgICAgICBpZiAoIShrZXkgaW4gbikpXG4gICAgICAgICAgICAgICAgICAgIHRvX251bGxfb3V0W2tleV0gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gbikge1xuICAgICAgICAgICAgICAgIGlmICghYWNjb3VudGVkX2ZvcltrZXldKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gbltrZXldO1xuICAgICAgICAgICAgICAgICAgICBhY2NvdW50ZWRfZm9yW2tleV0gPSAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldmVsc1tpXSA9IG47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvKSB7XG4gICAgICAgICAgICAgICAgYWNjb3VudGVkX2ZvcltrZXldID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGtleSBpbiB0b19udWxsX291dCkge1xuICAgICAgICBpZiAoIShrZXkgaW4gdXBkYXRlKSlcbiAgICAgICAgICAgIHVwZGF0ZVtrZXldID0gdW5kZWZpbmVkO1xuICAgIH1cbiAgICByZXR1cm4gdXBkYXRlO1xufVxuZnVuY3Rpb24gZ2V0X3NwcmVhZF9vYmplY3Qoc3ByZWFkX3Byb3BzKSB7XG4gICAgcmV0dXJuIHR5cGVvZiBzcHJlYWRfcHJvcHMgPT09ICdvYmplY3QnICYmIHNwcmVhZF9wcm9wcyAhPT0gbnVsbCA/IHNwcmVhZF9wcm9wcyA6IHt9O1xufVxuXG5jb25zdCBfYm9vbGVhbl9hdHRyaWJ1dGVzID0gW1xuICAgICdhbGxvd2Z1bGxzY3JlZW4nLFxuICAgICdhbGxvd3BheW1lbnRyZXF1ZXN0JyxcbiAgICAnYXN5bmMnLFxuICAgICdhdXRvZm9jdXMnLFxuICAgICdhdXRvcGxheScsXG4gICAgJ2NoZWNrZWQnLFxuICAgICdjb250cm9scycsXG4gICAgJ2RlZmF1bHQnLFxuICAgICdkZWZlcicsXG4gICAgJ2Rpc2FibGVkJyxcbiAgICAnZm9ybW5vdmFsaWRhdGUnLFxuICAgICdoaWRkZW4nLFxuICAgICdpbmVydCcsXG4gICAgJ2lzbWFwJyxcbiAgICAnbG9vcCcsXG4gICAgJ211bHRpcGxlJyxcbiAgICAnbXV0ZWQnLFxuICAgICdub21vZHVsZScsXG4gICAgJ25vdmFsaWRhdGUnLFxuICAgICdvcGVuJyxcbiAgICAncGxheXNpbmxpbmUnLFxuICAgICdyZWFkb25seScsXG4gICAgJ3JlcXVpcmVkJyxcbiAgICAncmV2ZXJzZWQnLFxuICAgICdzZWxlY3RlZCdcbl07XG4vKipcbiAqIExpc3Qgb2YgSFRNTCBib29sZWFuIGF0dHJpYnV0ZXMgKGUuZy4gYDxpbnB1dCBkaXNhYmxlZD5gKS5cbiAqIFNvdXJjZTogaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvaW5kaWNlcy5odG1sXG4gKi9cbmNvbnN0IGJvb2xlYW5fYXR0cmlidXRlcyA9IG5ldyBTZXQoWy4uLl9ib29sZWFuX2F0dHJpYnV0ZXNdKTtcblxuLyoqIHJlZ2V4IG9mIGFsbCBodG1sIHZvaWQgZWxlbWVudCBuYW1lcyAqL1xuY29uc3Qgdm9pZF9lbGVtZW50X25hbWVzID0gL14oPzphcmVhfGJhc2V8YnJ8Y29sfGNvbW1hbmR8ZW1iZWR8aHJ8aW1nfGlucHV0fGtleWdlbnxsaW5rfG1ldGF8cGFyYW18c291cmNlfHRyYWNrfHdicikkLztcbmZ1bmN0aW9uIGlzX3ZvaWQobmFtZSkge1xuICAgIHJldHVybiB2b2lkX2VsZW1lbnRfbmFtZXMudGVzdChuYW1lKSB8fCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09ICchZG9jdHlwZSc7XG59XG5cbmNvbnN0IGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyID0gL1tcXHMnXCI+Lz1cXHV7RkREMH0tXFx1e0ZERUZ9XFx1e0ZGRkV9XFx1e0ZGRkZ9XFx1ezFGRkZFfVxcdXsxRkZGRn1cXHV7MkZGRkV9XFx1ezJGRkZGfVxcdXszRkZGRX1cXHV7M0ZGRkZ9XFx1ezRGRkZFfVxcdXs0RkZGRn1cXHV7NUZGRkV9XFx1ezVGRkZGfVxcdXs2RkZGRX1cXHV7NkZGRkZ9XFx1ezdGRkZFfVxcdXs3RkZGRn1cXHV7OEZGRkV9XFx1ezhGRkZGfVxcdXs5RkZGRX1cXHV7OUZGRkZ9XFx1e0FGRkZFfVxcdXtBRkZGRn1cXHV7QkZGRkV9XFx1e0JGRkZGfVxcdXtDRkZGRX1cXHV7Q0ZGRkZ9XFx1e0RGRkZFfVxcdXtERkZGRn1cXHV7RUZGRkV9XFx1e0VGRkZGfVxcdXtGRkZGRX1cXHV7RkZGRkZ9XFx1ezEwRkZGRX1cXHV7MTBGRkZGfV0vdTtcbi8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuLy8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI25vbmNoYXJhY3RlclxuZnVuY3Rpb24gc3ByZWFkKGFyZ3MsIGF0dHJzX3RvX2FkZCkge1xuICAgIGNvbnN0IGF0dHJpYnV0ZXMgPSBPYmplY3QuYXNzaWduKHt9LCAuLi5hcmdzKTtcbiAgICBpZiAoYXR0cnNfdG9fYWRkKSB7XG4gICAgICAgIGNvbnN0IGNsYXNzZXNfdG9fYWRkID0gYXR0cnNfdG9fYWRkLmNsYXNzZXM7XG4gICAgICAgIGNvbnN0IHN0eWxlc190b19hZGQgPSBhdHRyc190b19hZGQuc3R5bGVzO1xuICAgICAgICBpZiAoY2xhc3Nlc190b19hZGQpIHtcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzLmNsYXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzID0gY2xhc3Nlc190b19hZGQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLmNsYXNzICs9ICcgJyArIGNsYXNzZXNfdG9fYWRkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzdHlsZXNfdG9fYWRkKSB7XG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlcy5zdHlsZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5zdHlsZSA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVzX3RvX2FkZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzLnN0eWxlID0gc3R5bGVfb2JqZWN0X3RvX3N0cmluZyhtZXJnZV9zc3Jfc3R5bGVzKGF0dHJpYnV0ZXMuc3R5bGUsIHN0eWxlc190b19hZGQpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXQgc3RyID0gJyc7XG4gICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChuYW1lID0+IHtcbiAgICAgICAgaWYgKGludmFsaWRfYXR0cmlidXRlX25hbWVfY2hhcmFjdGVyLnRlc3QobmFtZSkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB0cnVlKVxuICAgICAgICAgICAgc3RyICs9ICcgJyArIG5hbWU7XG4gICAgICAgIGVsc2UgaWYgKGJvb2xlYW5fYXR0cmlidXRlcy5oYXMobmFtZS50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgICAgaWYgKHZhbHVlKVxuICAgICAgICAgICAgICAgIHN0ciArPSAnICcgKyBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHZhbHVlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHN0ciArPSBgICR7bmFtZX09XCIke3ZhbHVlfVwiYDtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiBzdHI7XG59XG5mdW5jdGlvbiBtZXJnZV9zc3Jfc3R5bGVzKHN0eWxlX2F0dHJpYnV0ZSwgc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgY29uc3Qgc3R5bGVfb2JqZWN0ID0ge307XG4gICAgZm9yIChjb25zdCBpbmRpdmlkdWFsX3N0eWxlIG9mIHN0eWxlX2F0dHJpYnV0ZS5zcGxpdCgnOycpKSB7XG4gICAgICAgIGNvbnN0IGNvbG9uX2luZGV4ID0gaW5kaXZpZHVhbF9zdHlsZS5pbmRleE9mKCc6Jyk7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBpbmRpdmlkdWFsX3N0eWxlLnNsaWNlKDAsIGNvbG9uX2luZGV4KS50cmltKCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gaW5kaXZpZHVhbF9zdHlsZS5zbGljZShjb2xvbl9pbmRleCArIDEpLnRyaW0oKTtcbiAgICAgICAgaWYgKCFuYW1lKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3R5bGVfZGlyZWN0aXZlKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gc3R5bGVfZGlyZWN0aXZlW25hbWVdO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIHN0eWxlX29iamVjdFtuYW1lXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHN0eWxlX29iamVjdFtuYW1lXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3R5bGVfb2JqZWN0O1xufVxuY29uc3QgQVRUUl9SRUdFWCA9IC9bJlwiXS9nO1xuY29uc3QgQ09OVEVOVF9SRUdFWCA9IC9bJjxdL2c7XG4vKipcbiAqIE5vdGU6IHRoaXMgbWV0aG9kIGlzIHBlcmZvcm1hbmNlIHNlbnNpdGl2ZSBhbmQgaGFzIGJlZW4gb3B0aW1pemVkXG4gKiBodHRwczovL2dpdGh1Yi5jb20vc3ZlbHRlanMvc3ZlbHRlL3B1bGwvNTcwMVxuICovXG5mdW5jdGlvbiBlc2NhcGUodmFsdWUsIGlzX2F0dHIgPSBmYWxzZSkge1xuICAgIGNvbnN0IHN0ciA9IFN0cmluZyh2YWx1ZSk7XG4gICAgY29uc3QgcGF0dGVybiA9IGlzX2F0dHIgPyBBVFRSX1JFR0VYIDogQ09OVEVOVF9SRUdFWDtcbiAgICBwYXR0ZXJuLmxhc3RJbmRleCA9IDA7XG4gICAgbGV0IGVzY2FwZWQgPSAnJztcbiAgICBsZXQgbGFzdCA9IDA7XG4gICAgd2hpbGUgKHBhdHRlcm4udGVzdChzdHIpKSB7XG4gICAgICAgIGNvbnN0IGkgPSBwYXR0ZXJuLmxhc3RJbmRleCAtIDE7XG4gICAgICAgIGNvbnN0IGNoID0gc3RyW2ldO1xuICAgICAgICBlc2NhcGVkICs9IHN0ci5zdWJzdHJpbmcobGFzdCwgaSkgKyAoY2ggPT09ICcmJyA/ICcmYW1wOycgOiAoY2ggPT09ICdcIicgPyAnJnF1b3Q7JyA6ICcmbHQ7JykpO1xuICAgICAgICBsYXN0ID0gaSArIDE7XG4gICAgfVxuICAgIHJldHVybiBlc2NhcGVkICsgc3RyLnN1YnN0cmluZyhsYXN0KTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9hdHRyaWJ1dGVfdmFsdWUodmFsdWUpIHtcbiAgICAvLyBrZWVwIGJvb2xlYW5zLCBudWxsLCBhbmQgdW5kZWZpbmVkIGZvciB0aGUgc2FrZSBvZiBgc3ByZWFkYFxuICAgIGNvbnN0IHNob3VsZF9lc2NhcGUgPSB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8ICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKTtcbiAgICByZXR1cm4gc2hvdWxkX2VzY2FwZSA/IGVzY2FwZSh2YWx1ZSwgdHJ1ZSkgOiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVzY2FwZV9vYmplY3Qob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShvYmpba2V5XSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBlYWNoKGl0ZW1zLCBmbikge1xuICAgIGxldCBzdHIgPSAnJztcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSArPSAxKSB7XG4gICAgICAgIHN0ciArPSBmbihpdGVtc1tpXSwgaSk7XG4gICAgfVxuICAgIHJldHVybiBzdHI7XG59XG5jb25zdCBtaXNzaW5nX2NvbXBvbmVudCA9IHtcbiAgICAkJHJlbmRlcjogKCkgPT4gJydcbn07XG5mdW5jdGlvbiB2YWxpZGF0ZV9jb21wb25lbnQoY29tcG9uZW50LCBuYW1lKSB7XG4gICAgaWYgKCFjb21wb25lbnQgfHwgIWNvbXBvbmVudC4kJHJlbmRlcikge1xuICAgICAgICBpZiAobmFtZSA9PT0gJ3N2ZWx0ZTpjb21wb25lbnQnKVxuICAgICAgICAgICAgbmFtZSArPSAnIHRoaXM9ey4uLn0nO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYDwke25hbWV9PiBpcyBub3QgYSB2YWxpZCBTU1IgY29tcG9uZW50LiBZb3UgbWF5IG5lZWQgdG8gcmV2aWV3IHlvdXIgYnVpbGQgY29uZmlnIHRvIGVuc3VyZSB0aGF0IGRlcGVuZGVuY2llcyBhcmUgY29tcGlsZWQsIHJhdGhlciB0aGFuIGltcG9ydGVkIGFzIHByZS1jb21waWxlZCBtb2R1bGVzLiBPdGhlcndpc2UgeW91IG1heSBuZWVkIHRvIGZpeCBhIDwke25hbWV9Pi5gKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbn1cbmZ1bmN0aW9uIGRlYnVnKGZpbGUsIGxpbmUsIGNvbHVtbiwgdmFsdWVzKSB7XG4gICAgY29uc29sZS5sb2coYHtAZGVidWd9ICR7ZmlsZSA/IGZpbGUgKyAnICcgOiAnJ30oJHtsaW5lfToke2NvbHVtbn0pYCk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIGNvbnNvbGUubG9nKHZhbHVlcyk7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tY29uc29sZVxuICAgIHJldHVybiAnJztcbn1cbmxldCBvbl9kZXN0cm95O1xuZnVuY3Rpb24gY3JlYXRlX3Nzcl9jb21wb25lbnQoZm4pIHtcbiAgICBmdW5jdGlvbiAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMsIGNvbnRleHQpIHtcbiAgICAgICAgY29uc3QgcGFyZW50X2NvbXBvbmVudCA9IGN1cnJlbnRfY29tcG9uZW50O1xuICAgICAgICBjb25zdCAkJCA9IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3ksXG4gICAgICAgICAgICBjb250ZXh0OiBuZXcgTWFwKGNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAgICAgLy8gdGhlc2Ugd2lsbCBiZSBpbW1lZGlhdGVseSBkaXNjYXJkZWRcbiAgICAgICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgICAgIGJlZm9yZV91cGRhdGU6IFtdLFxuICAgICAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgICAgIGNhbGxiYWNrczogYmxhbmtfb2JqZWN0KClcbiAgICAgICAgfTtcbiAgICAgICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHsgJCQgfSk7XG4gICAgICAgIGNvbnN0IGh0bWwgPSBmbihyZXN1bHQsIHByb3BzLCBiaW5kaW5ncywgc2xvdHMpO1xuICAgICAgICBzZXRfY3VycmVudF9jb21wb25lbnQocGFyZW50X2NvbXBvbmVudCk7XG4gICAgICAgIHJldHVybiBodG1sO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICByZW5kZXI6IChwcm9wcyA9IHt9LCB7ICQkc2xvdHMgPSB7fSwgY29udGV4dCA9IG5ldyBNYXAoKSB9ID0ge30pID0+IHtcbiAgICAgICAgICAgIG9uX2Rlc3Ryb3kgPSBbXTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHsgdGl0bGU6ICcnLCBoZWFkOiAnJywgY3NzOiBuZXcgU2V0KCkgfTtcbiAgICAgICAgICAgIGNvbnN0IGh0bWwgPSAkJHJlbmRlcihyZXN1bHQsIHByb3BzLCB7fSwgJCRzbG90cywgY29udGV4dCk7XG4gICAgICAgICAgICBydW5fYWxsKG9uX2Rlc3Ryb3kpO1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBodG1sLFxuICAgICAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgICAgICBjb2RlOiBBcnJheS5mcm9tKHJlc3VsdC5jc3MpLm1hcChjc3MgPT4gY3NzLmNvZGUpLmpvaW4oJ1xcbicpLFxuICAgICAgICAgICAgICAgICAgICBtYXA6IG51bGwgLy8gVE9ET1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaGVhZDogcmVzdWx0LnRpdGxlICsgcmVzdWx0LmhlYWRcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0sXG4gICAgICAgICQkcmVuZGVyXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGFkZF9hdHRyaWJ1dGUobmFtZSwgdmFsdWUsIGJvb2xlYW4pIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCAoYm9vbGVhbiAmJiAhdmFsdWUpKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgY29uc3QgYXNzaWdubWVudCA9IChib29sZWFuICYmIHZhbHVlID09PSB0cnVlKSA/ICcnIDogYD1cIiR7ZXNjYXBlKHZhbHVlLCB0cnVlKX1cImA7XG4gICAgcmV0dXJuIGAgJHtuYW1lfSR7YXNzaWdubWVudH1gO1xufVxuZnVuY3Rpb24gYWRkX2NsYXNzZXMoY2xhc3Nlcykge1xuICAgIHJldHVybiBjbGFzc2VzID8gYCBjbGFzcz1cIiR7Y2xhc3Nlc31cImAgOiAnJztcbn1cbmZ1bmN0aW9uIHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KSB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHN0eWxlX29iamVjdClcbiAgICAgICAgLmZpbHRlcihrZXkgPT4gc3R5bGVfb2JqZWN0W2tleV0pXG4gICAgICAgIC5tYXAoa2V5ID0+IGAke2tleX06ICR7ZXNjYXBlX2F0dHJpYnV0ZV92YWx1ZShzdHlsZV9vYmplY3Rba2V5XSl9O2ApXG4gICAgICAgIC5qb2luKCcgJyk7XG59XG5mdW5jdGlvbiBhZGRfc3R5bGVzKHN0eWxlX29iamVjdCkge1xuICAgIGNvbnN0IHN0eWxlcyA9IHN0eWxlX29iamVjdF90b19zdHJpbmcoc3R5bGVfb2JqZWN0KTtcbiAgICByZXR1cm4gc3R5bGVzID8gYCBzdHlsZT1cIiR7c3R5bGVzfVwiYCA6ICcnO1xufVxuXG5mdW5jdGlvbiBiaW5kKGNvbXBvbmVudCwgbmFtZSwgY2FsbGJhY2spIHtcbiAgICBjb25zdCBpbmRleCA9IGNvbXBvbmVudC4kJC5wcm9wc1tuYW1lXTtcbiAgICBpZiAoaW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb21wb25lbnQuJCQuYm91bmRbaW5kZXhdID0gY2FsbGJhY2s7XG4gICAgICAgIGNhbGxiYWNrKGNvbXBvbmVudC4kJC5jdHhbaW5kZXhdKTtcbiAgICB9XG59XG5mdW5jdGlvbiBjcmVhdGVfY29tcG9uZW50KGJsb2NrKSB7XG4gICAgYmxvY2sgJiYgYmxvY2suYygpO1xufVxuZnVuY3Rpb24gY2xhaW1fY29tcG9uZW50KGJsb2NrLCBwYXJlbnRfbm9kZXMpIHtcbiAgICBibG9jayAmJiBibG9jay5sKHBhcmVudF9ub2Rlcyk7XG59XG5mdW5jdGlvbiBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCB0YXJnZXQsIGFuY2hvciwgY3VzdG9tRWxlbWVudCkge1xuICAgIGNvbnN0IHsgZnJhZ21lbnQsIGFmdGVyX3VwZGF0ZSB9ID0gY29tcG9uZW50LiQkO1xuICAgIGZyYWdtZW50ICYmIGZyYWdtZW50Lm0odGFyZ2V0LCBhbmNob3IpO1xuICAgIGlmICghY3VzdG9tRWxlbWVudCkge1xuICAgICAgICAvLyBvbk1vdW50IGhhcHBlbnMgYmVmb3JlIHRoZSBpbml0aWFsIGFmdGVyVXBkYXRlXG4gICAgICAgIGFkZF9yZW5kZXJfY2FsbGJhY2soKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgbmV3X29uX2Rlc3Ryb3kgPSBjb21wb25lbnQuJCQub25fbW91bnQubWFwKHJ1bikuZmlsdGVyKGlzX2Z1bmN0aW9uKTtcbiAgICAgICAgICAgIC8vIGlmIHRoZSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseVxuICAgICAgICAgICAgLy8gaXQgd2lsbCB1cGRhdGUgdGhlIGAkJC5vbl9kZXN0cm95YCByZWZlcmVuY2UgdG8gYG51bGxgLlxuICAgICAgICAgICAgLy8gdGhlIGRlc3RydWN0dXJlZCBvbl9kZXN0cm95IG1heSBzdGlsbCByZWZlcmVuY2UgdG8gdGhlIG9sZCBhcnJheVxuICAgICAgICAgICAgaWYgKGNvbXBvbmVudC4kJC5vbl9kZXN0cm95KSB7XG4gICAgICAgICAgICAgICAgY29tcG9uZW50LiQkLm9uX2Rlc3Ryb3kucHVzaCguLi5uZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFZGdlIGNhc2UgLSBjb21wb25lbnQgd2FzIGRlc3Ryb3llZCBpbW1lZGlhdGVseSxcbiAgICAgICAgICAgICAgICAvLyBtb3N0IGxpa2VseSBhcyBhIHJlc3VsdCBvZiBhIGJpbmRpbmcgaW5pdGlhbGlzaW5nXG4gICAgICAgICAgICAgICAgcnVuX2FsbChuZXdfb25fZGVzdHJveSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb21wb25lbnQuJCQub25fbW91bnQgPSBbXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFmdGVyX3VwZGF0ZS5mb3JFYWNoKGFkZF9yZW5kZXJfY2FsbGJhY2spO1xufVxuZnVuY3Rpb24gZGVzdHJveV9jb21wb25lbnQoY29tcG9uZW50LCBkZXRhY2hpbmcpIHtcbiAgICBjb25zdCAkJCA9IGNvbXBvbmVudC4kJDtcbiAgICBpZiAoJCQuZnJhZ21lbnQgIT09IG51bGwpIHtcbiAgICAgICAgZmx1c2hfcmVuZGVyX2NhbGxiYWNrcygkJC5hZnRlcl91cGRhdGUpO1xuICAgICAgICBydW5fYWxsKCQkLm9uX2Rlc3Ryb3kpO1xuICAgICAgICAkJC5mcmFnbWVudCAmJiAkJC5mcmFnbWVudC5kKGRldGFjaGluZyk7XG4gICAgICAgIC8vIFRPRE8gbnVsbCBvdXQgb3RoZXIgcmVmcywgaW5jbHVkaW5nIGNvbXBvbmVudC4kJCAoYnV0IG5lZWQgdG9cbiAgICAgICAgLy8gcHJlc2VydmUgZmluYWwgc3RhdGU/KVxuICAgICAgICAkJC5vbl9kZXN0cm95ID0gJCQuZnJhZ21lbnQgPSBudWxsO1xuICAgICAgICAkJC5jdHggPSBbXTtcbiAgICB9XG59XG5mdW5jdGlvbiBtYWtlX2RpcnR5KGNvbXBvbmVudCwgaSkge1xuICAgIGlmIChjb21wb25lbnQuJCQuZGlydHlbMF0gPT09IC0xKSB7XG4gICAgICAgIGRpcnR5X2NvbXBvbmVudHMucHVzaChjb21wb25lbnQpO1xuICAgICAgICBzY2hlZHVsZV91cGRhdGUoKTtcbiAgICAgICAgY29tcG9uZW50LiQkLmRpcnR5LmZpbGwoMCk7XG4gICAgfVxuICAgIGNvbXBvbmVudC4kJC5kaXJ0eVsoaSAvIDMxKSB8IDBdIHw9ICgxIDw8IChpICUgMzEpKTtcbn1cbmZ1bmN0aW9uIGluaXQoY29tcG9uZW50LCBvcHRpb25zLCBpbnN0YW5jZSwgY3JlYXRlX2ZyYWdtZW50LCBub3RfZXF1YWwsIHByb3BzLCBhcHBlbmRfc3R5bGVzLCBkaXJ0eSA9IFstMV0pIHtcbiAgICBjb25zdCBwYXJlbnRfY29tcG9uZW50ID0gY3VycmVudF9jb21wb25lbnQ7XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KGNvbXBvbmVudCk7XG4gICAgY29uc3QgJCQgPSBjb21wb25lbnQuJCQgPSB7XG4gICAgICAgIGZyYWdtZW50OiBudWxsLFxuICAgICAgICBjdHg6IFtdLFxuICAgICAgICAvLyBzdGF0ZVxuICAgICAgICBwcm9wcyxcbiAgICAgICAgdXBkYXRlOiBub29wLFxuICAgICAgICBub3RfZXF1YWwsXG4gICAgICAgIGJvdW5kOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgLy8gbGlmZWN5Y2xlXG4gICAgICAgIG9uX21vdW50OiBbXSxcbiAgICAgICAgb25fZGVzdHJveTogW10sXG4gICAgICAgIG9uX2Rpc2Nvbm5lY3Q6IFtdLFxuICAgICAgICBiZWZvcmVfdXBkYXRlOiBbXSxcbiAgICAgICAgYWZ0ZXJfdXBkYXRlOiBbXSxcbiAgICAgICAgY29udGV4dDogbmV3IE1hcChvcHRpb25zLmNvbnRleHQgfHwgKHBhcmVudF9jb21wb25lbnQgPyBwYXJlbnRfY29tcG9uZW50LiQkLmNvbnRleHQgOiBbXSkpLFxuICAgICAgICAvLyBldmVyeXRoaW5nIGVsc2VcbiAgICAgICAgY2FsbGJhY2tzOiBibGFua19vYmplY3QoKSxcbiAgICAgICAgZGlydHksXG4gICAgICAgIHNraXBfYm91bmQ6IGZhbHNlLFxuICAgICAgICByb290OiBvcHRpb25zLnRhcmdldCB8fCBwYXJlbnRfY29tcG9uZW50LiQkLnJvb3RcbiAgICB9O1xuICAgIGFwcGVuZF9zdHlsZXMgJiYgYXBwZW5kX3N0eWxlcygkJC5yb290KTtcbiAgICBsZXQgcmVhZHkgPSBmYWxzZTtcbiAgICAkJC5jdHggPSBpbnN0YW5jZVxuICAgICAgICA/IGluc3RhbmNlKGNvbXBvbmVudCwgb3B0aW9ucy5wcm9wcyB8fCB7fSwgKGksIHJldCwgLi4ucmVzdCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN0Lmxlbmd0aCA/IHJlc3RbMF0gOiByZXQ7XG4gICAgICAgICAgICBpZiAoJCQuY3R4ICYmIG5vdF9lcXVhbCgkJC5jdHhbaV0sICQkLmN0eFtpXSA9IHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGlmICghJCQuc2tpcF9ib3VuZCAmJiAkJC5ib3VuZFtpXSlcbiAgICAgICAgICAgICAgICAgICAgJCQuYm91bmRbaV0odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkeSlcbiAgICAgICAgICAgICAgICAgICAgbWFrZV9kaXJ0eShjb21wb25lbnQsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJldDtcbiAgICAgICAgfSlcbiAgICAgICAgOiBbXTtcbiAgICAkJC51cGRhdGUoKTtcbiAgICByZWFkeSA9IHRydWU7XG4gICAgcnVuX2FsbCgkJC5iZWZvcmVfdXBkYXRlKTtcbiAgICAvLyBgZmFsc2VgIGFzIGEgc3BlY2lhbCBjYXNlIG9mIG5vIERPTSBjb21wb25lbnRcbiAgICAkJC5mcmFnbWVudCA9IGNyZWF0ZV9mcmFnbWVudCA/IGNyZWF0ZV9mcmFnbWVudCgkJC5jdHgpIDogZmFsc2U7XG4gICAgaWYgKG9wdGlvbnMudGFyZ2V0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLmh5ZHJhdGUpIHtcbiAgICAgICAgICAgIHN0YXJ0X2h5ZHJhdGluZygpO1xuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBjaGlsZHJlbihvcHRpb25zLnRhcmdldCk7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQubChub2Rlcyk7XG4gICAgICAgICAgICBub2Rlcy5mb3JFYWNoKGRldGFjaCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLW5vbi1udWxsLWFzc2VydGlvblxuICAgICAgICAgICAgJCQuZnJhZ21lbnQgJiYgJCQuZnJhZ21lbnQuYygpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmludHJvKVxuICAgICAgICAgICAgdHJhbnNpdGlvbl9pbihjb21wb25lbnQuJCQuZnJhZ21lbnQpO1xuICAgICAgICBtb3VudF9jb21wb25lbnQoY29tcG9uZW50LCBvcHRpb25zLnRhcmdldCwgb3B0aW9ucy5hbmNob3IsIG9wdGlvbnMuY3VzdG9tRWxlbWVudCk7XG4gICAgICAgIGVuZF9oeWRyYXRpbmcoKTtcbiAgICAgICAgZmx1c2goKTtcbiAgICB9XG4gICAgc2V0X2N1cnJlbnRfY29tcG9uZW50KHBhcmVudF9jb21wb25lbnQpO1xufVxubGV0IFN2ZWx0ZUVsZW1lbnQ7XG5pZiAodHlwZW9mIEhUTUxFbGVtZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgU3ZlbHRlRWxlbWVudCA9IGNsYXNzIGV4dGVuZHMgSFRNTEVsZW1lbnQge1xuICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHN1cGVyKCk7XG4gICAgICAgICAgICB0aGlzLmF0dGFjaFNoYWRvdyh7IG1vZGU6ICdvcGVuJyB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgb25fbW91bnQgfSA9IHRoaXMuJCQ7XG4gICAgICAgICAgICB0aGlzLiQkLm9uX2Rpc2Nvbm5lY3QgPSBvbl9tb3VudC5tYXAocnVuKS5maWx0ZXIoaXNfZnVuY3Rpb24pO1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZSB0b2RvOiBpbXByb3ZlIHR5cGluZ3NcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IGluIHRoaXMuJCQuc2xvdHRlZCkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmUgdG9kbzogaW1wcm92ZSB0eXBpbmdzXG4gICAgICAgICAgICAgICAgdGhpcy5hcHBlbmRDaGlsZCh0aGlzLiQkLnNsb3R0ZWRba2V5XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXR0cmlidXRlQ2hhbmdlZENhbGxiYWNrKGF0dHIsIF9vbGRWYWx1ZSwgbmV3VmFsdWUpIHtcbiAgICAgICAgICAgIHRoaXNbYXR0cl0gPSBuZXdWYWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBkaXNjb25uZWN0ZWRDYWxsYmFjaygpIHtcbiAgICAgICAgICAgIHJ1bl9hbGwodGhpcy4kJC5vbl9kaXNjb25uZWN0KTtcbiAgICAgICAgfVxuICAgICAgICAkZGVzdHJveSgpIHtcbiAgICAgICAgICAgIGRlc3Ryb3lfY29tcG9uZW50KHRoaXMsIDEpO1xuICAgICAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgJG9uKHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3VsZCB0aGlzIGRlbGVnYXRlIHRvIGFkZEV2ZW50TGlzdGVuZXI/XG4gICAgICAgICAgICBpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBub29wO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgICAgICBjYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrcy5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICAkc2V0KCQkcHJvcHMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuJCQuc2tpcF9ib3VuZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgdGhpcy4kJHNldCgkJHByb3BzKTtcbiAgICAgICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59XG4vKipcbiAqIEJhc2UgY2xhc3MgZm9yIFN2ZWx0ZSBjb21wb25lbnRzLiBVc2VkIHdoZW4gZGV2PWZhbHNlLlxuICovXG5jbGFzcyBTdmVsdGVDb21wb25lbnQge1xuICAgICRkZXN0cm95KCkge1xuICAgICAgICBkZXN0cm95X2NvbXBvbmVudCh0aGlzLCAxKTtcbiAgICAgICAgdGhpcy4kZGVzdHJveSA9IG5vb3A7XG4gICAgfVxuICAgICRvbih0eXBlLCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWlzX2Z1bmN0aW9uKGNhbGxiYWNrKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY2FsbGJhY2tzID0gKHRoaXMuJCQuY2FsbGJhY2tzW3R5cGVdIHx8ICh0aGlzLiQkLmNhbGxiYWNrc1t0eXBlXSA9IFtdKSk7XG4gICAgICAgIGNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spO1xuICAgICAgICAgICAgaWYgKGluZGV4ICE9PSAtMSlcbiAgICAgICAgICAgICAgICBjYWxsYmFja3Muc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgJHNldCgkJHByb3BzKSB7XG4gICAgICAgIGlmICh0aGlzLiQkc2V0ICYmICFpc19lbXB0eSgkJHByb3BzKSkge1xuICAgICAgICAgICAgdGhpcy4kJC5za2lwX2JvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHRoaXMuJCRzZXQoJCRwcm9wcyk7XG4gICAgICAgICAgICB0aGlzLiQkLnNraXBfYm91bmQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZGlzcGF0Y2hfZGV2KHR5cGUsIGRldGFpbCkge1xuICAgIGRvY3VtZW50LmRpc3BhdGNoRXZlbnQoY3VzdG9tX2V2ZW50KHR5cGUsIE9iamVjdC5hc3NpZ24oeyB2ZXJzaW9uOiAnMy41OS4yJyB9LCBkZXRhaWwpLCB7IGJ1YmJsZXM6IHRydWUgfSkpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2Rldih0YXJnZXQsIG5vZGUpIHtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTUluc2VydCcsIHsgdGFyZ2V0LCBub2RlIH0pO1xuICAgIGFwcGVuZCh0YXJnZXQsIG5vZGUpO1xufVxuZnVuY3Rpb24gYXBwZW5kX2h5ZHJhdGlvbl9kZXYodGFyZ2V0LCBub2RlKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSB9KTtcbiAgICBhcHBlbmRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSk7XG59XG5mdW5jdGlvbiBpbnNlcnRfZGV2KHRhcmdldCwgbm9kZSwgYW5jaG9yKSB7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01JbnNlcnQnLCB7IHRhcmdldCwgbm9kZSwgYW5jaG9yIH0pO1xuICAgIGluc2VydCh0YXJnZXQsIG5vZGUsIGFuY2hvcik7XG59XG5mdW5jdGlvbiBpbnNlcnRfaHlkcmF0aW9uX2Rldih0YXJnZXQsIG5vZGUsIGFuY2hvcikge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NSW5zZXJ0JywgeyB0YXJnZXQsIG5vZGUsIGFuY2hvciB9KTtcbiAgICBpbnNlcnRfaHlkcmF0aW9uKHRhcmdldCwgbm9kZSwgYW5jaG9yKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9kZXYobm9kZSkge1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlJywgeyBub2RlIH0pO1xuICAgIGRldGFjaChub2RlKTtcbn1cbmZ1bmN0aW9uIGRldGFjaF9iZXR3ZWVuX2RldihiZWZvcmUsIGFmdGVyKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZyAmJiBiZWZvcmUubmV4dFNpYmxpbmcgIT09IGFmdGVyKSB7XG4gICAgICAgIGRldGFjaF9kZXYoYmVmb3JlLm5leHRTaWJsaW5nKTtcbiAgICB9XG59XG5mdW5jdGlvbiBkZXRhY2hfYmVmb3JlX2RldihhZnRlcikge1xuICAgIHdoaWxlIChhZnRlci5wcmV2aW91c1NpYmxpbmcpIHtcbiAgICAgICAgZGV0YWNoX2RldihhZnRlci5wcmV2aW91c1NpYmxpbmcpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGRldGFjaF9hZnRlcl9kZXYoYmVmb3JlKSB7XG4gICAgd2hpbGUgKGJlZm9yZS5uZXh0U2libGluZykge1xuICAgICAgICBkZXRhY2hfZGV2KGJlZm9yZS5uZXh0U2libGluZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbGlzdGVuX2Rldihub2RlLCBldmVudCwgaGFuZGxlciwgb3B0aW9ucywgaGFzX3ByZXZlbnRfZGVmYXVsdCwgaGFzX3N0b3BfcHJvcGFnYXRpb24sIGhhc19zdG9wX2ltbWVkaWF0ZV9wcm9wYWdhdGlvbikge1xuICAgIGNvbnN0IG1vZGlmaWVycyA9IG9wdGlvbnMgPT09IHRydWUgPyBbJ2NhcHR1cmUnXSA6IG9wdGlvbnMgPyBBcnJheS5mcm9tKE9iamVjdC5rZXlzKG9wdGlvbnMpKSA6IFtdO1xuICAgIGlmIChoYXNfcHJldmVudF9kZWZhdWx0KVxuICAgICAgICBtb2RpZmllcnMucHVzaCgncHJldmVudERlZmF1bHQnKTtcbiAgICBpZiAoaGFzX3N0b3BfcHJvcGFnYXRpb24pXG4gICAgICAgIG1vZGlmaWVycy5wdXNoKCdzdG9wUHJvcGFnYXRpb24nKTtcbiAgICBpZiAoaGFzX3N0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uKVxuICAgICAgICBtb2RpZmllcnMucHVzaCgnc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uJyk7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01BZGRFdmVudExpc3RlbmVyJywgeyBub2RlLCBldmVudCwgaGFuZGxlciwgbW9kaWZpZXJzIH0pO1xuICAgIGNvbnN0IGRpc3Bvc2UgPSBsaXN0ZW4obm9kZSwgZXZlbnQsIGhhbmRsZXIsIG9wdGlvbnMpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NUmVtb3ZlRXZlbnRMaXN0ZW5lcicsIHsgbm9kZSwgZXZlbnQsIGhhbmRsZXIsIG1vZGlmaWVycyB9KTtcbiAgICAgICAgZGlzcG9zZSgpO1xuICAgIH07XG59XG5mdW5jdGlvbiBhdHRyX2Rldihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKSB7XG4gICAgYXR0cihub2RlLCBhdHRyaWJ1dGUsIHZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01SZW1vdmVBdHRyaWJ1dGUnLCB7IG5vZGUsIGF0dHJpYnV0ZSB9KTtcbiAgICBlbHNlXG4gICAgICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0QXR0cmlidXRlJywgeyBub2RlLCBhdHRyaWJ1dGUsIHZhbHVlIH0pO1xufVxuZnVuY3Rpb24gcHJvcF9kZXYobm9kZSwgcHJvcGVydHksIHZhbHVlKSB7XG4gICAgbm9kZVtwcm9wZXJ0eV0gPSB2YWx1ZTtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldFByb3BlcnR5JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBkYXRhc2V0X2Rldihub2RlLCBwcm9wZXJ0eSwgdmFsdWUpIHtcbiAgICBub2RlLmRhdGFzZXRbcHJvcGVydHldID0gdmFsdWU7XG4gICAgZGlzcGF0Y2hfZGV2KCdTdmVsdGVET01TZXREYXRhc2V0JywgeyBub2RlLCBwcm9wZXJ0eSwgdmFsdWUgfSk7XG59XG5mdW5jdGlvbiBzZXRfZGF0YV9kZXYodGV4dCwgZGF0YSkge1xuICAgIGRhdGEgPSAnJyArIGRhdGE7XG4gICAgaWYgKHRleHQuZGF0YSA9PT0gZGF0YSlcbiAgICAgICAgcmV0dXJuO1xuICAgIGRpc3BhdGNoX2RldignU3ZlbHRlRE9NU2V0RGF0YScsIHsgbm9kZTogdGV4dCwgZGF0YSB9KTtcbiAgICB0ZXh0LmRhdGEgPSBkYXRhO1xufVxuZnVuY3Rpb24gc2V0X2RhdGFfY29udGVudGVkaXRhYmxlX2Rldih0ZXh0LCBkYXRhKSB7XG4gICAgZGF0YSA9ICcnICsgZGF0YTtcbiAgICBpZiAodGV4dC53aG9sZVRleHQgPT09IGRhdGEpXG4gICAgICAgIHJldHVybjtcbiAgICBkaXNwYXRjaF9kZXYoJ1N2ZWx0ZURPTVNldERhdGEnLCB7IG5vZGU6IHRleHQsIGRhdGEgfSk7XG4gICAgdGV4dC5kYXRhID0gZGF0YTtcbn1cbmZ1bmN0aW9uIHNldF9kYXRhX21heWJlX2NvbnRlbnRlZGl0YWJsZV9kZXYodGV4dCwgZGF0YSwgYXR0cl92YWx1ZSkge1xuICAgIGlmICh+Y29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMuaW5kZXhPZihhdHRyX3ZhbHVlKSkge1xuICAgICAgICBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGVfZGV2KHRleHQsIGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgc2V0X2RhdGFfZGV2KHRleHQsIGRhdGEpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2VhY2hfYXJndW1lbnQoYXJnKSB7XG4gICAgaWYgKHR5cGVvZiBhcmcgIT09ICdzdHJpbmcnICYmICEoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmICdsZW5ndGgnIGluIGFyZykpIHtcbiAgICAgICAgbGV0IG1zZyA9ICd7I2VhY2h9IG9ubHkgaXRlcmF0ZXMgb3ZlciBhcnJheS1saWtlIG9iamVjdHMuJztcbiAgICAgICAgaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgYXJnICYmIFN5bWJvbC5pdGVyYXRvciBpbiBhcmcpIHtcbiAgICAgICAgICAgIG1zZyArPSAnIFlvdSBjYW4gdXNlIGEgc3ByZWFkIHRvIGNvbnZlcnQgdGhpcyBpdGVyYWJsZSBpbnRvIGFuIGFycmF5Lic7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgfVxufVxuZnVuY3Rpb24gdmFsaWRhdGVfc2xvdHMobmFtZSwgc2xvdCwga2V5cykge1xuICAgIGZvciAoY29uc3Qgc2xvdF9rZXkgb2YgT2JqZWN0LmtleXMoc2xvdCkpIHtcbiAgICAgICAgaWYgKCF+a2V5cy5pbmRleE9mKHNsb3Rfa2V5KSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKGA8JHtuYW1lfT4gcmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBzbG90IFwiJHtzbG90X2tleX1cIi5gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX2R5bmFtaWNfZWxlbWVudCh0YWcpIHtcbiAgICBjb25zdCBpc19zdHJpbmcgPSB0eXBlb2YgdGFnID09PSAnc3RyaW5nJztcbiAgICBpZiAodGFnICYmICFpc19zdHJpbmcpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCc8c3ZlbHRlOmVsZW1lbnQ+IGV4cGVjdHMgXCJ0aGlzXCIgYXR0cmlidXRlIHRvIGJlIGEgc3RyaW5nLicpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHZhbGlkYXRlX3ZvaWRfZHluYW1pY19lbGVtZW50KHRhZykge1xuICAgIGlmICh0YWcgJiYgaXNfdm9pZCh0YWcpKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgPHN2ZWx0ZTplbGVtZW50IHRoaXM9XCIke3RhZ31cIj4gaXMgc2VsZi1jbG9zaW5nIGFuZCBjYW5ub3QgaGF2ZSBjb250ZW50LmApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50X2Rldihjb21wb25lbnQsIHByb3BzKSB7XG4gICAgY29uc3QgZXJyb3JfbWVzc2FnZSA9ICd0aGlzPXsuLi59IG9mIDxzdmVsdGU6Y29tcG9uZW50PiBzaG91bGQgc3BlY2lmeSBhIFN2ZWx0ZSBjb21wb25lbnQuJztcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBjb21wb25lbnQocHJvcHMpO1xuICAgICAgICBpZiAoIWluc3RhbmNlLiQkIHx8ICFpbnN0YW5jZS4kc2V0IHx8ICFpbnN0YW5jZS4kb24gfHwgIWluc3RhbmNlLiRkZXN0cm95KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZXJyb3JfbWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgIGNvbnN0IHsgbWVzc2FnZSB9ID0gZXJyO1xuICAgICAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnICYmIG1lc3NhZ2UuaW5kZXhPZignaXMgbm90IGEgY29uc3RydWN0b3InKSAhPT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihlcnJvcl9tZXNzYWdlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8qKlxuICogQmFzZSBjbGFzcyBmb3IgU3ZlbHRlIGNvbXBvbmVudHMgd2l0aCBzb21lIG1pbm9yIGRldi1lbmhhbmNlbWVudHMuIFVzZWQgd2hlbiBkZXY9dHJ1ZS5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50RGV2IGV4dGVuZHMgU3ZlbHRlQ29tcG9uZW50IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIGlmICghb3B0aW9ucyB8fCAoIW9wdGlvbnMudGFyZ2V0ICYmICFvcHRpb25zLiQkaW5saW5lKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiJ3RhcmdldCcgaXMgYSByZXF1aXJlZCBvcHRpb25cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoKTtcbiAgICB9XG4gICAgJGRlc3Ryb3koKSB7XG4gICAgICAgIHN1cGVyLiRkZXN0cm95KCk7XG4gICAgICAgIHRoaXMuJGRlc3Ryb3kgPSAoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oJ0NvbXBvbmVudCB3YXMgYWxyZWFkeSBkZXN0cm95ZWQnKTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1jb25zb2xlXG4gICAgICAgIH07XG4gICAgfVxuICAgICRjYXB0dXJlX3N0YXRlKCkgeyB9XG4gICAgJGluamVjdF9zdGF0ZSgpIHsgfVxufVxuLyoqXG4gKiBCYXNlIGNsYXNzIHRvIGNyZWF0ZSBzdHJvbmdseSB0eXBlZCBTdmVsdGUgY29tcG9uZW50cy5cbiAqIFRoaXMgb25seSBleGlzdHMgZm9yIHR5cGluZyBwdXJwb3NlcyBhbmQgc2hvdWxkIGJlIHVzZWQgaW4gYC5kLnRzYCBmaWxlcy5cbiAqXG4gKiAjIyMgRXhhbXBsZTpcbiAqXG4gKiBZb3UgaGF2ZSBjb21wb25lbnQgbGlicmFyeSBvbiBucG0gY2FsbGVkIGBjb21wb25lbnQtbGlicmFyeWAsIGZyb20gd2hpY2hcbiAqIHlvdSBleHBvcnQgYSBjb21wb25lbnQgY2FsbGVkIGBNeUNvbXBvbmVudGAuIEZvciBTdmVsdGUrVHlwZVNjcmlwdCB1c2VycyxcbiAqIHlvdSB3YW50IHRvIHByb3ZpZGUgdHlwaW5ncy4gVGhlcmVmb3JlIHlvdSBjcmVhdGUgYSBgaW5kZXguZC50c2A6XG4gKiBgYGB0c1xuICogaW1wb3J0IHsgU3ZlbHRlQ29tcG9uZW50VHlwZWQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gKiBleHBvcnQgY2xhc3MgTXlDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnRUeXBlZDx7Zm9vOiBzdHJpbmd9PiB7fVxuICogYGBgXG4gKiBUeXBpbmcgdGhpcyBtYWtlcyBpdCBwb3NzaWJsZSBmb3IgSURFcyBsaWtlIFZTIENvZGUgd2l0aCB0aGUgU3ZlbHRlIGV4dGVuc2lvblxuICogdG8gcHJvdmlkZSBpbnRlbGxpc2Vuc2UgYW5kIHRvIHVzZSB0aGUgY29tcG9uZW50IGxpa2UgdGhpcyBpbiBhIFN2ZWx0ZSBmaWxlXG4gKiB3aXRoIFR5cGVTY3JpcHQ6XG4gKiBgYGBzdmVsdGVcbiAqIDxzY3JpcHQgbGFuZz1cInRzXCI+XG4gKiBcdGltcG9ydCB7IE15Q29tcG9uZW50IH0gZnJvbSBcImNvbXBvbmVudC1saWJyYXJ5XCI7XG4gKiA8L3NjcmlwdD5cbiAqIDxNeUNvbXBvbmVudCBmb289eydiYXInfSAvPlxuICogYGBgXG4gKlxuICogIyMjIyBXaHkgbm90IG1ha2UgdGhpcyBwYXJ0IG9mIGBTdmVsdGVDb21wb25lbnQoRGV2KWA/XG4gKiBCZWNhdXNlXG4gKiBgYGB0c1xuICogY2xhc3MgQVN1YmNsYXNzT2ZTdmVsdGVDb21wb25lbnQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnQ8e2Zvbzogc3RyaW5nfT4ge31cbiAqIGNvbnN0IGNvbXBvbmVudDogdHlwZW9mIFN2ZWx0ZUNvbXBvbmVudCA9IEFTdWJjbGFzc09mU3ZlbHRlQ29tcG9uZW50O1xuICogYGBgXG4gKiB3aWxsIHRocm93IGEgdHlwZSBlcnJvciwgc28gd2UgbmVlZCB0byBzZXBhcmF0ZSB0aGUgbW9yZSBzdHJpY3RseSB0eXBlZCBjbGFzcy5cbiAqL1xuY2xhc3MgU3ZlbHRlQ29tcG9uZW50VHlwZWQgZXh0ZW5kcyBTdmVsdGVDb21wb25lbnREZXYge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxufVxuZnVuY3Rpb24gbG9vcF9ndWFyZCh0aW1lb3V0KSB7XG4gICAgY29uc3Qgc3RhcnQgPSBEYXRlLm5vdygpO1xuICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpIC0gc3RhcnQgPiB0aW1lb3V0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0luZmluaXRlIGxvb3AgZGV0ZWN0ZWQnKTtcbiAgICAgICAgfVxuICAgIH07XG59XG5cbmV4cG9ydCB7IEh0bWxUYWcsIEh0bWxUYWdIeWRyYXRpb24sIFJlc2l6ZU9ic2VydmVyU2luZ2xldG9uLCBTdmVsdGVDb21wb25lbnQsIFN2ZWx0ZUNvbXBvbmVudERldiwgU3ZlbHRlQ29tcG9uZW50VHlwZWQsIFN2ZWx0ZUVsZW1lbnQsIGFjdGlvbl9kZXN0cm95ZXIsIGFkZF9hdHRyaWJ1dGUsIGFkZF9jbGFzc2VzLCBhZGRfZmx1c2hfY2FsbGJhY2ssIGFkZF9pZnJhbWVfcmVzaXplX2xpc3RlbmVyLCBhZGRfbG9jYXRpb24sIGFkZF9yZW5kZXJfY2FsbGJhY2ssIGFkZF9zdHlsZXMsIGFkZF90cmFuc2Zvcm0sIGFmdGVyVXBkYXRlLCBhcHBlbmQsIGFwcGVuZF9kZXYsIGFwcGVuZF9lbXB0eV9zdHlsZXNoZWV0LCBhcHBlbmRfaHlkcmF0aW9uLCBhcHBlbmRfaHlkcmF0aW9uX2RldiwgYXBwZW5kX3N0eWxlcywgYXNzaWduLCBhdHRyLCBhdHRyX2RldiwgYXR0cmlidXRlX3RvX29iamVjdCwgYmVmb3JlVXBkYXRlLCBiaW5kLCBiaW5kaW5nX2NhbGxiYWNrcywgYmxhbmtfb2JqZWN0LCBidWJibGUsIGNoZWNrX291dHJvcywgY2hpbGRyZW4sIGNsYWltX2NvbW1lbnQsIGNsYWltX2NvbXBvbmVudCwgY2xhaW1fZWxlbWVudCwgY2xhaW1faHRtbF90YWcsIGNsYWltX3NwYWNlLCBjbGFpbV9zdmdfZWxlbWVudCwgY2xhaW1fdGV4dCwgY2xlYXJfbG9vcHMsIGNvbW1lbnQsIGNvbXBvbmVudF9zdWJzY3JpYmUsIGNvbXB1dGVfcmVzdF9wcm9wcywgY29tcHV0ZV9zbG90cywgY29uc3RydWN0X3N2ZWx0ZV9jb21wb25lbnQsIGNvbnN0cnVjdF9zdmVsdGVfY29tcG9uZW50X2RldiwgY29udGVudGVkaXRhYmxlX3RydXRoeV92YWx1ZXMsIGNyZWF0ZUV2ZW50RGlzcGF0Y2hlciwgY3JlYXRlX2FuaW1hdGlvbiwgY3JlYXRlX2JpZGlyZWN0aW9uYWxfdHJhbnNpdGlvbiwgY3JlYXRlX2NvbXBvbmVudCwgY3JlYXRlX2luX3RyYW5zaXRpb24sIGNyZWF0ZV9vdXRfdHJhbnNpdGlvbiwgY3JlYXRlX3Nsb3QsIGNyZWF0ZV9zc3JfY29tcG9uZW50LCBjdXJyZW50X2NvbXBvbmVudCwgY3VzdG9tX2V2ZW50LCBkYXRhc2V0X2RldiwgZGVidWcsIGRlc3Ryb3lfYmxvY2ssIGRlc3Ryb3lfY29tcG9uZW50LCBkZXN0cm95X2VhY2gsIGRldGFjaCwgZGV0YWNoX2FmdGVyX2RldiwgZGV0YWNoX2JlZm9yZV9kZXYsIGRldGFjaF9iZXR3ZWVuX2RldiwgZGV0YWNoX2RldiwgZGlydHlfY29tcG9uZW50cywgZGlzcGF0Y2hfZGV2LCBlYWNoLCBlbGVtZW50LCBlbGVtZW50X2lzLCBlbXB0eSwgZW5kX2h5ZHJhdGluZywgZXNjYXBlLCBlc2NhcGVfYXR0cmlidXRlX3ZhbHVlLCBlc2NhcGVfb2JqZWN0LCBleGNsdWRlX2ludGVybmFsX3Byb3BzLCBmaXhfYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9hbmRfb3V0cm9fYW5kX2Rlc3Ryb3lfYmxvY2ssIGZpeF9wb3NpdGlvbiwgZmx1c2gsIGZsdXNoX3JlbmRlcl9jYWxsYmFja3MsIGdldEFsbENvbnRleHRzLCBnZXRDb250ZXh0LCBnZXRfYWxsX2RpcnR5X2Zyb21fc2NvcGUsIGdldF9iaW5kaW5nX2dyb3VwX3ZhbHVlLCBnZXRfY3VycmVudF9jb21wb25lbnQsIGdldF9jdXN0b21fZWxlbWVudHNfc2xvdHMsIGdldF9yb290X2Zvcl9zdHlsZSwgZ2V0X3Nsb3RfY2hhbmdlcywgZ2V0X3NwcmVhZF9vYmplY3QsIGdldF9zcHJlYWRfdXBkYXRlLCBnZXRfc3RvcmVfdmFsdWUsIGdsb2JhbHMsIGdyb3VwX291dHJvcywgaGFuZGxlX3Byb21pc2UsIGhhc0NvbnRleHQsIGhhc19wcm9wLCBoZWFkX3NlbGVjdG9yLCBpZGVudGl0eSwgaW5pdCwgaW5pdF9iaW5kaW5nX2dyb3VwLCBpbml0X2JpbmRpbmdfZ3JvdXBfZHluYW1pYywgaW5zZXJ0LCBpbnNlcnRfZGV2LCBpbnNlcnRfaHlkcmF0aW9uLCBpbnNlcnRfaHlkcmF0aW9uX2RldiwgaW50cm9zLCBpbnZhbGlkX2F0dHJpYnV0ZV9uYW1lX2NoYXJhY3RlciwgaXNfY2xpZW50LCBpc19jcm9zc29yaWdpbiwgaXNfZW1wdHksIGlzX2Z1bmN0aW9uLCBpc19wcm9taXNlLCBpc192b2lkLCBsaXN0ZW4sIGxpc3Rlbl9kZXYsIGxvb3AsIGxvb3BfZ3VhcmQsIG1lcmdlX3Nzcl9zdHlsZXMsIG1pc3NpbmdfY29tcG9uZW50LCBtb3VudF9jb21wb25lbnQsIG5vb3AsIG5vdF9lcXVhbCwgbm93LCBudWxsX3RvX2VtcHR5LCBvYmplY3Rfd2l0aG91dF9wcm9wZXJ0aWVzLCBvbkRlc3Ryb3ksIG9uTW91bnQsIG9uY2UsIG91dHJvX2FuZF9kZXN0cm95X2Jsb2NrLCBwcmV2ZW50X2RlZmF1bHQsIHByb3BfZGV2LCBxdWVyeV9zZWxlY3Rvcl9hbGwsIHJhZiwgcmVzaXplX29ic2VydmVyX2JvcmRlcl9ib3gsIHJlc2l6ZV9vYnNlcnZlcl9jb250ZW50X2JveCwgcmVzaXplX29ic2VydmVyX2RldmljZV9waXhlbF9jb250ZW50X2JveCwgcnVuLCBydW5fYWxsLCBzYWZlX25vdF9lcXVhbCwgc2NoZWR1bGVfdXBkYXRlLCBzZWxlY3RfbXVsdGlwbGVfdmFsdWUsIHNlbGVjdF9vcHRpb24sIHNlbGVjdF9vcHRpb25zLCBzZWxlY3RfdmFsdWUsIHNlbGYsIHNldENvbnRleHQsIHNldF9hdHRyaWJ1dGVzLCBzZXRfY3VycmVudF9jb21wb25lbnQsIHNldF9jdXN0b21fZWxlbWVudF9kYXRhLCBzZXRfY3VzdG9tX2VsZW1lbnRfZGF0YV9tYXAsIHNldF9kYXRhLCBzZXRfZGF0YV9jb250ZW50ZWRpdGFibGUsIHNldF9kYXRhX2NvbnRlbnRlZGl0YWJsZV9kZXYsIHNldF9kYXRhX2Rldiwgc2V0X2RhdGFfbWF5YmVfY29udGVudGVkaXRhYmxlLCBzZXRfZGF0YV9tYXliZV9jb250ZW50ZWRpdGFibGVfZGV2LCBzZXRfZHluYW1pY19lbGVtZW50X2RhdGEsIHNldF9pbnB1dF90eXBlLCBzZXRfaW5wdXRfdmFsdWUsIHNldF9ub3csIHNldF9yYWYsIHNldF9zdG9yZV92YWx1ZSwgc2V0X3N0eWxlLCBzZXRfc3ZnX2F0dHJpYnV0ZXMsIHNwYWNlLCBzcGxpdF9jc3NfdW5pdCwgc3ByZWFkLCBzcmNfdXJsX2VxdWFsLCBzdGFydF9oeWRyYXRpbmcsIHN0b3BfaW1tZWRpYXRlX3Byb3BhZ2F0aW9uLCBzdG9wX3Byb3BhZ2F0aW9uLCBzdWJzY3JpYmUsIHN2Z19lbGVtZW50LCB0ZXh0LCB0aWNrLCB0aW1lX3Jhbmdlc190b19hcnJheSwgdG9fbnVtYmVyLCB0b2dnbGVfY2xhc3MsIHRyYW5zaXRpb25faW4sIHRyYW5zaXRpb25fb3V0LCB0cnVzdGVkLCB1cGRhdGVfYXdhaXRfYmxvY2tfYnJhbmNoLCB1cGRhdGVfa2V5ZWRfZWFjaCwgdXBkYXRlX3Nsb3QsIHVwZGF0ZV9zbG90X2Jhc2UsIHZhbGlkYXRlX2NvbXBvbmVudCwgdmFsaWRhdGVfZHluYW1pY19lbGVtZW50LCB2YWxpZGF0ZV9lYWNoX2FyZ3VtZW50LCB2YWxpZGF0ZV9lYWNoX2tleXMsIHZhbGlkYXRlX3Nsb3RzLCB2YWxpZGF0ZV9zdG9yZSwgdmFsaWRhdGVfdm9pZF9keW5hbWljX2VsZW1lbnQsIHhsaW5rX2F0dHIgfTtcbiIsICJpbXBvcnQgeyBub29wLCBzYWZlX25vdF9lcXVhbCwgc3Vic2NyaWJlLCBydW5fYWxsLCBpc19mdW5jdGlvbiB9IGZyb20gJy4uL2ludGVybmFsL2luZGV4Lm1qcyc7XG5leHBvcnQgeyBnZXRfc3RvcmVfdmFsdWUgYXMgZ2V0IH0gZnJvbSAnLi4vaW50ZXJuYWwvaW5kZXgubWpzJztcblxuY29uc3Qgc3Vic2NyaWJlcl9xdWV1ZSA9IFtdO1xuLyoqXG4gKiBDcmVhdGVzIGEgYFJlYWRhYmxlYCBzdG9yZSB0aGF0IGFsbG93cyByZWFkaW5nIGJ5IHN1YnNjcmlwdGlvbi5cbiAqIEBwYXJhbSB2YWx1ZSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyfSBbc3RhcnRdXG4gKi9cbmZ1bmN0aW9uIHJlYWRhYmxlKHZhbHVlLCBzdGFydCkge1xuICAgIHJldHVybiB7XG4gICAgICAgIHN1YnNjcmliZTogd3JpdGFibGUodmFsdWUsIHN0YXJ0KS5zdWJzY3JpYmVcbiAgICB9O1xufVxuLyoqXG4gKiBDcmVhdGUgYSBgV3JpdGFibGVgIHN0b3JlIHRoYXQgYWxsb3dzIGJvdGggdXBkYXRpbmcgYW5kIHJlYWRpbmcgYnkgc3Vic2NyaXB0aW9uLlxuICogQHBhcmFtIHsqPX12YWx1ZSBpbml0aWFsIHZhbHVlXG4gKiBAcGFyYW0ge1N0YXJ0U3RvcE5vdGlmaWVyPX0gc3RhcnRcbiAqL1xuZnVuY3Rpb24gd3JpdGFibGUodmFsdWUsIHN0YXJ0ID0gbm9vcCkge1xuICAgIGxldCBzdG9wO1xuICAgIGNvbnN0IHN1YnNjcmliZXJzID0gbmV3IFNldCgpO1xuICAgIGZ1bmN0aW9uIHNldChuZXdfdmFsdWUpIHtcbiAgICAgICAgaWYgKHNhZmVfbm90X2VxdWFsKHZhbHVlLCBuZXdfdmFsdWUpKSB7XG4gICAgICAgICAgICB2YWx1ZSA9IG5ld192YWx1ZTtcbiAgICAgICAgICAgIGlmIChzdG9wKSB7IC8vIHN0b3JlIGlzIHJlYWR5XG4gICAgICAgICAgICAgICAgY29uc3QgcnVuX3F1ZXVlID0gIXN1YnNjcmliZXJfcXVldWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3Qgc3Vic2NyaWJlciBvZiBzdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyWzFdKCk7XG4gICAgICAgICAgICAgICAgICAgIHN1YnNjcmliZXJfcXVldWUucHVzaChzdWJzY3JpYmVyLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChydW5fcXVldWUpIHtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyX3F1ZXVlW2ldWzBdKHN1YnNjcmliZXJfcXVldWVbaSArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzdWJzY3JpYmVyX3F1ZXVlLmxlbmd0aCA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZShmbikge1xuICAgICAgICBzZXQoZm4odmFsdWUpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gc3Vic2NyaWJlKHJ1biwgaW52YWxpZGF0ZSA9IG5vb3ApIHtcbiAgICAgICAgY29uc3Qgc3Vic2NyaWJlciA9IFtydW4sIGludmFsaWRhdGVdO1xuICAgICAgICBzdWJzY3JpYmVycy5hZGQoc3Vic2NyaWJlcik7XG4gICAgICAgIGlmIChzdWJzY3JpYmVycy5zaXplID09PSAxKSB7XG4gICAgICAgICAgICBzdG9wID0gc3RhcnQoc2V0KSB8fCBub29wO1xuICAgICAgICB9XG4gICAgICAgIHJ1bih2YWx1ZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICBzdWJzY3JpYmVycy5kZWxldGUoc3Vic2NyaWJlcik7XG4gICAgICAgICAgICBpZiAoc3Vic2NyaWJlcnMuc2l6ZSA9PT0gMCAmJiBzdG9wKSB7XG4gICAgICAgICAgICAgICAgc3RvcCgpO1xuICAgICAgICAgICAgICAgIHN0b3AgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4geyBzZXQsIHVwZGF0ZSwgc3Vic2NyaWJlIH07XG59XG5mdW5jdGlvbiBkZXJpdmVkKHN0b3JlcywgZm4sIGluaXRpYWxfdmFsdWUpIHtcbiAgICBjb25zdCBzaW5nbGUgPSAhQXJyYXkuaXNBcnJheShzdG9yZXMpO1xuICAgIGNvbnN0IHN0b3Jlc19hcnJheSA9IHNpbmdsZVxuICAgICAgICA/IFtzdG9yZXNdXG4gICAgICAgIDogc3RvcmVzO1xuICAgIGNvbnN0IGF1dG8gPSBmbi5sZW5ndGggPCAyO1xuICAgIHJldHVybiByZWFkYWJsZShpbml0aWFsX3ZhbHVlLCAoc2V0KSA9PiB7XG4gICAgICAgIGxldCBzdGFydGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IFtdO1xuICAgICAgICBsZXQgcGVuZGluZyA9IDA7XG4gICAgICAgIGxldCBjbGVhbnVwID0gbm9vcDtcbiAgICAgICAgY29uc3Qgc3luYyA9ICgpID0+IHtcbiAgICAgICAgICAgIGlmIChwZW5kaW5nKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gZm4oc2luZ2xlID8gdmFsdWVzWzBdIDogdmFsdWVzLCBzZXQpO1xuICAgICAgICAgICAgaWYgKGF1dG8pIHtcbiAgICAgICAgICAgICAgICBzZXQocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNsZWFudXAgPSBpc19mdW5jdGlvbihyZXN1bHQpID8gcmVzdWx0IDogbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgdW5zdWJzY3JpYmVycyA9IHN0b3Jlc19hcnJheS5tYXAoKHN0b3JlLCBpKSA9PiBzdWJzY3JpYmUoc3RvcmUsICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdmFsdWVzW2ldID0gdmFsdWU7XG4gICAgICAgICAgICBwZW5kaW5nICY9IH4oMSA8PCBpKTtcbiAgICAgICAgICAgIGlmIChzdGFydGVkKSB7XG4gICAgICAgICAgICAgICAgc3luYygpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCAoKSA9PiB7XG4gICAgICAgICAgICBwZW5kaW5nIHw9ICgxIDw8IGkpO1xuICAgICAgICB9KSk7XG4gICAgICAgIHN0YXJ0ZWQgPSB0cnVlO1xuICAgICAgICBzeW5jKCk7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiBzdG9wKCkge1xuICAgICAgICAgICAgcnVuX2FsbCh1bnN1YnNjcmliZXJzKTtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gc2V0IHRoaXMgdG8gZmFsc2UgYmVjYXVzZSBjYWxsYmFja3MgY2FuIHN0aWxsIGhhcHBlbiBkZXNwaXRlIGhhdmluZyB1bnN1YnNjcmliZWQ6XG4gICAgICAgICAgICAvLyBDYWxsYmFja3MgbWlnaHQgYWxyZWFkeSBiZSBwbGFjZWQgaW4gdGhlIHF1ZXVlIHdoaWNoIGRvZXNuJ3Qga25vdyBpdCBzaG91bGQgbm8gbG9uZ2VyXG4gICAgICAgICAgICAvLyBpbnZva2UgdGhpcyBkZXJpdmVkIHN0b3JlLlxuICAgICAgICAgICAgc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICB9O1xuICAgIH0pO1xufVxuLyoqXG4gKiBUYWtlcyBhIHN0b3JlIGFuZCByZXR1cm5zIGEgbmV3IG9uZSBkZXJpdmVkIGZyb20gdGhlIG9sZCBvbmUgdGhhdCBpcyByZWFkYWJsZS5cbiAqXG4gKiBAcGFyYW0gc3RvcmUgLSBzdG9yZSB0byBtYWtlIHJlYWRvbmx5XG4gKi9cbmZ1bmN0aW9uIHJlYWRvbmx5KHN0b3JlKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3Vic2NyaWJlOiBzdG9yZS5zdWJzY3JpYmUuYmluZChzdG9yZSlcbiAgICB9O1xufVxuXG5leHBvcnQgeyBkZXJpdmVkLCByZWFkYWJsZSwgcmVhZG9ubHksIHdyaXRhYmxlIH07XG4iLCAiZXhwb3J0IGNvbnN0IFZJRVdfVFlQRV9USU1FTElORSA9IFwidGltZWxpbmVcIjtcblxuZXhwb3J0IGNvbnN0IERFRkFVTFRfRFVSQVRJT05fTUlOVVRFUyA9IDMwO1xuXG5leHBvcnQgY29uc3QgU05BUF9TVEVQX01JTlVURVMgPSAxMDtcblxuZXhwb3J0IGNvbnN0IElDT05TID0gW1xuICBcImFueS1rZXlcIixcbiAgXCJhdWRpby1maWxlXCIsXG4gIFwiYmxvY2tzXCIsXG4gIFwiYnJva2VuLWxpbmtcIixcbiAgXCJidWxsZXQtbGlzdFwiLFxuICBcImNhbGVuZGFyLXdpdGgtY2hlY2ttYXJrXCIsXG4gIFwiY2hlY2ttYXJrXCIsXG4gIFwiY3JlYXRlLW5ld1wiLFxuICBcImNyb3NzXCIsXG4gIFwiY3Jvc3MtaW4tYm94XCIsXG4gIFwiY3Jvc3NlZC1zdGFyXCIsXG4gIFwiZGljZVwiLFxuICBcImRvY3VtZW50XCIsXG4gIFwiZG9jdW1lbnRzXCIsXG4gIFwiZG90LW5ldHdvcmtcIixcbiAgXCJlbnRlclwiLFxuICBcImV4cGFuZC12ZXJ0aWNhbGx5XCIsXG4gIFwiZmlsbGVkLXBpblwiLFxuICBcImZvbGRlclwiLFxuICBcImdlYXJcIixcbiAgXCJnby10by1maWxlXCIsXG4gIFwiaGFzaHRhZ1wiLFxuICBcImhlbHBcIixcbiAgXCJob3Jpem9udGFsLXNwbGl0XCIsXG4gIFwiaW1hZ2UtZmlsZVwiLFxuICBcImluZm9cIixcbiAgXCJpbnN0YWxsXCIsXG4gIFwibGFuZ3VhZ2VzXCIsXG4gIFwibGVmdC1hcnJvd1wiLFxuICBcImxlZnQtYXJyb3ctd2l0aC10YWlsXCIsXG4gIFwibGluZXMtb2YtdGV4dFwiLFxuICBcImxpbmtcIixcbiAgXCJsb2dvLWNyeXN0YWxcIixcbiAgXCJtYWduaWZ5aW5nLWdsYXNzXCIsXG4gIFwibWljcm9waG9uZVwiLFxuICBcIm1pY3JvcGhvbmUtZmlsbGVkXCIsXG4gIFwib3Blbi12YXVsdFwiLFxuICBcInBhbmUtbGF5b3V0XCIsXG4gIFwicGFwZXItcGxhbmVcIixcbiAgXCJwZGYtZmlsZVwiLFxuICBcInBlbmNpbFwiLFxuICBcInBpblwiLFxuICBcInBvcHVwLW9wZW5cIixcbiAgXCJwcmVzZW50YXRpb25cIixcbiAgXCJyZXNldFwiLFxuICBcInJpZ2h0LWFycm93XCIsXG4gIFwicmlnaHQtYXJyb3ctd2l0aC10YWlsXCIsXG4gIFwicmlnaHQtdHJpYW5nbGVcIixcbiAgXCJzZWFyY2hcIixcbiAgXCJzaGVldHMtaW4tYm94XCIsXG4gIFwic3RhclwiLFxuICBcInN0YXItbGlzdFwiLFxuICBcInN3aXRjaFwiLFxuICBcInRocmVlLWhvcml6b250YWwtYmFyc1wiLFxuICBcInRyYXNoXCIsXG4gIFwidHdvLWNvbHVtbnNcIixcbiAgXCJ1cC1hbmQtZG93bi1hcnJvd3NcIixcbiAgXCJ1cHBlcmNhc2UtbG93ZXJjYXNlLWFcIixcbiAgXCJ2YXVsdFwiLFxuICBcInZlcnRpY2FsLXNwbGl0XCIsXG4gIFwidmVydGljYWwtdGhyZWUtZG90c1wiLFxuXTtcbiIsICJjb25zdCB1bFRva2VuID0gYFstKitdYDtcbmNvbnN0IG9sVG9rZW4gPSBgXFxcXGQrXFxcXC5gO1xuY29uc3QgbGlzdFRva2VuID0gYCgke3VsVG9rZW59fCR7b2xUb2tlbn0pXFxcXHMrYDtcblxuY29uc3QgY2hlY2tib3ggPSBgXFxcXFsoPzxjb21wbGV0aW9uPlteXFxcXF1dKV1cXFxccytgO1xuY29uc3QgY2hlY2tib3hPck5vdGhpbmcgPSBgKCR7Y2hlY2tib3h9KT9gO1xuXG5jb25zdCBkdXJhdGlvblNlcGFyYXRvciA9IGBcXFxccyotezEsMn1cXFxccypgO1xuXG5jb25zdCBob3VycyA9IGBcXFxcZHsxLDJ9YDtcbmNvbnN0IG1pbnV0ZXMgPSBgXFxcXGR7Mn1gO1xuY29uc3QgaG91ck1pbnV0ZVNlcGFyYXRvciA9IGBbOi4gXWA7XG5cbmNvbnN0IHRpbWUgPSBgKCR7aG91cnN9KSg/OiR7aG91ck1pbnV0ZVNlcGFyYXRvcn0/KCR7bWludXRlc30pKT9cXFxccyooW2FwXW0pP2A7XG5cbmV4cG9ydCBjb25zdCB0aW1lUmVnRXhwID0gbmV3IFJlZ0V4cCh0aW1lKTtcbmV4cG9ydCBjb25zdCB0aW1lc3RhbXBSZWdFeHAgPSBuZXcgUmVnRXhwKFxuICBgXig/PGxpc3RUb2tlbnM+JHtsaXN0VG9rZW59JHtjaGVja2JveE9yTm90aGluZ30pKD88dGltZXM+KD88c3RhcnQ+JHt0aW1lfSkoPzoke2R1cmF0aW9uU2VwYXJhdG9yfSg/PGVuZD4ke3RpbWV9KSk/KSg/PHRleHQ+LispJGAsXG4gIFwiaW1cIixcbik7XG4iLCAiaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tIFwibW9tZW50L21vbWVudFwiO1xuXG5jb25zdCBtb21lbnQgPSB3aW5kb3cubW9tZW50O1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TWludXRlc1NpbmNlTWlkbmlnaHQoKSB7XG4gIHJldHVybiBtb21lbnQoKS5kaWZmKG1vbWVudCgpLnN0YXJ0T2YoXCJkYXlcIiksIFwibWludXRlc1wiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldE1pbnV0ZXNTaW5jZU1pZG5pZ2h0VG8oc29tZU1vbWVudDogTW9tZW50KSB7XG4gIHJldHVybiBnZXREaWZmSW5NaW51dGVzKHNvbWVNb21lbnQsIG1vbWVudCgpLnN0YXJ0T2YoXCJkYXlcIikpO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0RGlmZkluTWludXRlcyhhOiBNb21lbnQsIGI6IE1vbWVudCkge1xuICByZXR1cm4gTWF0aC5hYnMoYS5kaWZmKGIsIFwibWludXRlc1wiKSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBtaW51dGVzVG9Nb21lbnQobWludXRlc1NpbmNlTWlkbmlnaHQ6IG51bWJlcikge1xuICByZXR1cm4gbW9tZW50KCkuc3RhcnRPZihcImRheVwiKS5hZGQobWludXRlc1NpbmNlTWlkbmlnaHQsIFwibWludXRlc1wiKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFkZE1pbnV0ZXMobW9tZW50OiBNb21lbnQsIG1pbnV0ZXM6IG51bWJlcikge1xuICByZXR1cm4gbW9tZW50LmNsb25lKCkuYWRkKG1pbnV0ZXMsIFwibWludXRlc1wiKTtcbn1cbiIsICJpbXBvcnQgeyB0aW1lUmVnRXhwIH0gZnJvbSBcIi4uL3JlZ2V4cFwiO1xuaW1wb3J0IHR5cGUgeyBNb21lbnQgfSBmcm9tIFwibW9tZW50L21vbWVudFwiO1xuaW1wb3J0IHsgYWRkTWludXRlcywgbWludXRlc1RvTW9tZW50IH0gZnJvbSBcIi4uL3V0aWwvbW9tZW50XCI7XG5pbXBvcnQgdHlwZSB7IFRpbWVzdGFtcCB9IGZyb20gXCJzcmMvc3RvcmUvdGltZWxpbmUtc3RvcmVcIjtcbmltcG9ydCB0eXBlIHsgUGxhbkl0ZW0gfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlVGltZXN0YW1wKGFzVGV4dD86IHN0cmluZyk6IE1vbWVudCB8IG51bGwge1xuICBpZiAoIWFzVGV4dCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgY29uc3QgcmVzdWx0ID0gdGltZVJlZ0V4cC5leGVjKGFzVGV4dCk7XG5cbiAgaWYgKHJlc3VsdCA9PT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihgJHthc1RleHR9IGlzIG5vdCBhIHZhbGlkIHRpbWVzdGFtcGApO1xuICB9XG5cbiAgY29uc3QgWywgaG91cnMsIG1pbnV0ZXMsIGFtcG1dID0gcmVzdWx0O1xuXG4gIGxldCBwYXJzZWRIb3VycyA9IHBhcnNlSW50KGhvdXJzKTtcblxuICBpZiAoaXNOYU4ocGFyc2VkSG91cnMpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGAke2FzVGV4dH0gaXMgbm90IGEgdmFsaWQgdGltZXN0YW1wYCk7XG4gIH1cblxuICBjb25zdCBwYXJzZWRNaW51dGVzID0gcGFyc2VJbnQobWludXRlcykgfHwgMDtcblxuICAvLyB0b2RvOiB3aGF0IGFib3V0IDEyP1xuICBpZiAoYW1wbT8udG9Mb3dlckNhc2UoKSA9PT0gXCJwbVwiICYmIHBhcnNlZEhvdXJzIDwgMTIpIHtcbiAgICBwYXJzZWRIb3VycyArPSAxMjtcbiAgfVxuXG4gIHJldHVybiB3aW5kb3cubW9tZW50KHsgaG91cnM6IHBhcnNlZEhvdXJzLCBtaW51dGVzOiBwYXJzZWRNaW51dGVzIH0pO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVwbGFjZVRpbWVzdGFtcChcbiAgcGxhbkl0ZW06IFBsYW5JdGVtLFxuICB7IHN0YXJ0TWludXRlcywgZHVyYXRpb25NaW51dGVzIH06IFRpbWVzdGFtcCxcbikge1xuICByZXR1cm4gYCR7cGxhbkl0ZW0ubGlzdFRva2Vuc30ke2NyZWF0ZVRpbWVzdGFtcChcbiAgICBzdGFydE1pbnV0ZXMsXG4gICAgZHVyYXRpb25NaW51dGVzLFxuICApfSAke3BsYW5JdGVtLnRleHR9YDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlVGltZXN0YW1wKHN0YXJ0TWludXRlczogbnVtYmVyLCBkdXJhdGlvbk1pbnV0ZXM6IG51bWJlcikge1xuICBjb25zdCBzdGFydCA9IG1pbnV0ZXNUb01vbWVudChzdGFydE1pbnV0ZXMpO1xuICBjb25zdCBlbmQgPSBhZGRNaW51dGVzKHN0YXJ0LCBkdXJhdGlvbk1pbnV0ZXMpO1xuXG4gIHJldHVybiBgJHtmb3JtYXRUaW1lc3RhbXAoc3RhcnQpfSAtICR7Zm9ybWF0VGltZXN0YW1wKGVuZCl9YDtcbn1cblxuZnVuY3Rpb24gZm9ybWF0VGltZXN0YW1wKG1vbWVudDogTW9tZW50KSB7XG4gIHJldHVybiBtb21lbnQuZm9ybWF0KFwiSEg6bW1cIik7XG59XG4iLCAiaW1wb3J0IHsgUG9zIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5cbmV4cG9ydCBjb25zdCBnZXRUZXh0QXRQb3NpdGlvbiA9ICh0ZXh0SW5wdXQ6IHN0cmluZywgcG9zOiBQb3MpID0+XG4gIHRleHRJbnB1dC5zdWJzdHJpbmcocG9zLnN0YXJ0Lm9mZnNldCwgcG9zLmVuZC5vZmZzZXQpO1xuXG5leHBvcnQgY29uc3QgZ2V0VGV4dEZyb21MaW5lU3RhcnRUb1Bvc2l0aW9uRW5kID0gKFxuICB0ZXh0SW5wdXQ6IHN0cmluZyxcbiAgcG9zOiBQb3NcbikgPT4gdGV4dElucHV0LnN1YnN0cmluZyhwb3Muc3RhcnQub2Zmc2V0IC0gcG9zLnN0YXJ0LmNvbCwgcG9zLmVuZC5vZmZzZXQpO1xuXG5leHBvcnQgY29uc3QgZG9lc1Bvc2l0aW9uSW5jbHVkZUFub3RoZXIgPSAoY29udGFpbmVyOiBQb3MsIGNoaWxkOiBQb3MpID0+XG4gIGNvbnRhaW5lci5zdGFydC5vZmZzZXQgPD0gY2hpbGQuc3RhcnQub2Zmc2V0ICYmXG4gIGNvbnRhaW5lci5lbmQub2Zmc2V0ID49IGNoaWxkLmVuZC5vZmZzZXQ7XG5cbmV4cG9ydCBmdW5jdGlvbiBpc1NhbWVQb3NpdGlvbihhPzogUG9zLCBiPzogUG9zKSB7XG4gIHJldHVybiAoXG4gICAgYSAmJiBiICYmIGEuc3RhcnQub2Zmc2V0ID09PSBiLnN0YXJ0Lm9mZnNldCAmJiBhLmVuZC5vZmZzZXQgPT09IGIuZW5kLm9mZnNldFxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25Gcm9tT2Zmc2V0cyhcbiAgY29udGVudDogc3RyaW5nLFxuICBzdGFydE9mZnNldDogbnVtYmVyLFxuICBlbmRPZmZzZXQ6IG51bWJlclxuKSB7XG4gIGNvbnN0IHN0YXJ0TGluZSA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KS5zcGxpdChcIlxcblwiKS5sZW5ndGggLSAxO1xuICBjb25zdCBlbmRMaW5lID0gY29udGVudC5zdWJzdHJpbmcoMCwgZW5kT2Zmc2V0KS5zcGxpdChcIlxcblwiKS5sZW5ndGggLSAxO1xuXG4gIGNvbnN0IHN0YXJ0TGluZVBvcyA9IGNvbnRlbnQuc3Vic3RyaW5nKDAsIHN0YXJ0T2Zmc2V0KS5sYXN0SW5kZXhPZihcIlxcblwiKSArIDE7XG4gIGNvbnN0IHN0YXJ0Q29sID0gY29udGVudC5zdWJzdHJpbmcoc3RhcnRMaW5lUG9zLCBzdGFydE9mZnNldCkubGVuZ3RoO1xuXG4gIGNvbnN0IGVuZExpbmVQb3MgPSBjb250ZW50LnN1YnN0cmluZygwLCBlbmRPZmZzZXQpLmxhc3RJbmRleE9mKFwiXFxuXCIpICsgMTtcbiAgY29uc3QgZW5kQ29sID0gY29udGVudC5zdWJzdHJpbmcoZW5kTGluZVBvcywgZW5kT2Zmc2V0KS5sZW5ndGg7XG5cbiAgcmV0dXJuIHtcbiAgICBwb3NpdGlvbjoge1xuICAgICAgc3RhcnQ6IHsgbGluZTogc3RhcnRMaW5lLCBjb2w6IHN0YXJ0Q29sLCBvZmZzZXQ6IHN0YXJ0T2Zmc2V0IH0sXG4gICAgICBlbmQ6IHsgbGluZTogZW5kTGluZSwgY29sOiBlbmRDb2wsIG9mZnNldDogZW5kT2Zmc2V0IH0sXG4gICAgfSxcbiAgfTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGhpZ2hsaWdodEF0UG9zaXRpb25XaXRoUmVjYWxjdWxhdGluZ09mZnNldHMoXG4gIHBvc2l0aW9uOiBQb3MsXG4gIGNvbnRhaW5lclBvc2l0aW9uOiBQb3MsXG4gIHRleHQ6IHN0cmluZ1xuKSB7XG4gIGNvbnN0IGNvbnRhaW5lclN0YXJ0ID0gY29udGFpbmVyUG9zaXRpb24uc3RhcnQub2Zmc2V0O1xuICBjb25zdCBwb3NpdGlvbkxlbmd0aCA9IHBvc2l0aW9uLmVuZC5vZmZzZXQgLSBwb3NpdGlvbi5zdGFydC5vZmZzZXQ7XG5cbiAgY29uc3Qgc3RhcnRPZlBvc2l0aW9uSW5Db250YWluZXIgPSBwb3NpdGlvbi5zdGFydC5vZmZzZXQgLSBjb250YWluZXJTdGFydDtcbiAgY29uc3QgZW5kT2ZQb3NpdGlvbkluQ29udGFpbmVyID0gcG9zaXRpb25MZW5ndGggKyBzdGFydE9mUG9zaXRpb25JbkNvbnRhaW5lcjtcblxuICBjb25zdCBiZWZvcmVIaWdobGlnaHQgPSB0ZXh0LnN1YnN0cmluZygwLCBzdGFydE9mUG9zaXRpb25JbkNvbnRhaW5lcik7XG4gIGNvbnN0IGhpZ2hsaWdodCA9IHRleHQuc3Vic3RyaW5nKFxuICAgIHN0YXJ0T2ZQb3NpdGlvbkluQ29udGFpbmVyLFxuICAgIGVuZE9mUG9zaXRpb25JbkNvbnRhaW5lclxuICApO1xuICBjb25zdCBhZnRlckhpZ2hsaWdodCA9IHRleHQuc3Vic3RyaW5nKGVuZE9mUG9zaXRpb25JbkNvbnRhaW5lcik7XG5cbiAgcmV0dXJuIGAke2JlZm9yZUhpZ2hsaWdodH08c3BhbiBjbGFzcz1cInNlYXJjaC1yZXN1bHQtZmlsZS1tYXRjaGVkLXRleHRcIj4ke2hpZ2hsaWdodH08L3NwYW4+JHthZnRlckhpZ2hsaWdodH1gO1xufVxuIiwgImltcG9ydCB7IExpc3RJdGVtQ2FjaGUsIFBvcyB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgZG9lc1Bvc2l0aW9uSW5jbHVkZUFub3RoZXIgfSBmcm9tIFwiLi9wb3NpdGlvblwiO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGlzdEl0ZW1XaXRoRGVzY2VuZGFudHMoXG4gIGxpc3RJdGVtSW5kZXg6IG51bWJlcixcbiAgbGlzdEl0ZW1zOiBMaXN0SXRlbUNhY2hlW11cbikge1xuICBjb25zdCByb290TGlzdEl0ZW0gPSBsaXN0SXRlbXNbbGlzdEl0ZW1JbmRleF07XG4gIGNvbnN0IGxpc3RJdGVtV2l0aERlc2NlbmRhbnRzID0gW3Jvb3RMaXN0SXRlbV07XG5cbiAgZm9yIChsZXQgaSA9IGxpc3RJdGVtSW5kZXggKyAxOyBpIDwgbGlzdEl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgbmV4dEl0ZW0gPSBsaXN0SXRlbXNbaV07XG4gICAgaWYgKG5leHRJdGVtLnBhcmVudCA8IHJvb3RMaXN0SXRlbS5wb3NpdGlvbi5zdGFydC5saW5lKSB7XG4gICAgICByZXR1cm4gbGlzdEl0ZW1XaXRoRGVzY2VuZGFudHM7XG4gICAgfVxuICAgIGxpc3RJdGVtV2l0aERlc2NlbmRhbnRzLnB1c2gobmV4dEl0ZW0pO1xuICB9XG5cbiAgcmV0dXJuIGxpc3RJdGVtV2l0aERlc2NlbmRhbnRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGlzdEJyZWFkY3J1bWJzKHBvc2l0aW9uOiBQb3MsIGxpc3RJdGVtczogTGlzdEl0ZW1DYWNoZVtdKSB7XG4gIGNvbnN0IGxpc3RCcmVhZGNydW1iczogTGlzdEl0ZW1DYWNoZVtdID0gW107XG5cbiAgaWYgKGxpc3RJdGVtcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbGlzdEJyZWFkY3J1bWJzO1xuICB9XG5cbiAgY29uc3QgdGhpc0l0ZW1JbmRleCA9IGdldExpc3RJdGVtSW5kZXhDb250YWluaW5nKHBvc2l0aW9uLCBsaXN0SXRlbXMpO1xuICBjb25zdCBpc1Bvc2l0aW9uT3V0c2lkZUxpc3RJdGVtID0gdGhpc0l0ZW1JbmRleCA8IDA7XG5cbiAgaWYgKGlzUG9zaXRpb25PdXRzaWRlTGlzdEl0ZW0pIHtcbiAgICByZXR1cm4gbGlzdEJyZWFkY3J1bWJzO1xuICB9XG5cbiAgY29uc3QgdGhpc0l0ZW0gPSBsaXN0SXRlbXNbdGhpc0l0ZW1JbmRleF07XG4gIGxldCBjdXJyZW50UGFyZW50ID0gdGhpc0l0ZW0ucGFyZW50O1xuXG4gIGlmIChpc1RvcExldmVsTGlzdEl0ZW0odGhpc0l0ZW0pKSB7XG4gICAgcmV0dXJuIGxpc3RCcmVhZGNydW1icztcbiAgfVxuXG4gIGZvciAobGV0IGkgPSB0aGlzSXRlbUluZGV4IC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBjdXJyZW50SXRlbSA9IGxpc3RJdGVtc1tpXTtcblxuICAgIGNvbnN0IGN1cnJlbnRJdGVtSXNIaWdoZXJVcCA9IGN1cnJlbnRJdGVtLnBhcmVudCA8IGN1cnJlbnRQYXJlbnQ7XG4gICAgaWYgKGN1cnJlbnRJdGVtSXNIaWdoZXJVcCkge1xuICAgICAgbGlzdEJyZWFkY3J1bWJzLnVuc2hpZnQoY3VycmVudEl0ZW0pO1xuICAgICAgY3VycmVudFBhcmVudCA9IGN1cnJlbnRJdGVtLnBhcmVudDtcbiAgICB9XG5cbiAgICBpZiAoaXNUb3BMZXZlbExpc3RJdGVtKGN1cnJlbnRJdGVtKSkge1xuICAgICAgcmV0dXJuIGxpc3RCcmVhZGNydW1icztcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbGlzdEJyZWFkY3J1bWJzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNUb3BMZXZlbExpc3RJdGVtKGxpc3RJdGVtOiBMaXN0SXRlbUNhY2hlKSB7XG4gIHJldHVybiBsaXN0SXRlbS5wYXJlbnQgPCAwO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gZ2V0TGlzdEl0ZW1JbmRleENvbnRhaW5pbmcoXG4gIHNlYXJjaGVkRm9yUG9zaXRpb246IFBvcyxcbiAgbGlzdEl0ZW1zOiBMaXN0SXRlbUNhY2hlW11cbikge1xuICByZXR1cm4gbGlzdEl0ZW1zLmZpbmRJbmRleCgoeyBwb3NpdGlvbiB9KSA9PlxuICAgIGRvZXNQb3NpdGlvbkluY2x1ZGVBbm90aGVyKHBvc2l0aW9uLCBzZWFyY2hlZEZvclBvc2l0aW9uKVxuICApO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gaXNQb3NpdGlvbkluTGlzdChwb3NpdGlvbjogUG9zLCBsaXN0SXRlbXM6IExpc3RJdGVtQ2FjaGVbXSkge1xuICByZXR1cm4gZ2V0TGlzdEl0ZW1JbmRleENvbnRhaW5pbmcocG9zaXRpb24sIGxpc3RJdGVtcykgPj0gMDtcbn1cbiIsICJpbXBvcnQgeyB3cml0YWJsZSB9IGZyb20gXCJzdmVsdGUvc3RvcmVcIjtcblxuZXhwb3J0IGNvbnN0IHNldHRpbmdzID0gd3JpdGFibGUoe1xuICB6b29tTGV2ZWw6IDIsXG4gIHN0YXJ0SG91cjogMCxcbiAgY2VudGVyTmVlZGxlOiB0cnVlLFxuICB0aW1lbGluZURhdGVGb3JtYXQ6IFwiTExMTFwiLFxuICBwbGFubmVySGVhZGluZzogXCJEYXkgcGxhbm5lclwiLFxuICBwbGFubmVySGVhZGluZ0xldmVsOiAxLFxufSk7XG4iLCAiaW1wb3J0IHsgZGVyaXZlZCwgZ2V0LCB3cml0YWJsZSB9IGZyb20gXCJzdmVsdGUvc3RvcmVcIjtcbmltcG9ydCB7IFNOQVBfU1RFUF9NSU5VVEVTIH0gZnJvbSBcInNyYy9jb25zdGFudHNcIjtcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcIi4vc2V0dGluZ3NcIjtcbmltcG9ydCB0eXBlIHsgQXBwIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgdHlwZSB7IFBsYW5JdGVtIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCB0eXBlIFRpbWVzdGFtcCA9IHsgZHVyYXRpb25NaW51dGVzOiBudW1iZXI7IHN0YXJ0TWludXRlczogbnVtYmVyIH07XG5cbmV4cG9ydCBjb25zdCBhcHBTdG9yZSA9IHdyaXRhYmxlPEFwcD4oKTtcblxuZXhwb3J0IGNvbnN0IHRhc2tzID0gd3JpdGFibGU8UGxhbkl0ZW1bXT4oW10pO1xuXG5leHBvcnQgY29uc3QgaG91clNpemUgPSBkZXJpdmVkKFxuICBzZXR0aW5ncyxcbiAgKCRzZXR0aW5ncykgPT4gJHNldHRpbmdzLnpvb21MZXZlbCAqIDYwLFxuKTtcblxuZXhwb3J0IGNvbnN0IHZpc2libGVIb3VycyA9IGRlcml2ZWQoc2V0dGluZ3MsICgkc2V0dGluZ3MpID0+XG4gIFsuLi5BcnJheSgyNCkua2V5cygpXS5zbGljZSgkc2V0dGluZ3Muc3RhcnRIb3VyKSxcbik7XG5cbmV4cG9ydCBjb25zdCBoaWRkZW5Ib3Vyc1NpemUgPSBkZXJpdmVkKFxuICBbc2V0dGluZ3MsIGhvdXJTaXplXSxcbiAgKFskc2V0dGluZ3MsICRob3VyU2l6ZV0pID0+ICRzZXR0aW5ncy5zdGFydEhvdXIgKiAkaG91clNpemUsXG4pO1xuXG5leHBvcnQgY29uc3QgdGltZVRvVGltZWxpbmVPZmZzZXQgPSBkZXJpdmVkKFxuICBbc2V0dGluZ3MsIGhpZGRlbkhvdXJzU2l6ZV0sXG4gIChbJHNldHRpbmdzLCAkaGlkZGVuSG91cnNTaXplXSkgPT5cbiAgICAobWludXRlczogbnVtYmVyKSA9PlxuICAgICAgbWludXRlcyAqICRzZXR0aW5ncy56b29tTGV2ZWwgLSAkaGlkZGVuSG91cnNTaXplLFxuKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHJvdW5kVG9TbmFwU3RlcChjb29yZHM6IG51bWJlcikge1xuICBjb25zdCB7IHpvb21MZXZlbCB9ID0gZ2V0KHNldHRpbmdzKTtcbiAgcmV0dXJuIGNvb3JkcyAtIChjb29yZHMgJSAoU05BUF9TVEVQX01JTlVURVMgKiB6b29tTGV2ZWwpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRpbWVGcm9tWU9mZnNldCh5Q29vcmRzOiBudW1iZXIpIHtcbiAgY29uc3QgeyB6b29tTGV2ZWwgfSA9IGdldChzZXR0aW5ncyk7XG4gIHJldHVybiAoeUNvb3JkcyArIGdldChoaWRkZW5Ib3Vyc1NpemUpKSAvIHpvb21MZXZlbDtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNpemVUb0R1cmF0aW9uKHNpemU6IG51bWJlcikge1xuICBjb25zdCB7IHpvb21MZXZlbCB9ID0gZ2V0KHNldHRpbmdzKTtcbiAgcmV0dXJuIHNpemUgLyB6b29tTGV2ZWw7XG59XG5cbmV4cG9ydCBjb25zdCBkdXJhdGlvblRvU2l6ZSA9IGRlcml2ZWQoc2V0dGluZ3MsICgkc2V0dGluZ3MpID0+IHtcbiAgcmV0dXJuIChkdXJhdGlvbjogbnVtYmVyKSA9PiB7XG4gICAgY29uc3QgeyB6b29tTGV2ZWwgfSA9ICRzZXR0aW5ncztcbiAgICByZXR1cm4gZHVyYXRpb24gKiB6b29tTGV2ZWw7XG4gIH07XG59KTtcbiIsICJpbXBvcnQge1xuICBjcmVhdGVEYWlseU5vdGUsXG4gIGdldEFsbERhaWx5Tm90ZXMsXG4gIGdldERhaWx5Tm90ZSxcbn0gZnJvbSBcIm9ic2lkaWFuLWRhaWx5LW5vdGVzLWludGVyZmFjZVwiO1xuaW1wb3J0IHR5cGUgeyBURmlsZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY3JlYXRlRGFpbHlOb3RlSWZOZWVkZWQoKTogUHJvbWlzZTxURmlsZT4ge1xuICByZXR1cm4gZ2V0RGFpbHlOb3RlRm9yVG9kYXkoKSB8fCBjcmVhdGVEYWlseU5vdGUod2luZG93Lm1vbWVudCgpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldERhaWx5Tm90ZUZvclRvZGF5KCkge1xuICByZXR1cm4gZ2V0RGFpbHlOb3RlKHdpbmRvdy5tb21lbnQoKSwgZ2V0QWxsRGFpbHlOb3RlcygpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRhaWx5Tm90ZUV4aXN0cygpIHtcbiAgcmV0dXJuIEJvb2xlYW4oZ2V0RGFpbHlOb3RlKHdpbmRvdy5tb21lbnQoKSwgZ2V0QWxsRGFpbHlOb3RlcygpKSk7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBDYWNoZWRNZXRhZGF0YSwgTGlzdEl0ZW1DYWNoZSB9IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHsgcGFyc2VUaW1lc3RhbXAgfSBmcm9tIFwiLi4vdGltZXN0YW1wL3RpbWVzdGFtcFwiO1xuaW1wb3J0IHsgdGltZXN0YW1wUmVnRXhwIH0gZnJvbSBcIi4uL3JlZ2V4cFwiO1xuaW1wb3J0IHsgaXNUb3BMZXZlbExpc3RJdGVtIH0gZnJvbSBcIi4uLy4uL29ic2lkaWFuLW1ldGFkYXRhLXV0aWxzL3NyYy9saXN0XCI7XG5pbXBvcnQgeyBnZXRUZXh0QXRQb3NpdGlvbiB9IGZyb20gXCIuLi8uLi9vYnNpZGlhbi1tZXRhZGF0YS11dGlscy9zcmMvcG9zaXRpb25cIjtcbmltcG9ydCB7XG4gIGdldERpZmZJbk1pbnV0ZXMsXG4gIGdldE1pbnV0ZXNTaW5jZU1pZG5pZ2h0VG8sXG4gIG1pbnV0ZXNUb01vbWVudCxcbn0gZnJvbSBcIi4uL3V0aWwvbW9tZW50XCI7XG5pbXBvcnQgeyBERUZBVUxUX0RVUkFUSU9OX01JTlVURVMgfSBmcm9tIFwiLi4vY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBnZXRUaW1lRnJvbVlPZmZzZXQsIHJvdW5kVG9TbmFwU3RlcCB9IGZyb20gXCJzcmMvc3RvcmUvdGltZWxpbmUtc3RvcmVcIjtcbmltcG9ydCB7IGdldERhaWx5Tm90ZUZvclRvZGF5IH0gZnJvbSBcInNyYy91dGlsL2RhaWx5LW5vdGVzXCI7XG5pbXBvcnQgdHlwZSB7IFBsYW5JdGVtLCBQbGFuSXRlbUxvY2F0aW9uIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbi8vIHRvZG86IG91dCBvZiBwbGFjZVxuZXhwb3J0IGZ1bmN0aW9uIGNhbGN1bGF0ZURlZmF1bHREdXJhdGlvbihcbiAgaXRlbTogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlUGxhbkl0ZW0+LFxuICBuZXh0PzogUmV0dXJuVHlwZTx0eXBlb2YgY3JlYXRlUGxhbkl0ZW0+LFxuKSB7XG4gIGlmIChpdGVtLmVuZFRpbWUpIHtcbiAgICByZXR1cm4gZ2V0RGlmZkluTWludXRlcyhpdGVtLnN0YXJ0VGltZSwgaXRlbS5lbmRUaW1lKTtcbiAgfVxuXG4gIGlmIChuZXh0KSB7XG4gICAgY29uc3QgbWludXRlc1VudGlsTmV4dCA9IGdldERpZmZJbk1pbnV0ZXMobmV4dC5zdGFydFRpbWUsIGl0ZW0uc3RhcnRUaW1lKTtcblxuICAgIGlmIChtaW51dGVzVW50aWxOZXh0IDwgREVGQVVMVF9EVVJBVElPTl9NSU5VVEVTKSB7XG4gICAgICByZXR1cm4gbWludXRlc1VudGlsTmV4dDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gREVGQVVMVF9EVVJBVElPTl9NSU5VVEVTO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VQbGFuSXRlbXMoXG4gIGNvbnRlbnQ6IHN0cmluZyxcbiAgbWV0YWRhdGE6IENhY2hlZE1ldGFkYXRhLFxuICBwbGFuSGVhZGluZ0NvbnRlbnQ6IHN0cmluZyxcbiAgcGF0aDogc3RyaW5nLFxuKTogUGxhbkl0ZW1bXSB7XG4gIGNvbnN0IGxpc3RJdGVtc1VuZGVyUGxhbiA9IGdldExpc3RJdGVtc1VuZGVySGVhZGluZyhcbiAgICBtZXRhZGF0YSxcbiAgICBwbGFuSGVhZGluZ0NvbnRlbnQsXG4gICk7XG5cbiAgaWYgKCFsaXN0SXRlbXNVbmRlclBsYW4pIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBsaXN0SXRlbXNXaXRoQ29udGVudCA9IGdldExpc3RJdGVtQ29udGVudChjb250ZW50LCBsaXN0SXRlbXNVbmRlclBsYW4pO1xuXG4gIHJldHVybiBsaXN0SXRlbXNXaXRoQ29udGVudFxuICAgIC5tYXAoKGxpKSA9PlxuICAgICAgY3JlYXRlUGxhbkl0ZW0oe1xuICAgICAgICBsaW5lOiBsaS5saXN0SXRlbUxpbmVDb250ZW50LFxuICAgICAgICBsb2NhdGlvbjogeyBwYXRoLCBsaW5lOiBsaS5saW5lIH0sXG4gICAgICB9KSxcbiAgICApXG4gICAgLmZpbHRlcigoaXRlbSkgPT4gaXRlbSAhPT0gbnVsbClcbiAgICAubWFwKChpdGVtLCBpbmRleCwgaXRlbXMpID0+IHtcbiAgICAgIGNvbnN0IG5leHQgPSBpdGVtc1tpbmRleCArIDFdO1xuXG4gICAgICBjb25zdCBkdXJhdGlvbk1pbnV0ZXMgPSBjYWxjdWxhdGVEZWZhdWx0RHVyYXRpb24oaXRlbSwgbmV4dCk7XG5cbiAgICAgIGNvbnN0IGVuZFRpbWUgPVxuICAgICAgICBpdGVtLmVuZFRpbWUgfHwgaXRlbS5zdGFydFRpbWUuY2xvbmUoKS5hZGQoZHVyYXRpb25NaW51dGVzLCBcIm1pbnV0ZXNcIik7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIC4uLml0ZW0sXG4gICAgICAgIGVuZFRpbWUsXG4gICAgICAgIHN0YXJ0TWludXRlczogZ2V0TWludXRlc1NpbmNlTWlkbmlnaHRUbyhpdGVtLnN0YXJ0VGltZSksXG4gICAgICAgIGVuZE1pbnV0ZXM6IGdldE1pbnV0ZXNTaW5jZU1pZG5pZ2h0VG8oZW5kVGltZSksXG4gICAgICAgIGR1cmF0aW9uTWludXRlcyxcbiAgICAgIH07XG4gICAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMaXN0SXRlbXNVbmRlckhlYWRpbmcoXG4gIG1ldGFkYXRhOiBDYWNoZWRNZXRhZGF0YSxcbiAgaGVhZGluZzogc3RyaW5nLFxuKSB7XG4gIGNvbnN0IHsgaGVhZGluZ3MgfSA9IG1ldGFkYXRhO1xuXG4gIGlmICghaGVhZGluZ3MpIHtcbiAgICByZXR1cm4gW107XG4gIH1cblxuICBjb25zdCBwbGFuSGVhZGluZ0luZGV4ID0gaGVhZGluZ3MuZmluZEluZGV4KChoKSA9PiBoLmhlYWRpbmcgPT09IGhlYWRpbmcpO1xuXG4gIGlmIChwbGFuSGVhZGluZ0luZGV4IDwgMCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuXG4gIGNvbnN0IHBsYW5IZWFkaW5nID0gaGVhZGluZ3NbcGxhbkhlYWRpbmdJbmRleF07XG4gIGNvbnN0IG5leHRIZWFkaW5nT2ZTYW1lTGV2ZWwgPSBoZWFkaW5nc1xuICAgIC5zbGljZShwbGFuSGVhZGluZ0luZGV4ICsgMSlcbiAgICAuZmluZCgoaGVhZGluZykgPT4gaGVhZGluZy5sZXZlbCA8PSBwbGFuSGVhZGluZy5sZXZlbCk7XG5cbiAgcmV0dXJuIG1ldGFkYXRhLmxpc3RJdGVtcz8uZmlsdGVyKChsaSkgPT4ge1xuICAgIGNvbnN0IGlzQmVsb3dQbGFuID1cbiAgICAgIGxpLnBvc2l0aW9uLnN0YXJ0LmxpbmUgPiBwbGFuSGVhZGluZy5wb3NpdGlvbi5zdGFydC5saW5lO1xuICAgIGNvbnN0IGlzQWJvdmVOZXh0SGVhZGluZ0lmSXRFeGlzdHMgPVxuICAgICAgIW5leHRIZWFkaW5nT2ZTYW1lTGV2ZWwgfHxcbiAgICAgIGxpLnBvc2l0aW9uLnN0YXJ0LmxpbmUgPCBuZXh0SGVhZGluZ09mU2FtZUxldmVsLnBvc2l0aW9uLnN0YXJ0LmxpbmU7XG5cbiAgICByZXR1cm4gaXNCZWxvd1BsYW4gJiYgaXNBYm92ZU5leHRIZWFkaW5nSWZJdEV4aXN0cztcbiAgfSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRIZWFkaW5nQnlUZXh0KG1ldGFkYXRhOiBDYWNoZWRNZXRhZGF0YSwgdGV4dDogc3RyaW5nKSB7XG4gIGNvbnN0IHsgaGVhZGluZ3MgfSA9IG1ldGFkYXRhO1xuXG4gIHJldHVybiBoZWFkaW5ncz8uZmluZCgoaCkgPT4gaC5oZWFkaW5nID09PSB0ZXh0KTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUGxhbkl0ZW0oe1xuICBsaW5lLFxuICBsb2NhdGlvbixcbn06IHtcbiAgbGluZTogc3RyaW5nO1xuICBsb2NhdGlvbjogUGxhbkl0ZW1Mb2NhdGlvbjtcbn0pIHtcbiAgY29uc3QgbWF0Y2ggPSB0aW1lc3RhbXBSZWdFeHAuZXhlYyhsaW5lLnRyaW0oKSk7XG4gIGlmICghbWF0Y2gpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIGNvbnN0IHtcbiAgICBncm91cHM6IHsgbGlzdFRva2Vucywgc3RhcnQsIGVuZCwgdGV4dCB9LFxuICB9ID0gbWF0Y2g7XG5cbiAgcmV0dXJuIHtcbiAgICBsaXN0VG9rZW5zLFxuICAgIHN0YXJ0VGltZTogcGFyc2VUaW1lc3RhbXAoc3RhcnQpLFxuICAgIGVuZFRpbWU6IHBhcnNlVGltZXN0YW1wKGVuZCksXG4gICAgcmF3U3RhcnRUaW1lOiBzdGFydCxcbiAgICByYXdFbmRUaW1lOiBlbmQsXG4gICAgdGV4dCxcbiAgICBsb2NhdGlvbixcbiAgfTtcbn1cblxuZnVuY3Rpb24gZ3JvdXBUb3BMaXN0SXRlbXNXaXRoRGVzY2VuZGFudHMobGlzdEl0ZW1zOiBMaXN0SXRlbUNhY2hlW10pIHtcbiAgcmV0dXJuIGxpc3RJdGVtcy5yZWR1Y2UoKHJlc3VsdCwgY3VycmVudCkgPT4ge1xuICAgIGlmIChpc1RvcExldmVsTGlzdEl0ZW0oY3VycmVudCkpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHsgcm9vdDogY3VycmVudCwgZGVzY2VuZGFudHM6IFtdIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBwcmV2aW91c1RvcExpc3RJdGVtID0gcmVzdWx0W3Jlc3VsdC5sZW5ndGggLSAxXTtcbiAgICAgIHByZXZpb3VzVG9wTGlzdEl0ZW0uZGVzY2VuZGFudHMucHVzaChjdXJyZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9LCBbXSk7XG59XG5cbmZ1bmN0aW9uIGdldExpc3RJdGVtQ29udGVudChjb250ZW50OiBzdHJpbmcsIGxpc3RJdGVtczogTGlzdEl0ZW1DYWNoZVtdKSB7XG4gIHJldHVybiBncm91cFRvcExpc3RJdGVtc1dpdGhEZXNjZW5kYW50cyhsaXN0SXRlbXMpLm1hcChcbiAgICAoeyByb290LCBkZXNjZW5kYW50cyB9KSA9PiB7XG4gICAgICBjb25zdCBsYXN0RGVzY2VuZGFudFBvc2l0aW9uID1cbiAgICAgICAgZGVzY2VuZGFudHM/LltkZXNjZW5kYW50cy5sZW5ndGggLSAxXT8ucG9zaXRpb24/LmVuZDtcbiAgICAgIGNvbnN0IGJldHdlZW5Sb290QW5kTGFzdERlc2NlbmRhbnQgPSB7XG4gICAgICAgIHN0YXJ0OiByb290LnBvc2l0aW9uLnN0YXJ0LFxuICAgICAgICBlbmQ6IGxhc3REZXNjZW5kYW50UG9zaXRpb24gfHwgcm9vdC5wb3NpdGlvbi5lbmQsXG4gICAgICB9O1xuXG4gICAgICByZXR1cm4ge1xuICAgICAgICBsaW5lOiByb290LnBvc2l0aW9uLnN0YXJ0LmxpbmUsXG4gICAgICAgIGxpc3RJdGVtTGluZUNvbnRlbnQ6IGdldFRleHRBdFBvc2l0aW9uKGNvbnRlbnQsIHJvb3QucG9zaXRpb24pLFxuICAgICAgICBsaXN0SXRlbUNvbXBsZXRlQ29udGVudDogZ2V0VGV4dEF0UG9zaXRpb24oXG4gICAgICAgICAgY29udGVudCxcbiAgICAgICAgICBiZXR3ZWVuUm9vdEFuZExhc3REZXNjZW5kYW50LFxuICAgICAgICApLFxuICAgICAgfTtcbiAgICB9LFxuICApO1xufVxuXG4vLyB0b2RvOiBtb3ZlXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUGxhbkl0ZW1Gcm9tVGltZWxpbmUocG9pbnRlcllPZmZzZXQ6IG51bWJlcikge1xuICBjb25zdCBzdGFydE1pbnV0ZXMgPSBnZXRUaW1lRnJvbVlPZmZzZXQocm91bmRUb1NuYXBTdGVwKHBvaW50ZXJZT2Zmc2V0KSk7XG4gIGNvbnN0IGVuZE1pbnV0ZXMgPSBzdGFydE1pbnV0ZXMgKyBERUZBVUxUX0RVUkFUSU9OX01JTlVURVM7XG5cbiAgcmV0dXJuIHtcbiAgICBzdGFydE1pbnV0ZXMsXG4gICAgZHVyYXRpb25NaW51dGVzOiBERUZBVUxUX0RVUkFUSU9OX01JTlVURVMsXG4gICAgZW5kTWludXRlcyxcbiAgICB0ZXh0OiBcIk5ldyBpdGVtXCIsXG4gICAgc3RhcnRUaW1lOiBtaW51dGVzVG9Nb21lbnQoc3RhcnRNaW51dGVzKSxcbiAgICBlbmRUaW1lOiBtaW51dGVzVG9Nb21lbnQoZW5kTWludXRlcyksXG4gICAgLy8gdG9kbzogbm8gaGFyZGNvZGVcbiAgICBsaXN0VG9rZW5zOiBcIi0gXCIsXG4gICAgbG9jYXRpb246IHtcbiAgICAgIHBhdGg6IGdldERhaWx5Tm90ZUZvclRvZGF5KCkucGF0aCxcbiAgICB9LFxuICB9O1xufVxuIiwgImV4cG9ydCBjbGFzcyBEYXlQbGFubmVyU2V0dGluZ3Mge1xuICBjaXJjdWxhclByb2dyZXNzOiBib29sZWFuID0gZmFsc2U7XG4gIG5vd0FuZE5leHRJblN0YXR1c0JhcjogYm9vbGVhbiA9IGZhbHNlO1xuICBzaG93VGFza05vdGlmaWNhdGlvbjogYm9vbGVhbiA9IGZhbHNlO1xuICB6b29tTGV2ZWw6IG51bWJlciA9IDI7XG4gIHRpbWVsaW5lSWNvbjogc3RyaW5nID0gXCJjYWxlbmRhci13aXRoLWNoZWNrbWFya1wiO1xuICBlbmRMYWJlbDogc3RyaW5nID0gXCJBbGwgZG9uZVwiO1xuICBzdGFydEhvdXI6IG51bWJlciA9IDY7XG4gIHRpbWVsaW5lRGF0ZUZvcm1hdDogc3RyaW5nID0gXCJMTExMXCI7XG4gIGNlbnRlck5lZWRsZTogYm9vbGVhbiA9IHRydWU7XG4gIHBsYW5uZXJIZWFkaW5nOiBzdHJpbmcgPSBcIkRheSBwbGFubmVyXCI7XG4gIHBsYW5uZXJIZWFkaW5nTGV2ZWw6IG51bWJlciA9IDE7XG59XG4iLCAiaW1wb3J0IHsgQXBwLCBQbHVnaW5TZXR0aW5nVGFiLCBTZXR0aW5nIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgdHlwZSBEYXlQbGFubmVyIGZyb20gXCIuLi9tYWluXCI7XG5pbXBvcnQgeyBJQ09OUyB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcInNyYy9zdG9yZS9zZXR0aW5nc1wiO1xuXG5leHBvcnQgY2xhc3MgRGF5UGxhbm5lclNldHRpbmdzVGFiIGV4dGVuZHMgUGx1Z2luU2V0dGluZ1RhYiB7XG4gIHBsdWdpbjogRGF5UGxhbm5lcjtcblxuICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgcGx1Z2luOiBEYXlQbGFubmVyKSB7XG4gICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgIHRoaXMucGx1Z2luID0gcGx1Z2luO1xuICB9XG5cbiAgZGlzcGxheSgpOiB2b2lkIHtcbiAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgY29udGFpbmVyRWwuZW1wdHkoKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJTdGF0dXMgQmFyIC0gQ2lyY3VsYXIgUHJvZ3Jlc3NcIilcbiAgICAgIC5zZXREZXNjKFwiRGlzcGxheSBhIGNpcmN1bGFyIHByb2dyZXNzIGJhciBpbiB0aGUgc3RhdHVzIGJhclwiKVxuICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxuICAgICAgICB0b2dnbGVcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MuY2lyY3VsYXJQcm9ncmVzcylcbiAgICAgICAgICAub25DaGFuZ2UoKHZhbHVlOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5jaXJjdWxhclByb2dyZXNzID0gdmFsdWU7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIlN0YXR1cyBCYXIgLSBOb3cgYW5kIE5leHRcIilcbiAgICAgIC5zZXREZXNjKFwiRGlzcGxheSBub3cgYW5kIG5leHQgdGFza3MgaW4gdGhlIHN0YXR1cyBiYXJcIilcbiAgICAgIC5hZGRUb2dnbGUoKHRvZ2dsZSkgPT5cbiAgICAgICAgdG9nZ2xlXG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLm5vd0FuZE5leHRJblN0YXR1c0JhcilcbiAgICAgICAgICAub25DaGFuZ2UoKHZhbHVlOiBib29sZWFuKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5ub3dBbmROZXh0SW5TdGF0dXNCYXIgPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVEYXRhKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcbiAgICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiVGFzayBOb3RpZmljYXRpb25cIilcbiAgICAgIC5zZXREZXNjKFwiRGlzcGxheSBhIG5vdGlmaWNhdGlvbiB3aGVuIGEgbmV3IHRhc2sgaXMgc3RhcnRlZFwiKVxuICAgICAgLmFkZFRvZ2dsZSgodG9nZ2xlKSA9PlxuICAgICAgICB0b2dnbGVcbiAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hvd1Rhc2tOb3RpZmljYXRpb24pXG4gICAgICAgICAgLm9uQ2hhbmdlKCh2YWx1ZTogYm9vbGVhbikgPT4ge1xuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc2hvd1Rhc2tOb3RpZmljYXRpb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVEYXRhKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcbiAgICAgICAgICB9KSxcbiAgICAgICk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiVGltZWxpbmUgWm9vbSBMZXZlbFwiKVxuICAgICAgLnNldERlc2MoXG4gICAgICAgIFwiVGhlIHpvb20gbGV2ZWwgdG8gZGlzcGxheSB0aGUgdGltZWxpbmUuIFRoZSBoaWdoZXIgdGhlIG51bWJlciwgdGhlIG1vcmUgdmVydGljYWwgc3BhY2UgZWFjaCB0YXNrIHdpbGwgdGFrZSB1cC5cIixcbiAgICAgIClcbiAgICAgIC5hZGRTbGlkZXIoKHNsaWRlcikgPT5cbiAgICAgICAgc2xpZGVyXG4gICAgICAgICAgLnNldExpbWl0cygxLCA1LCAxKVxuICAgICAgICAgIC5zZXRWYWx1ZShOdW1iZXIodGhpcy5wbHVnaW4uc2V0dGluZ3Muem9vbUxldmVsKSA/PyA0KVxuICAgICAgICAgIC5zZXREeW5hbWljVG9vbHRpcCgpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICBzZXR0aW5ncy51cGRhdGUoKHNldHRpbmdzKSA9PiAoeyAuLi5zZXR0aW5ncywgem9vbUxldmVsOiB2YWx1ZSB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnpvb21MZXZlbCA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZURhdGEodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xuICAgICAgICAgIH0pLFxuICAgICAgKTtcblxuICAgIG5ldyBTZXR0aW5nKGNvbnRhaW5lckVsKVxuICAgICAgLnNldE5hbWUoXCJUaW1lbGluZSBJY29uXCIpXG4gICAgICAuc2V0RGVzYyhcbiAgICAgICAgXCJUaGUgaWNvbiBvZiB0aGUgdGltZWxpbmUgcGFuZS4gUmVvcGVuIHRpbWVsaW5lIHBhbmUgb3IgcmVzdGFydCBvYnNpZGlhbiB0byBzZWUgdGhlIGNoYW5nZS5cIixcbiAgICAgIClcbiAgICAgIC5hZGREcm9wZG93bigoZHJvcGRvd24pID0+IHtcbiAgICAgICAgSUNPTlMuZm9yRWFjaCgoaWNvbikgPT4gZHJvcGRvd24uYWRkT3B0aW9uKGljb24sIGljb24pKTtcbiAgICAgICAgcmV0dXJuIGRyb3Bkb3duXG4gICAgICAgICAgLnNldFZhbHVlKFxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudGltZWxpbmVJY29uID8/IFwiY2FsZW5kYXItd2l0aC1jaGVja21hcmtcIixcbiAgICAgICAgICApXG4gICAgICAgICAgLm9uQ2hhbmdlKCh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy50aW1lbGluZUljb24gPSB2YWx1ZTtcbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNhdmVEYXRhKHRoaXMucGx1Z2luLnNldHRpbmdzKTtcbiAgICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIlN0YXJ0IEhvdXJcIilcbiAgICAgIC5zZXREZXNjKFwiVGhlIHBsYW5uZXIgaXMgZ29pbmcgdG8gc3RhcnQgYXQgdGhpcyBob3VyIGVhY2ggZGF5XCIpXG4gICAgICAuYWRkRHJvcGRvd24oKGNvbXBvbmVudCkgPT5cbiAgICAgICAgY29tcG9uZW50XG4gICAgICAgICAgLmFkZE9wdGlvbnMoe1xuICAgICAgICAgICAgXCIwXCI6IFwiMFwiLFxuICAgICAgICAgICAgXCIxXCI6IFwiMVwiLFxuICAgICAgICAgICAgXCIyXCI6IFwiMlwiLFxuICAgICAgICAgICAgXCIzXCI6IFwiM1wiLFxuICAgICAgICAgICAgXCI0XCI6IFwiNFwiLFxuICAgICAgICAgICAgXCI1XCI6IFwiNVwiLFxuICAgICAgICAgICAgXCI2XCI6IFwiNlwiLFxuICAgICAgICAgICAgXCI3XCI6IFwiN1wiLFxuICAgICAgICAgICAgXCI4XCI6IFwiOFwiLFxuICAgICAgICAgICAgXCI5XCI6IFwiOVwiLFxuICAgICAgICAgICAgXCIxMFwiOiBcIjEwXCIsXG4gICAgICAgICAgICBcIjExXCI6IFwiMTFcIixcbiAgICAgICAgICAgIFwiMTJcIjogXCIxMlwiLFxuICAgICAgICAgIH0pXG4gICAgICAgICAgLnNldFZhbHVlKFN0cmluZyh0aGlzLnBsdWdpbi5zZXR0aW5ncy5zdGFydEhvdXIpKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWU6IHN0cmluZykgPT4ge1xuICAgICAgICAgICAgY29uc3QgYXNOdW1iZXIgPSBOdW1iZXIodmFsdWUpO1xuXG4gICAgICAgICAgICBzZXR0aW5ncy51cGRhdGUoKHByZXZpb3VzKSA9PiAoe1xuICAgICAgICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgICAgICAgc3RhcnRIb3VyOiBhc051bWJlcixcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3Muc3RhcnRIb3VyID0gYXNOdW1iZXI7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkRhdGUgRm9ybWF0IGluIFRpbWVsaW5lIEhlYWRlclwiKVxuICAgICAgLnRoZW4oKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICBjb21wb25lbnQuc2V0RGVzYyhcbiAgICAgICAgICBjcmVhdGVGcmFnbWVudCgoZnJhZ21lbnQpID0+IHtcbiAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZFRleHQoXCJZb3VyIGN1cnJlbnQgc3ludGF4IGxvb2tzIGxpa2UgdGhpczogXCIpO1xuICAgICAgICAgICAgY29tcG9uZW50LmFkZE1vbWVudEZvcm1hdCgobW9tZW50Rm9ybWF0KSA9PlxuICAgICAgICAgICAgICBtb21lbnRGb3JtYXRcbiAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MudGltZWxpbmVEYXRlRm9ybWF0KVxuICAgICAgICAgICAgICAgIC5zZXRTYW1wbGVFbChmcmFnbWVudC5jcmVhdGVTcGFuKCkpXG4gICAgICAgICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZTogc3RyaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICBzZXR0aW5ncy51cGRhdGUoKHByZXZpb3VzKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAuLi5wcmV2aW91cyxcbiAgICAgICAgICAgICAgICAgICAgdGltZWxpbmVEYXRlRm9ybWF0OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MudGltZWxpbmVEYXRlRm9ybWF0ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kKFxuICAgICAgICAgICAgICBjcmVhdGVFbChcImJyXCIpLFxuICAgICAgICAgICAgICBjcmVhdGVFbChcbiAgICAgICAgICAgICAgICBcImFcIixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICB0ZXh0OiBcImZvcm1hdCByZWZlcmVuY2VcIixcbiAgICAgICAgICAgICAgICAgIGhyZWY6IFwiaHR0cHM6Ly9tb21lbnRqcy5jb20vZG9jcy8jL2Rpc3BsYXlpbmcvZm9ybWF0L1wiLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGEpID0+IHtcbiAgICAgICAgICAgICAgICAgIGEuc2V0QXR0cihcInRhcmdldFwiLCBcIl9ibGFua1wiKTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KSxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIkNlbnRlciB0aGUgUG9pbnRlciBpbiB0aGUgVGltZWxpbmUgVmlld1wiKVxuICAgICAgLnNldERlc2MoXG4gICAgICAgIFwiU2hvdWxkIHRoZSBwb2ludGVyIGNvbnRpbnVvdXNseSBnZXQgc2Nyb2xsZWQgdG8gdGhlIGNlbnRlciBvZiB0aGUgdmlld1wiLFxuICAgICAgKVxuICAgICAgLmFkZFRvZ2dsZSgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgIGNvbXBvbmVudFxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5jZW50ZXJOZWVkbGUpXG4gICAgICAgICAgLm9uQ2hhbmdlKGFzeW5jICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgc2V0dGluZ3MudXBkYXRlKChwcmV2aW91cykgPT4gKHtcbiAgICAgICAgICAgICAgLi4ucHJldmlvdXMsXG4gICAgICAgICAgICAgIGNlbnRlck5lZWRsZTogdmFsdWUsXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLmNlbnRlck5lZWRsZSA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZURhdGEodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICBuZXcgU2V0dGluZyhjb250YWluZXJFbClcbiAgICAgIC5zZXROYW1lKFwiUGxhbm5lciBIZWFkaW5nXCIpXG4gICAgICAuc2V0RGVzYyhcbiAgICAgICAgYFdoZW4geW91IGNyZWF0ZSBhIHBsYW5uZXIsIHRoaXMgdGV4dCBpcyBnb2luZyB0byBiZSBpbiB0aGUgaGVhZGluZy5cbldoZW4geW91IG9wZW4gYSBmaWxlLCB0aGUgcGx1Z2luIHdpbGwgc2VhcmNoIGZvciB0aGlzIGhlYWRpbmcgdG8gZGV0ZWN0IGEgZGF5IHBsYW5gLFxuICAgICAgKVxuICAgICAgLmFkZFRleHQoKGNvbXBvbmVudCkgPT5cbiAgICAgICAgY29tcG9uZW50XG4gICAgICAgICAgLnNldFZhbHVlKHRoaXMucGx1Z2luLnNldHRpbmdzLnBsYW5uZXJIZWFkaW5nKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHNldHRpbmdzLnVwZGF0ZSgocHJldmlvdXMpID0+ICh7XG4gICAgICAgICAgICAgIC4uLnByZXZpb3VzLFxuICAgICAgICAgICAgICBwbGFubmVySGVhZGluZzogdmFsdWUsXG4gICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIHRoaXMucGx1Z2luLnNldHRpbmdzLnBsYW5uZXJIZWFkaW5nID0gdmFsdWU7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLnBsdWdpbi5zYXZlRGF0YSh0aGlzLnBsdWdpbi5zZXR0aW5ncyk7XG4gICAgICAgICAgfSksXG4gICAgICApO1xuXG4gICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAuc2V0TmFtZShcIlBsYW5uZXIgaGVhZGluZyBsZXZlbFwiKVxuICAgICAgLnNldERlc2MoXG4gICAgICAgIFwiV2hlbiB5b3UgY3JlYXRlIGEgcGxhbm5lciBpbiBhIGZpbGUsIHRoaXMgbGV2ZWwgb2YgaGVhZGluZyBpcyBnb2luZyB0byBiZSB1c2VkXCIsXG4gICAgICApXG4gICAgICAuYWRkU2xpZGVyKChjb21wb25lbnQpID0+XG4gICAgICAgIGNvbXBvbmVudFxuICAgICAgICAgIC5zZXRMaW1pdHMoMSwgNiwgMSlcbiAgICAgICAgICAuc2V0RHluYW1pY1Rvb2x0aXAoKVxuICAgICAgICAgIC5zZXRWYWx1ZSh0aGlzLnBsdWdpbi5zZXR0aW5ncy5wbGFubmVySGVhZGluZ0xldmVsKVxuICAgICAgICAgIC5vbkNoYW5nZShhc3luYyAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHNldHRpbmdzLnVwZGF0ZSgocHJldmlvdXMpID0+ICh7XG4gICAgICAgICAgICAgIC4uLnByZXZpb3VzLFxuICAgICAgICAgICAgICBwbGFubmVySGVhZGluZ0xldmVsOiB2YWx1ZSxcbiAgICAgICAgICAgIH0pKTtcblxuICAgICAgICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MucGxhbm5lckhlYWRpbmdMZXZlbCA9IHZhbHVlO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZURhdGEodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xuICAgICAgICAgIH0pLFxuICAgICAgKTtcbiAgfVxuXG4gIHByaXZhdGUgbW9kZURlc2NyaXB0aW9uQ29udGVudCgpOiBEb2N1bWVudEZyYWdtZW50IHtcbiAgICBjb25zdCBkZXNjRWwgPSBkb2N1bWVudC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCk7XG4gICAgZGVzY0VsLmFwcGVuZFRleHQoXCJDaG9vc2UgYmV0d2VlbiAzIG1vZGVzIHRvIHVzZSB0aGUgRGF5IFBsYW5uZXIgcGx1Z2luOlwiKTtcbiAgICBkZXNjRWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICBkZXNjRWxcbiAgICAgIC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3Ryb25nXCIpKVxuICAgICAgLmFwcGVuZFRleHQoXCJGaWxlIG1vZGVcIik7XG4gICAgZGVzY0VsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgZGVzY0VsLmFwcGVuZFRleHQoXG4gICAgICBcIlBsdWdpbiBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBkYXkgcGxhbm5lciBub3RlcyBmb3IgZWFjaCBkYXkgd2l0aGluIGEgRGF5IFBsYW5uZXJzIGZvbGRlci5cIixcbiAgICApO1xuICAgIGRlc2NFbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgIGRlc2NFbFxuICAgICAgLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHJvbmdcIikpXG4gICAgICAuYXBwZW5kVGV4dChcIkNvbW1hbmQgbW9kZVwiKTtcbiAgICBkZXNjRWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICBkZXNjRWwuYXBwZW5kVGV4dChcbiAgICAgIFwiQ29tbWFuZCB1c2VkIHRvIGluc2VydCBhIERheSBQbGFubmVyIGZvciB0b2RheSB3aXRoaW4gdGhlIGN1cnJlbnQgbm90ZS5cIixcbiAgICApO1xuICAgIGRlc2NFbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgIGRlc2NFbFxuICAgICAgLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHJvbmdcIikpXG4gICAgICAuYXBwZW5kVGV4dChcIkRhaWx5IG1vZGVcIik7XG4gICAgZGVzY0VsLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKSk7XG4gICAgZGVzY0VsLmFwcGVuZFRleHQoXG4gICAgICBcIlBsdWdpbiBhdXRvbWF0aWNhbGx5IGxpbmtzIHRvIHRoZSBjdXJyZW50IGRhaWx5IG5vdGUuIERhaWx5IG5vdGVzIHBsdWdpbiBtdXN0IGJlIGVuYWJsZWQuXCIsXG4gICAgKTtcbiAgICBkZXNjRWwuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICB0aGlzLmFkZERvY3NMaW5rKGRlc2NFbCk7XG4gICAgcmV0dXJuIGRlc2NFbDtcbiAgfVxuXG4gIHByaXZhdGUgYWRkRG9jc0xpbmsoZGVzY0VsOiBEb2N1bWVudEZyYWdtZW50KSB7XG4gICAgY29uc3QgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJhXCIpO1xuICAgIGEuaHJlZiA9XG4gICAgICBcImh0dHBzOi8vZ2l0aHViLmNvbS9seW5jaGphbWVzL29ic2lkaWFuLWRheS1wbGFubmVyL2Jsb2IvbWFpbi9SRUFETUUubWRcIjtcbiAgICBhLnRleHQgPSBcInBsdWdpbiBSRUFETUVcIjtcbiAgICBhLnRhcmdldCA9IFwiX2JsYW5rXCI7XG4gICAgZGVzY0VsLmFwcGVuZENoaWxkKGEpO1xuICAgIGRlc2NFbC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICB9XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBXb3Jrc3BhY2UgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB0eXBlIHsgRGF5UGxhbm5lclNldHRpbmdzIH0gZnJvbSBcIi4uL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBnZXREaWZmSW5NaW51dGVzIH0gZnJvbSBcIi4uL3V0aWwvbW9tZW50XCI7XG5pbXBvcnQgdHlwZSB7IFBsYW5JdGVtIH0gZnJvbSBcIi4uL3R5cGVzXCI7XG5cbmV4cG9ydCBjbGFzcyBTdGF0dXNCYXIge1xuICBwcml2YXRlIHN0YXR1c0JhclRleHQ6IEhUTUxTcGFuRWxlbWVudDtcbiAgcHJpdmF0ZSBuZXh0VGV4dDogSFRNTFNwYW5FbGVtZW50O1xuICBwcml2YXRlIHN0YXR1c0JhclByb2dyZXNzOiBIVE1MRGl2RWxlbWVudDtcbiAgcHJpdmF0ZSBzdGF0dXNCYXJDdXJyZW50UHJvZ3Jlc3M6IEhUTUxEaXZFbGVtZW50O1xuICBwcml2YXRlIGNpcmNsZTogSFRNTERpdkVsZW1lbnQ7XG4gIHByaXZhdGUgY2FyZDogSFRNTERpdkVsZW1lbnQ7XG4gIHByaXZhdGUgY2FyZEN1cnJlbnQ6IEhUTUxTcGFuRWxlbWVudDtcbiAgcHJpdmF0ZSBjYXJkTmV4dDogSFRNTFNwYW5FbGVtZW50O1xuICBwcml2YXRlIGN1cnJlbnRUaW1lOiBzdHJpbmc7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSByZWFkb25seSBzZXR0aW5nczogRGF5UGxhbm5lclNldHRpbmdzLFxuICAgIHByaXZhdGUgcmVhZG9ubHkgY29udGFpbmVyRWw6IEhUTUxFbGVtZW50LFxuICAgIHByaXZhdGUgcmVhZG9ubHkgd29ya3NwYWNlOiBXb3Jrc3BhY2UsXG4gICkge1xuICAgIC8vIHRvZG86IHRoaXMgaXMgcmVkdW5kYW50XG4gICAgdGhpcy5jb250YWluZXJFbC5hZGRDbGFzcyhcImRheS1wbGFubmVyXCIpO1xuXG4gICAgdGhpcy5zZXR1cENhcmQoKTtcbiAgICB0aGlzLnN0YXR1c0JhclRleHQgPSB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZUVsKFwic3BhblwiLCB7XG4gICAgICBjbHM6IFtcInN0YXR1cy1iYXItaXRlbS1zZWdtZW50XCIsIFwiZGF5LXBsYW5uZXItc3RhdHVzLWJhci10ZXh0XCJdLFxuICAgIH0pO1xuXG4gICAgdGhpcy5zZXR1cENpcmN1bGFyUHJvZ3Jlc3NCYXIoKTtcbiAgICB0aGlzLnNldHVwSG9yaXpvbnRhbFByb2dyZXNzQmFyKCk7XG5cbiAgICB0aGlzLm5leHRUZXh0ID0gdGhpcy5jb250YWluZXJFbC5jcmVhdGVFbChcInNwYW5cIiwge1xuICAgICAgY2xzOiBbXCJzdGF0dXMtYmFyLWl0ZW0tc2VnbWVudFwiLCBcImRheS1wbGFubmVyLXN0YXR1cy1iYXItdGV4dFwiXSxcbiAgICB9KTtcblxuICAgIHRoaXMuc2V0dXBTdGF0dXNCYXJFdmVudHMoKTtcbiAgfVxuXG4gIGFzeW5jIHVwZGF0ZShwbGFuSXRlbXM6IFBsYW5JdGVtW10pIHtcbiAgICB0aGlzLmNvbnRhaW5lckVsLnNob3coKTtcbiAgICBpZiAocGxhbkl0ZW1zLmxlbmd0aCA+IDApIHtcbiAgICAgIHRoaXMudXBkYXRlUHJvZ3Jlc3MocGxhbkl0ZW1zKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRFbXB0eSgpO1xuICAgIH1cbiAgfVxuXG4gIHNldEVtcHR5KCkge1xuICAgIHRoaXMuc2V0VGV4dChcIk5vIHBsYW4gZm9yIHRvZGF5XCIpO1xuICB9XG5cbiAgc2V0VGV4dCh0ZXh0OiBzdHJpbmcpIHtcbiAgICB0aGlzLnN0YXR1c0JhclRleHQudGV4dENvbnRlbnQgPSB0ZXh0O1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cFN0YXR1c0JhckV2ZW50cygpIHtcbiAgICB0aGlzLmNvbnRhaW5lckVsLm9uQ2xpY2tFdmVudChhc3luYyAoKSA9PiB7XG4gICAgICAvLyB0b2RvOiBvcGVuIGRhaWx5IG5vdGVcbiAgICB9KTtcblxuICAgIHRoaXMuY29udGFpbmVyRWwub24oXCJtb3VzZWVudGVyXCIsIFwiLmRheS1wbGFubmVyXCIsICgpID0+IHtcbiAgICAgIHRoaXMuY2FyZC5zaG93KCk7XG4gICAgfSk7XG5cbiAgICB0aGlzLmNvbnRhaW5lckVsLm9uKFwibW91c2VsZWF2ZVwiLCBcIi5kYXktcGxhbm5lclwiLCAoKSA9PiB7XG4gICAgICB0aGlzLmNhcmQuaGlkZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBoaWRlUHJvZ3Jlc3MoKSB7XG4gICAgdGhpcy5zdGF0dXNCYXJQcm9ncmVzcy5oaWRlKCk7XG4gICAgdGhpcy5jaXJjbGUuaGlkZSgpO1xuICAgIHRoaXMubmV4dFRleHQuaGlkZSgpO1xuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVQcm9ncmVzcyhwbGFuSXRlbXM6IFBsYW5JdGVtW10pIHtcbiAgICBjb25zdCBub3cgPSB3aW5kb3cubW9tZW50KCk7XG5cbiAgICBjb25zdCBjdXJyZW50SXRlbUluZGV4ID0gcGxhbkl0ZW1zLmZpbmRJbmRleChcbiAgICAgIChpdGVtKSA9PiBpdGVtLnN0YXJ0VGltZS5pc0JlZm9yZShub3cpICYmIGl0ZW0uZW5kVGltZS5pc0FmdGVyKG5vdyksXG4gICAgKTtcblxuICAgIGlmIChjdXJyZW50SXRlbUluZGV4IDwgMCkge1xuICAgICAgdGhpcy5oaWRlUHJvZ3Jlc3MoKTtcbiAgICAgIHRoaXMuc3RhdHVzQmFyVGV4dC5pbm5lclRleHQgPSB0aGlzLnNldHRpbmdzLmVuZExhYmVsO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIHRvZG86IG1vdmUgY2FsY3VsYXRpb25zIG91dFxuICAgIGNvbnN0IGN1cnJlbnRJdGVtID0gcGxhbkl0ZW1zW2N1cnJlbnRJdGVtSW5kZXhdO1xuICAgIGNvbnN0IG5leHRJdGVtID0gcGxhbkl0ZW1zW2N1cnJlbnRJdGVtSW5kZXggKyAxXTtcblxuICAgIGNvbnN0IG1pbnV0ZXNGcm9tU3RhcnQgPSBnZXREaWZmSW5NaW51dGVzKGN1cnJlbnRJdGVtLnN0YXJ0VGltZSwgbm93KTtcbiAgICBjb25zdCBwZXJjZW50YWdlQ29tcGxldGUgPVxuICAgICAgbWludXRlc0Zyb21TdGFydCAvIChjdXJyZW50SXRlbS5kdXJhdGlvbk1pbnV0ZXMgLyAxMDApO1xuXG4gICAgdGhpcy51cGRhdGVTdGF0dXNCYXJUZXh0KGN1cnJlbnRJdGVtLCBuZXh0SXRlbSk7XG5cbiAgICBpZiAobmV4dEl0ZW0pIHtcbiAgICAgIHRoaXMuc2V0U3RhdHVzVGV4dChcbiAgICAgICAgZ2V0RGlmZkluTWludXRlcyhub3csIG5leHRJdGVtLnN0YXJ0VGltZSksXG4gICAgICAgIGN1cnJlbnRJdGVtLFxuICAgICAgICBuZXh0SXRlbSxcbiAgICAgICAgcGVyY2VudGFnZUNvbXBsZXRlLFxuICAgICAgKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5zZXR0aW5ncy5jaXJjdWxhclByb2dyZXNzKSB7XG4gICAgICB0aGlzLnN0YXR1c0JhclByb2dyZXNzLmhpZGUoKTtcbiAgICAgIHRoaXMucHJvZ3Jlc3NDaXJjbGUocGVyY2VudGFnZUNvbXBsZXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jaXJjbGUuaGlkZSgpO1xuICAgICAgdGhpcy5wcm9ncmVzc0JhcihwZXJjZW50YWdlQ29tcGxldGUpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgcHJvZ3Jlc3NCYXIocGVyY2VudGFnZUNvbXBsZXRlOiBudW1iZXIpIHtcbiAgICB0aGlzLnN0YXR1c0JhckN1cnJlbnRQcm9ncmVzcy5zdHlsZS53aWR0aCA9IGAke3BlcmNlbnRhZ2VDb21wbGV0ZX0lYDtcbiAgICB0aGlzLnN0YXR1c0JhclByb2dyZXNzLnNob3coKTtcbiAgfVxuXG4gIHByaXZhdGUgcHJvZ3Jlc3NDaXJjbGUocGVyY2VudGFnZUNvbXBsZXRlOiBudW1iZXIpIHtcbiAgICB0aGlzLmNpcmNsZS5zZXRBdHRyKFwiZGF0YS12YWx1ZVwiLCBwZXJjZW50YWdlQ29tcGxldGUudG9GaXhlZCgwKSk7XG4gICAgdGhpcy5jaXJjbGUuc2hvdygpO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXRTdGF0dXNUZXh0KFxuICAgIG1pbnNVbnRpbE5leHQ6IG51bWJlcixcbiAgICBjdXJyZW50OiBQbGFuSXRlbSxcbiAgICBuZXh0OiBQbGFuSXRlbSxcbiAgICBwZXJjZW50YWdlQ29tcGxldGU6IG51bWJlcixcbiAgKSB7XG4gICAgY29uc3QgbWluc1VudGlsTmV4dFRleHQgPSBtaW5zVW50aWxOZXh0ID09PSAwID8gXCIxXCIgOiBtaW5zVW50aWxOZXh0O1xuICAgIGNvbnN0IG1pbnNUZXh0ID0gYCR7bWluc1VudGlsTmV4dFRleHR9IG1pbiR7XG4gICAgICBtaW5zVW50aWxOZXh0VGV4dCA9PT0gXCIxXCIgPyBcIlwiIDogXCJzXCJcbiAgICB9YDtcblxuICAgIGNvbnN0IHBlcmNlbnQgPSBwZXJjZW50YWdlQ29tcGxldGUudG9GaXhlZCgwKTtcbiAgICBjb25zdCBjdXJyZW50VGFza1N0YXR1cyA9IGBDdXJyZW50IFRhc2sgKCR7cGVyY2VudH0lIGNvbXBsZXRlKWA7XG5cbiAgICAvLyB0b2RvOiB0aGlzIGlzIG91dCBvZiBwbGFjZVxuICAgIGNvbnN0IGN1cnJlbnRUYXNrVGltZUFuZFRleHQgPSBgJHtjdXJyZW50LnJhd1N0YXJ0VGltZX0gJHtjdXJyZW50LnRleHR9YDtcbiAgICBjb25zdCBuZXh0VGFzayA9IGBOZXh0IFRhc2sgKGluICR7bWluc1RleHR9KWA7XG4gICAgY29uc3QgbmV4dFRhc2tUaW1lQW5kVGV4dCA9IGAke25leHQucmF3U3RhcnRUaW1lfSAke25leHQudGV4dH1gO1xuXG4gICAgdGhpcy5jYXJkQ3VycmVudC50ZXh0Q29udGVudCA9IGAke2N1cnJlbnRUYXNrU3RhdHVzfTogJHtjdXJyZW50VGFza1RpbWVBbmRUZXh0fWA7XG4gICAgdGhpcy5jYXJkTmV4dC50ZXh0Q29udGVudCA9IGAke25leHRUYXNrfTogJHtuZXh0VGFza1RpbWVBbmRUZXh0fWA7XG5cbiAgICAvLyB0b2RvOiB0aGlzIGlzIG91dCBvZiBwbGFjZVxuICAgIHRoaXMudGFza05vdGlmaWNhdGlvbihcbiAgICAgIGN1cnJlbnQsXG4gICAgICBjdXJyZW50VGFza1RpbWVBbmRUZXh0LFxuICAgICAgbmV4dFRhc2ssXG4gICAgICBuZXh0VGFza1RpbWVBbmRUZXh0LFxuICAgICk7XG4gIH1cblxuICBwcml2YXRlIHVwZGF0ZVN0YXR1c0JhclRleHQoY3VycmVudEl0ZW06IFBsYW5JdGVtLCBuZXh0SXRlbT86IFBsYW5JdGVtKSB7XG4gICAgaWYgKHRoaXMuc2V0dGluZ3Mubm93QW5kTmV4dEluU3RhdHVzQmFyKSB7XG4gICAgICB0aGlzLnN0YXR1c0JhclRleHQudGV4dENvbnRlbnQgPSBgTm93OiAke1xuICAgICAgICBjdXJyZW50SXRlbS5yYXdTdGFydFRpbWVcbiAgICAgIH0gJHt0aGlzLmVsbGlwc2lzKGN1cnJlbnRJdGVtLnRleHQsIDE1KX1gO1xuXG4gICAgICBpZiAobmV4dEl0ZW0pIHtcbiAgICAgICAgdGhpcy5uZXh0VGV4dC50ZXh0Q29udGVudCA9IGBOZXh0OiAke1xuICAgICAgICAgIG5leHRJdGVtLnJhd1N0YXJ0VGltZVxuICAgICAgICB9ICR7dGhpcy5lbGxpcHNpcyhuZXh0SXRlbS50ZXh0LCAxNSl9YDtcblxuICAgICAgICB0aGlzLm5leHRUZXh0LnNob3coKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZXh0VGV4dC5oaWRlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMubmV4dFRleHQuaGlkZSgpO1xuICAgICAgY29uc3QgbWludXRlc0xlZnQgPSBnZXREaWZmSW5NaW51dGVzKFxuICAgICAgICBjdXJyZW50SXRlbS5lbmRUaW1lLFxuICAgICAgICB3aW5kb3cubW9tZW50KCksXG4gICAgICApO1xuICAgICAgdGhpcy5zdGF0dXNCYXJUZXh0LnRleHRDb250ZW50ID0gYE1pbnV0ZXMgbGVmdDogJHttaW51dGVzTGVmdH1gO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdGFza05vdGlmaWNhdGlvbihcbiAgICBjdXJyZW50OiBQbGFuSXRlbSxcbiAgICBjdXJyZW50VGFza1RpbWVBbmRUZXh0OiBzdHJpbmcsXG4gICAgbmV4dFRhc2s6IHN0cmluZyxcbiAgICBuZXh0VGFza1RleHQ6IHN0cmluZyxcbiAgKSB7XG4gICAgaWYgKFxuICAgICAgdGhpcy5zZXR0aW5ncy5zaG93VGFza05vdGlmaWNhdGlvbiAmJlxuICAgICAgdGhpcy5jdXJyZW50VGltZSAhPT0gdW5kZWZpbmVkICYmXG4gICAgICB0aGlzLmN1cnJlbnRUaW1lICE9PSBjdXJyZW50LnN0YXJ0VGltZS50b1N0cmluZygpXG4gICAgKSB7XG4gICAgICBuZXcgTm90aWZpY2F0aW9uKGBUYXNrIHN0YXJ0ZWQsICR7Y3VycmVudFRhc2tUaW1lQW5kVGV4dH1gLCB7XG4gICAgICAgIGJvZHk6IGAke25leHRUYXNrfTogJHtuZXh0VGFza1RleHR9YCxcbiAgICAgICAgcmVxdWlyZUludGVyYWN0aW9uOiB0cnVlLFxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFRpbWUgPSBjdXJyZW50LnN0YXJ0VGltZS50b1N0cmluZygpO1xuICB9XG5cbiAgLy8gdG9kbzogdGhpcyBkb2Vzbid0IGJlbG9uZyB0byB0aGUgY2xhc3NcbiAgcHJpdmF0ZSBlbGxpcHNpcyhpbnB1dDogc3RyaW5nLCBsaW1pdDogbnVtYmVyKSB7XG4gICAgaWYgKGlucHV0Lmxlbmd0aCA8PSBsaW1pdCkge1xuICAgICAgcmV0dXJuIGlucHV0O1xuICAgIH1cbiAgICByZXR1cm4gaW5wdXQuc3Vic3RyaW5nKDAsIGxpbWl0KSArIFwiLi4uXCI7XG4gIH1cblxuICBwcml2YXRlIHNldHVwSG9yaXpvbnRhbFByb2dyZXNzQmFyKCkge1xuICAgIHRoaXMuc3RhdHVzQmFyUHJvZ3Jlc3MgPSB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgIGNsczogW1wic3RhdHVzLWJhci1pdGVtLXNlZ21lbnRcIiwgXCJkYXktcGxhbm5lci1wcm9ncmVzcy1iYXJcIl0sXG4gICAgfSk7XG4gICAgdGhpcy5zdGF0dXNCYXJQcm9ncmVzcy5oaWRlKCk7XG4gICAgdGhpcy5zdGF0dXNCYXJDdXJyZW50UHJvZ3Jlc3MgPSB0aGlzLnN0YXR1c0JhclByb2dyZXNzLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgIGNsczogXCJkYXktcGxhbm5lci1wcm9ncmVzcy12YWx1ZVwiLFxuICAgIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBzZXR1cENpcmN1bGFyUHJvZ3Jlc3NCYXIoKSB7XG4gICAgdGhpcy5jaXJjbGUgPSB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgIGNsczogW1wic3RhdHVzLWJhci1pdGVtLXNlZ21lbnRcIiwgXCJwcm9ncmVzcy1waWUgZGF5LXBsYW5uZXJcIl0sXG4gICAgfSk7XG4gIH1cblxuICBwcml2YXRlIHNldHVwQ2FyZCgpIHtcbiAgICB0aGlzLmNhcmQgPSB0aGlzLmNvbnRhaW5lckVsLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgIGNsczogXCJkYXktcGxhbm5lci1zdGF0dXMtY2FyZFwiLFxuICAgIH0pO1xuXG4gICAgdGhpcy5jYXJkQ3VycmVudCA9IHRoaXMuY2FyZC5jcmVhdGVFbChcInNwYW5cIik7XG5cbiAgICB0aGlzLmNhcmQuY3JlYXRlRWwoXCJiclwiKTtcbiAgICB0aGlzLmNhcmQuY3JlYXRlRWwoXCJiclwiKTtcblxuICAgIHRoaXMuY2FyZE5leHQgPSB0aGlzLmNhcmQuY3JlYXRlRWwoXCJzcGFuXCIpO1xuXG4gICAgdGhpcy5jYXJkLmNyZWF0ZUVsKFwiZGl2XCIsIHsgY2xzOiBcImFycm93LWRvd25cIiB9KTtcbiAgfVxufVxuIiwgImltcG9ydCB7IEl0ZW1WaWV3LCBXb3Jrc3BhY2VMZWFmIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgVGltZWxpbmUgZnJvbSBcIi4vY29tcG9uZW50cy90aW1lbGluZS5zdmVsdGVcIjtcbmltcG9ydCB7IGFwcFN0b3JlIH0gZnJvbSBcIi4uL3N0b3JlL3RpbWVsaW5lLXN0b3JlXCI7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJzcmMvc3RvcmUvc2V0dGluZ3NcIjtcbmltcG9ydCB7IFZJRVdfVFlQRV9USU1FTElORSB9IGZyb20gXCIuLi9jb25zdGFudHNcIjtcbmltcG9ydCB0eXBlIHsgRGF5UGxhbm5lclNldHRpbmdzIH0gZnJvbSBcIi4uL3NldHRpbmdzXCI7XG5pbXBvcnQgdHlwZSBEYXlQbGFubmVyIGZyb20gXCIuLi9tYWluXCI7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRpbWVsaW5lVmlldyBleHRlbmRzIEl0ZW1WaWV3IHtcbiAgcHJpdmF0ZSB0aW1lbGluZTogVGltZWxpbmU7XG4gIHByaXZhdGUgc2V0dGluZ3M6IERheVBsYW5uZXJTZXR0aW5ncztcblxuICBjb25zdHJ1Y3RvcihcbiAgICBsZWFmOiBXb3Jrc3BhY2VMZWFmLFxuICAgIHNldHRpbmdzOiBEYXlQbGFubmVyU2V0dGluZ3MsXG4gICAgcHJpdmF0ZSByZWFkb25seSBwbHVnaW46IERheVBsYW5uZXIsXG4gICkge1xuICAgIHN1cGVyKGxlYWYpO1xuICAgIHRoaXMuc2V0dGluZ3MgPSBzZXR0aW5ncztcbiAgfVxuXG4gIGdldFZpZXdUeXBlKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFZJRVdfVFlQRV9USU1FTElORTtcbiAgfVxuXG4gIGdldERpc3BsYXlUZXh0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIFwiRGF5IFBsYW5uZXIgVGltZWxpbmVcIjtcbiAgfVxuXG4gIGdldEljb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuc2V0dGluZ3MudGltZWxpbmVJY29uO1xuICB9XG5cbiAgYXN5bmMgb25PcGVuKCkge1xuICAgIHRoaXMuaW5pdFN0b3JlKCk7XG5cbiAgICBjb25zdCBjb250ZW50RWwgPSB0aGlzLmNvbnRhaW5lckVsLmNoaWxkcmVuWzFdO1xuICAgIHRoaXMudGltZWxpbmUgPSBuZXcgVGltZWxpbmUoe1xuICAgICAgdGFyZ2V0OiBjb250ZW50RWwsXG4gICAgfSk7XG4gIH1cblxuICBpbml0U3RvcmUoKSB7XG4gICAgYXBwU3RvcmUuc2V0KHRoaXMuYXBwKTtcbiAgICBjb25zdCB7XG4gICAgICB6b29tTGV2ZWwsXG4gICAgICBjZW50ZXJOZWVkbGUsXG4gICAgICBzdGFydEhvdXIsXG4gICAgICB0aW1lbGluZURhdGVGb3JtYXQsXG4gICAgICBwbGFubmVySGVhZGluZyxcbiAgICAgIHBsYW5uZXJIZWFkaW5nTGV2ZWwsXG4gICAgfSA9IHRoaXMuc2V0dGluZ3M7XG5cbiAgICBzZXR0aW5ncy5zZXQoe1xuICAgICAgem9vbUxldmVsLFxuICAgICAgY2VudGVyTmVlZGxlLFxuICAgICAgc3RhcnRIb3VyLFxuICAgICAgdGltZWxpbmVEYXRlRm9ybWF0LFxuICAgICAgcGxhbm5lckhlYWRpbmcsXG4gICAgICBwbGFubmVySGVhZGluZ0xldmVsLFxuICAgIH0pO1xuXG4gICAgc2V0dGluZ3Muc3Vic2NyaWJlKGFzeW5jIChuZXdWYWx1ZSkgPT4ge1xuICAgICAgdGhpcy5wbHVnaW4uc2V0dGluZ3MgPSB7IC4uLnRoaXMucGx1Z2luLnNldHRpbmdzLCAuLi5uZXdWYWx1ZSB9O1xuICAgICAgYXdhaXQgdGhpcy5wbHVnaW4uc2F2ZURhdGEodGhpcy5wbHVnaW4uc2V0dGluZ3MpO1xuICAgIH0pO1xuICB9XG5cbiAgYXN5bmMgb25DbG9zZSgpIHtcbiAgICB0aGlzLnRpbWVsaW5lPy4kZGVzdHJveSgpO1xuICB9XG59XG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgaW1wb3J0IHsgaG91clNpemUgfSBmcm9tIFwiLi4vLi4vc3RvcmUvdGltZWxpbmUtc3RvcmVcIjtcblxuICBleHBvcnQgbGV0IHZpc2libGVIb3VyczogbnVtYmVyW107XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cImhvdXJzLWNvbnRhaW5lclwiPlxuICB7I2VhY2ggdmlzaWJsZUhvdXJzIGFzIGhvdXJ9XG4gICAgPGRpdiBjbGFzcz1cImhvdXJcIiBzdHlsZTpoZWlnaHQ9XCJ7JGhvdXJTaXplfXB4XCI+XG4gICAgICA8ZGl2IGNsYXNzPVwiaG91ci1udW1iZXItY29udGFpbmVyXCIgc3R5bGU6dHJhbnNmb3JtPVwidHJhbnNsYXRlWSgtMTBweClcIj5cbiAgICAgICAge2hvdXJ9XG4gICAgICA8L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJob3VyLWd1aWRlXCI+PC9kaXY+XG4gICAgPC9kaXY+XG4gIHsvZWFjaH1cbjwvZGl2PlxuXG48c3R5bGU+XG4gIC5ob3Vycy1jb250YWluZXIge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleDogMCAwIDQwcHg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgfVxuXG4gIC5ob3VyIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXgtZ3JvdzogMTtcbiAgICBmbGV4LXNocmluazogMDtcbiAgfVxuXG4gIC5ob3VyLWd1aWRlIHtcbiAgICBmbGV4OiAwIDAgMTBweDtcbiAgfVxuXG4gIC5ob3VyOm5vdCg6Zmlyc3QtY2hpbGQpIC5ob3VyLWd1aWRlIHtcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpO1xuICB9XG5cbiAgLmhvdXItbnVtYmVyLWNvbnRhaW5lciB7XG4gICAgcG9zaXRpb246IHN0aWNreTtcbiAgICB0b3A6IDEwcHg7XG5cbiAgICBkaXNwbGF5OiBmbGV4O1xuICAgIGZsZXg6IDAgMCAzMHB4O1xuICAgIGFsaWduLXNlbGY6IGZsZXgtc3RhcnQ7XG4gICAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XG5cbiAgICBjb2xvcjogdmFyKC0tdGV4dC1mYWludCk7XG4gIH1cbjwvc3R5bGU+XG4iLCAiPHNjcmlwdCBsYW5nPVwidHNcIj5cbiAgaW1wb3J0IHsgaG91clNpemUgfSBmcm9tIFwiLi4vLi4vc3RvcmUvdGltZWxpbmUtc3RvcmVcIjtcblxuICBleHBvcnQgbGV0IHZpc2libGVIb3VyczogbnVtYmVyW107XG48L3NjcmlwdD5cblxuPGRpdiBjbGFzcz1cInRhc2stZ3JpZFwiPlxuICA8c2xvdCAvPlxuICB7I2VhY2ggdmlzaWJsZUhvdXJzIGFzIGhvdXJ9XG4gICAgPGRpdiBjbGFzcz1cInRpbWUtZ3JpZC1ibG9ja1wiIHN0eWxlOmhlaWdodD1cInskaG91clNpemV9cHhcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJoYWxmLWhvdXItc2VwYXJhdG9yXCIgc3R5bGU6aGVpZ2h0PVwieyRob3VyU2l6ZSAvIDJ9cHhcIj48L2Rpdj5cbiAgICA8L2Rpdj5cbiAgey9lYWNofVxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnRhc2stZ3JpZCB7XG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgIGZsZXg6IDEgMCAwO1xuICB9XG5cbiAgLnRpbWUtZ3JpZC1ibG9jayB7XG4gICAgZmxleC1ncm93OiAxO1xuICAgIGZsZXgtc2hyaW5rOiAwO1xuICAgIGJvcmRlci1sZWZ0OiAxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpO1xuICB9XG5cbiAgLmhhbGYtaG91ci1zZXBhcmF0b3Ige1xuICAgIGJvcmRlci1ib3R0b206IDFweCBkYXNoZWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpO1xuICB9XG5cbiAgLyogVE9ETzogdGhpcyBzZWxlY3RvciBpcyBhIGxhbWUgd29ya2Fyb3VuZCBmb3IgdGFzayBjb250YWluZXIgd2hpY2ggaXMgYWJzb2x1dGVseSBwb3NpdGlvbmVkICovXG4gIC50aW1lLWdyaWQtYmxvY2s6bm90KDpudGgtY2hpbGQoMikpIHtcbiAgICBib3JkZXItdG9wOiAxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpO1xuICB9XG48L3N0eWxlPlxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gIGltcG9ydCB7IG9uTW91bnQgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcInNyYy9zdG9yZS9zZXR0aW5nc1wiO1xuICBpbXBvcnQgeyBnZXRNaW51dGVzU2luY2VNaWRuaWdodCB9IGZyb20gXCIuLi8uLi91dGlsL21vbWVudFwiO1xuICBpbXBvcnQgeyB0aW1lVG9UaW1lbGluZU9mZnNldCB9IGZyb20gXCJzcmMvc3RvcmUvdGltZWxpbmUtc3RvcmVcIjtcblxuICBleHBvcnQgbGV0IHNjcm9sbEJsb2NrZWRCeVVzZXIgPSBmYWxzZTtcblxuICBsZXQgZWw6IEhUTUxEaXZFbGVtZW50O1xuXG4gICQ6IGNvb3JkcyA9ICR0aW1lVG9UaW1lbGluZU9mZnNldChnZXRNaW51dGVzU2luY2VNaWRuaWdodCgpKTtcblxuICBmdW5jdGlvbiBzY3JvbGxJbnRvVmlldygpIHtcbiAgICBpZiAoJHNldHRpbmdzLmNlbnRlck5lZWRsZSAmJiAhc2Nyb2xsQmxvY2tlZEJ5VXNlcikge1xuICAgICAgZWw/LnNjcm9sbEludG9WaWV3KHsgYmVoYXZpb3I6IFwic21vb3RoXCIsIGJsb2NrOiBcImNlbnRlclwiIH0pO1xuICAgIH1cbiAgfVxuXG4gIG9uTW91bnQoKCkgPT4ge1xuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgY29vcmRzID0gJHRpbWVUb1RpbWVsaW5lT2Zmc2V0KGdldE1pbnV0ZXNTaW5jZU1pZG5pZ2h0KCkpO1xuICAgICAgc2Nyb2xsSW50b1ZpZXcoKTtcbiAgICB9LCAyMDAwKTtcblxuICAgIHJldHVybiAoKSA9PiBjbGVhckludGVydmFsKGludGVydmFsKTtcbiAgfSk7XG48L3NjcmlwdD5cblxuPGRpdlxuICBiaW5kOnRoaXM9e2VsfVxuICBjbGFzcz1cIm5lZWRsZSBhYnNvbHV0ZS1zdHJldGNoLXhcIlxuICBzdHlsZTp0cmFuc2Zvcm09XCJ0cmFuc2xhdGVZKHtjb29yZHN9cHgpXCJcbj48L2Rpdj5cblxuPHN0eWxlPlxuICAubmVlZGxlIHtcbiAgICBoZWlnaHQ6IDRweDtcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiB2YXIoLS1jb2xvci1hY2NlbnQpO1xuICB9XG48L3N0eWxlPlxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gIGltcG9ydCB7IENvbXBvbmVudCwgTWFya2Rvd25SZW5kZXJlciB9IGZyb20gXCJvYnNpZGlhblwiO1xuICBpbXBvcnQgeyBvbkRlc3Ryb3kgfSBmcm9tIFwic3ZlbHRlXCI7XG4gIGltcG9ydCB7IGFwcFN0b3JlIH0gZnJvbSBcIi4uLy4uL3N0b3JlL3RpbWVsaW5lLXN0b3JlXCI7XG5cbiAgZXhwb3J0IGxldCB0ZXh0OiBzdHJpbmc7XG5cbiAgbGV0IG1hcmtkb3duTGlmZWN5Y2xlTWFuYWdlciA9IG5ldyBDb21wb25lbnQoKTtcbiAgbGV0IHJlbmRlcmVkTWFya2Rvd246IEhUTUxEaXZFbGVtZW50O1xuXG4gIG9uRGVzdHJveSgoKSA9PiB7XG4gICAgbWFya2Rvd25MaWZlY3ljbGVNYW5hZ2VyLnVubG9hZCgpO1xuICB9KTtcblxuICAkOiBpZiAocmVuZGVyZWRNYXJrZG93bikge1xuICAgIG1hcmtkb3duTGlmZWN5Y2xlTWFuYWdlci51bmxvYWQoKTtcbiAgICBtYXJrZG93bkxpZmVjeWNsZU1hbmFnZXIgPSBuZXcgQ29tcG9uZW50KCk7XG5cbiAgICByZW5kZXJlZE1hcmtkb3duLmVtcHR5KCk7XG4gICAgTWFya2Rvd25SZW5kZXJlci5yZW5kZXIoXG4gICAgICAkYXBwU3RvcmUsXG4gICAgICB0ZXh0LFxuICAgICAgcmVuZGVyZWRNYXJrZG93bixcbiAgICAgIFwiXCIsXG4gICAgICBtYXJrZG93bkxpZmVjeWNsZU1hbmFnZXIsXG4gICAgKTtcbiAgICBtYXJrZG93bkxpZmVjeWNsZU1hbmFnZXIubG9hZCgpO1xuICB9XG48L3NjcmlwdD5cblxuPGRpdiBiaW5kOnRoaXM9e3JlbmRlcmVkTWFya2Rvd259IGNsYXNzPVwicmVuZGVyZWQtbWFya2Rvd25cIj48L2Rpdj5cblxuPHN0eWxlPlxuICAucmVuZGVyZWQtbWFya2Rvd24gOmdsb2JhbChwKSB7XG4gICAgbWFyZ2luLWJsb2NrLXN0YXJ0OiAwO1xuICAgIG1hcmdpbi1ibG9jay1lbmQ6IDA7XG4gIH1cbjwvc3R5bGU+XG4iLCAiaW1wb3J0IHsgY3ViaWNJbk91dCwgbGluZWFyLCBjdWJpY091dCB9IGZyb20gJy4uL2Vhc2luZy9pbmRleC5tanMnO1xuaW1wb3J0IHsgc3BsaXRfY3NzX3VuaXQsIGlzX2Z1bmN0aW9uLCBhc3NpZ24gfSBmcm9tICcuLi9pbnRlcm5hbC9pbmRleC5tanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqXHJcbkNvcHlyaWdodCAoYykgTWljcm9zb2Z0IENvcnBvcmF0aW9uLlxyXG5cclxuUGVybWlzc2lvbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgYW5kL29yIGRpc3RyaWJ1dGUgdGhpcyBzb2Z0d2FyZSBmb3IgYW55XHJcbnB1cnBvc2Ugd2l0aCBvciB3aXRob3V0IGZlZSBpcyBoZXJlYnkgZ3JhbnRlZC5cclxuXHJcblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIgQU5EIFRIRSBBVVRIT1IgRElTQ0xBSU1TIEFMTCBXQVJSQU5USUVTIFdJVEhcclxuUkVHQVJEIFRPIFRISVMgU09GVFdBUkUgSU5DTFVESU5HIEFMTCBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZXHJcbkFORCBGSVRORVNTLiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SIEJFIExJQUJMRSBGT1IgQU5ZIFNQRUNJQUwsIERJUkVDVCxcclxuSU5ESVJFQ1QsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBPUiBBTlkgREFNQUdFUyBXSEFUU09FVkVSIFJFU1VMVElORyBGUk9NXHJcbkxPU1MgT0YgVVNFLCBEQVRBIE9SIFBST0ZJVFMsIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBORUdMSUdFTkNFIE9SXHJcbk9USEVSIFRPUlRJT1VTIEFDVElPTiwgQVJJU0lORyBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBVU0UgT1JcclxuUEVSRk9STUFOQ0UgT0YgVEhJUyBTT0ZUV0FSRS5cclxuKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiogKi9cclxuXHJcbmZ1bmN0aW9uIF9fcmVzdChzLCBlKSB7XHJcbiAgICB2YXIgdCA9IHt9O1xyXG4gICAgZm9yICh2YXIgcCBpbiBzKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHMsIHApICYmIGUuaW5kZXhPZihwKSA8IDApXHJcbiAgICAgICAgdFtwXSA9IHNbcF07XHJcbiAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHAgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKHMpOyBpIDwgcC5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoZS5pbmRleE9mKHBbaV0pIDwgMCAmJiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwocywgcFtpXSkpXHJcbiAgICAgICAgICAgICAgICB0W3BbaV1dID0gc1twW2ldXTtcclxuICAgICAgICB9XHJcbiAgICByZXR1cm4gdDtcclxufVxuXG5mdW5jdGlvbiBibHVyKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gY3ViaWNJbk91dCwgYW1vdW50ID0gNSwgb3BhY2l0eSA9IDAgfSA9IHt9KSB7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGNvbnN0IHRhcmdldF9vcGFjaXR5ID0gK3N0eWxlLm9wYWNpdHk7XG4gICAgY29uc3QgZiA9IHN0eWxlLmZpbHRlciA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS5maWx0ZXI7XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgY29uc3QgW3ZhbHVlLCB1bml0XSA9IHNwbGl0X2Nzc191bml0KGFtb3VudCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgb3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfTsgZmlsdGVyOiAke2Z9IGJsdXIoJHt1ICogdmFsdWV9JHt1bml0fSk7YFxuICAgIH07XG59XG5mdW5jdGlvbiBmYWRlKG5vZGUsIHsgZGVsYXkgPSAwLCBkdXJhdGlvbiA9IDQwMCwgZWFzaW5nID0gbGluZWFyIH0gPSB7fSkge1xuICAgIGNvbnN0IG8gPSArZ2V0Q29tcHV0ZWRTdHlsZShub2RlKS5vcGFjaXR5O1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IHQgPT4gYG9wYWNpdHk6ICR7dCAqIG99YFxuICAgIH07XG59XG5mdW5jdGlvbiBmbHkobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgeCA9IDAsIHkgPSAwLCBvcGFjaXR5ID0gMCB9ID0ge30pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3QgdGFyZ2V0X29wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICBjb25zdCB0cmFuc2Zvcm0gPSBzdHlsZS50cmFuc2Zvcm0gPT09ICdub25lJyA/ICcnIDogc3R5bGUudHJhbnNmb3JtO1xuICAgIGNvbnN0IG9kID0gdGFyZ2V0X29wYWNpdHkgKiAoMSAtIG9wYWNpdHkpO1xuICAgIGNvbnN0IFt4VmFsdWUsIHhVbml0XSA9IHNwbGl0X2Nzc191bml0KHgpO1xuICAgIGNvbnN0IFt5VmFsdWUsIHlVbml0XSA9IHNwbGl0X2Nzc191bml0KHkpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSB0cmFuc2xhdGUoJHsoMSAtIHQpICogeFZhbHVlfSR7eFVuaXR9LCAkeygxIC0gdCkgKiB5VmFsdWV9JHt5VW5pdH0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfWBcbiAgICB9O1xufVxuZnVuY3Rpb24gc2xpZGUobm9kZSwgeyBkZWxheSA9IDAsIGR1cmF0aW9uID0gNDAwLCBlYXNpbmcgPSBjdWJpY091dCwgYXhpcyA9ICd5JyB9ID0ge30pIHtcbiAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgY29uc3Qgb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHByaW1hcnlfcHJvcGVydHkgPSBheGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgY29uc3QgcHJpbWFyeV9wcm9wZXJ0eV92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbcHJpbWFyeV9wcm9wZXJ0eV0pO1xuICAgIGNvbnN0IHNlY29uZGFyeV9wcm9wZXJ0aWVzID0gYXhpcyA9PT0gJ3knID8gWyd0b3AnLCAnYm90dG9tJ10gOiBbJ2xlZnQnLCAncmlnaHQnXTtcbiAgICBjb25zdCBjYXBpdGFsaXplZF9zZWNvbmRhcnlfcHJvcGVydGllcyA9IHNlY29uZGFyeV9wcm9wZXJ0aWVzLm1hcCgoZSkgPT4gYCR7ZVswXS50b1VwcGVyQ2FzZSgpfSR7ZS5zbGljZSgxKX1gKTtcbiAgICBjb25zdCBwYWRkaW5nX3N0YXJ0X3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgcGFkZGluZyR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19YF0pO1xuICAgIGNvbnN0IHBhZGRpbmdfZW5kX3ZhbHVlID0gcGFyc2VGbG9hdChzdHlsZVtgcGFkZGluZyR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMV19YF0pO1xuICAgIGNvbnN0IG1hcmdpbl9zdGFydF92YWx1ZSA9IHBhcnNlRmxvYXQoc3R5bGVbYG1hcmdpbiR7Y2FwaXRhbGl6ZWRfc2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19YF0pO1xuICAgIGNvbnN0IG1hcmdpbl9lbmRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2BtYXJnaW4ke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfWBdKTtcbiAgICBjb25zdCBib3JkZXJfd2lkdGhfc3RhcnRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2Bib3JkZXIke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfVdpZHRoYF0pO1xuICAgIGNvbnN0IGJvcmRlcl93aWR0aF9lbmRfdmFsdWUgPSBwYXJzZUZsb2F0KHN0eWxlW2Bib3JkZXIke2NhcGl0YWxpemVkX3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfVdpZHRoYF0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGRlbGF5LFxuICAgICAgICBkdXJhdGlvbixcbiAgICAgICAgZWFzaW5nLFxuICAgICAgICBjc3M6IHQgPT4gJ292ZXJmbG93OiBoaWRkZW47JyArXG4gICAgICAgICAgICBgb3BhY2l0eTogJHtNYXRoLm1pbih0ICogMjAsIDEpICogb3BhY2l0eX07YCArXG4gICAgICAgICAgICBgJHtwcmltYXJ5X3Byb3BlcnR5fTogJHt0ICogcHJpbWFyeV9wcm9wZXJ0eV92YWx1ZX1weDtgICtcbiAgICAgICAgICAgIGBwYWRkaW5nLSR7c2Vjb25kYXJ5X3Byb3BlcnRpZXNbMF19OiAke3QgKiBwYWRkaW5nX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuICAgICAgICAgICAgYHBhZGRpbmctJHtzZWNvbmRhcnlfcHJvcGVydGllc1sxXX06ICR7dCAqIHBhZGRpbmdfZW5kX3ZhbHVlfXB4O2AgK1xuICAgICAgICAgICAgYG1hcmdpbi0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzBdfTogJHt0ICogbWFyZ2luX3N0YXJ0X3ZhbHVlfXB4O2AgK1xuICAgICAgICAgICAgYG1hcmdpbi0ke3NlY29uZGFyeV9wcm9wZXJ0aWVzWzFdfTogJHt0ICogbWFyZ2luX2VuZF92YWx1ZX1weDtgICtcbiAgICAgICAgICAgIGBib3JkZXItJHtzZWNvbmRhcnlfcHJvcGVydGllc1swXX0td2lkdGg6ICR7dCAqIGJvcmRlcl93aWR0aF9zdGFydF92YWx1ZX1weDtgICtcbiAgICAgICAgICAgIGBib3JkZXItJHtzZWNvbmRhcnlfcHJvcGVydGllc1sxXX0td2lkdGg6ICR7dCAqIGJvcmRlcl93aWR0aF9lbmRfdmFsdWV9cHg7YFxuICAgIH07XG59XG5mdW5jdGlvbiBzY2FsZShub2RlLCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSA0MDAsIGVhc2luZyA9IGN1YmljT3V0LCBzdGFydCA9IDAsIG9wYWNpdHkgPSAwIH0gPSB7fSkge1xuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShub2RlKTtcbiAgICBjb25zdCB0YXJnZXRfb3BhY2l0eSA9ICtzdHlsZS5vcGFjaXR5O1xuICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgY29uc3Qgc2QgPSAxIC0gc3RhcnQ7XG4gICAgY29uc3Qgb2QgPSB0YXJnZXRfb3BhY2l0eSAqICgxIC0gb3BhY2l0eSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVsYXksXG4gICAgICAgIGR1cmF0aW9uLFxuICAgICAgICBlYXNpbmcsXG4gICAgICAgIGNzczogKF90LCB1KSA9PiBgXG5cdFx0XHR0cmFuc2Zvcm06ICR7dHJhbnNmb3JtfSBzY2FsZSgkezEgLSAoc2QgKiB1KX0pO1xuXHRcdFx0b3BhY2l0eTogJHt0YXJnZXRfb3BhY2l0eSAtIChvZCAqIHUpfVxuXHRcdGBcbiAgICB9O1xufVxuZnVuY3Rpb24gZHJhdyhub2RlLCB7IGRlbGF5ID0gMCwgc3BlZWQsIGR1cmF0aW9uLCBlYXNpbmcgPSBjdWJpY0luT3V0IH0gPSB7fSkge1xuICAgIGxldCBsZW4gPSBub2RlLmdldFRvdGFsTGVuZ3RoKCk7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKG5vZGUpO1xuICAgIGlmIChzdHlsZS5zdHJva2VMaW5lY2FwICE9PSAnYnV0dCcpIHtcbiAgICAgICAgbGVuICs9IHBhcnNlSW50KHN0eWxlLnN0cm9rZVdpZHRoKTtcbiAgICB9XG4gICAgaWYgKGR1cmF0aW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHNwZWVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGR1cmF0aW9uID0gODAwO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZHVyYXRpb24gPSBsZW4gLyBzcGVlZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgZHVyYXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZHVyYXRpb24gPSBkdXJhdGlvbihsZW4pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBkZWxheSxcbiAgICAgICAgZHVyYXRpb24sXG4gICAgICAgIGVhc2luZyxcbiAgICAgICAgY3NzOiAoXywgdSkgPT4gYFxuXHRcdFx0c3Ryb2tlLWRhc2hhcnJheTogJHtsZW59O1xuXHRcdFx0c3Ryb2tlLWRhc2hvZmZzZXQ6ICR7dSAqIGxlbn07XG5cdFx0YFxuICAgIH07XG59XG5mdW5jdGlvbiBjcm9zc2ZhZGUoX2EpIHtcbiAgICB2YXIgeyBmYWxsYmFjayB9ID0gX2EsIGRlZmF1bHRzID0gX19yZXN0KF9hLCBbXCJmYWxsYmFja1wiXSk7XG4gICAgY29uc3QgdG9fcmVjZWl2ZSA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCB0b19zZW5kID0gbmV3IE1hcCgpO1xuICAgIGZ1bmN0aW9uIGNyb3NzZmFkZShmcm9tX25vZGUsIG5vZGUsIHBhcmFtcykge1xuICAgICAgICBjb25zdCB7IGRlbGF5ID0gMCwgZHVyYXRpb24gPSBkID0+IE1hdGguc3FydChkKSAqIDMwLCBlYXNpbmcgPSBjdWJpY091dCB9ID0gYXNzaWduKGFzc2lnbih7fSwgZGVmYXVsdHMpLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBmcm9tID0gZnJvbV9ub2RlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgICBjb25zdCB0byA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGNvbnN0IGR4ID0gZnJvbS5sZWZ0IC0gdG8ubGVmdDtcbiAgICAgICAgY29uc3QgZHkgPSBmcm9tLnRvcCAtIHRvLnRvcDtcbiAgICAgICAgY29uc3QgZHcgPSBmcm9tLndpZHRoIC8gdG8ud2lkdGg7XG4gICAgICAgIGNvbnN0IGRoID0gZnJvbS5oZWlnaHQgLyB0by5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGQgPSBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuICAgICAgICBjb25zdCBzdHlsZSA9IGdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gICAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHN0eWxlLnRyYW5zZm9ybSA9PT0gJ25vbmUnID8gJycgOiBzdHlsZS50cmFuc2Zvcm07XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSArc3R5bGUub3BhY2l0eTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRlbGF5LFxuICAgICAgICAgICAgZHVyYXRpb246IGlzX2Z1bmN0aW9uKGR1cmF0aW9uKSA/IGR1cmF0aW9uKGQpIDogZHVyYXRpb24sXG4gICAgICAgICAgICBlYXNpbmcsXG4gICAgICAgICAgICBjc3M6ICh0LCB1KSA9PiBgXG5cdFx0XHRcdG9wYWNpdHk6ICR7dCAqIG9wYWNpdHl9O1xuXHRcdFx0XHR0cmFuc2Zvcm0tb3JpZ2luOiB0b3AgbGVmdDtcblx0XHRcdFx0dHJhbnNmb3JtOiAke3RyYW5zZm9ybX0gdHJhbnNsYXRlKCR7dSAqIGR4fXB4LCR7dSAqIGR5fXB4KSBzY2FsZSgke3QgKyAoMSAtIHQpICogZHd9LCAke3QgKyAoMSAtIHQpICogZGh9KTtcblx0XHRcdGBcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdHJhbnNpdGlvbihpdGVtcywgY291bnRlcnBhcnRzLCBpbnRybykge1xuICAgICAgICByZXR1cm4gKG5vZGUsIHBhcmFtcykgPT4ge1xuICAgICAgICAgICAgaXRlbXMuc2V0KHBhcmFtcy5rZXksIG5vZGUpO1xuICAgICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoY291bnRlcnBhcnRzLmhhcyhwYXJhbXMua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdGhlcl9ub2RlID0gY291bnRlcnBhcnRzLmdldChwYXJhbXMua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgY291bnRlcnBhcnRzLmRlbGV0ZShwYXJhbXMua2V5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNyb3NzZmFkZShvdGhlcl9ub2RlLCBub2RlLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBpZiB0aGUgbm9kZSBpcyBkaXNhcHBlYXJpbmcgYWx0b2dldGhlclxuICAgICAgICAgICAgICAgIC8vIChpLmUuIHdhc24ndCBjbGFpbWVkIGJ5IHRoZSBvdGhlciBsaXN0KVxuICAgICAgICAgICAgICAgIC8vIHRoZW4gd2UgbmVlZCB0byBzdXBwbHkgYW4gb3V0cm9cbiAgICAgICAgICAgICAgICBpdGVtcy5kZWxldGUocGFyYW1zLmtleSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbGxiYWNrICYmIGZhbGxiYWNrKG5vZGUsIHBhcmFtcywgaW50cm8pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdHJhbnNpdGlvbih0b19zZW5kLCB0b19yZWNlaXZlLCBmYWxzZSksXG4gICAgICAgIHRyYW5zaXRpb24odG9fcmVjZWl2ZSwgdG9fc2VuZCwgdHJ1ZSlcbiAgICBdO1xufVxuXG5leHBvcnQgeyBibHVyLCBjcm9zc2ZhZGUsIGRyYXcsIGZhZGUsIGZseSwgc2NhbGUsIHNsaWRlIH07XG4iLCAiaW1wb3J0IHsgZ2V0IH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuaW1wb3J0IHsgVEZpbGUgfSBmcm9tIFwib2JzaWRpYW5cIjtcbmltcG9ydCB7IHJlcGxhY2VUaW1lc3RhbXAgfSBmcm9tIFwic3JjL3RpbWVzdGFtcC90aW1lc3RhbXBcIjtcbmltcG9ydCB7IGFwcFN0b3JlLCB0YXNrcywgVGltZXN0YW1wIH0gZnJvbSBcIi4vdGltZWxpbmUtc3RvcmVcIjtcbmltcG9ydCB0eXBlIHsgUGxhbkl0ZW0gfSBmcm9tIFwiLi4vdHlwZXNcIjtcblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHVwZGF0ZVRpbWVzdGFtcHMoaWQ6IHN0cmluZywgdGltZXN0YW1wOiBUaW1lc3RhbXApIHtcbiAgdGFza3MudXBkYXRlKChwcmV2aW91cykgPT4ge1xuICAgIHJldHVybiBwcmV2aW91cy5tYXAoKHRhc2spID0+IHtcbiAgICAgIC8vIHRvZG86IHJlcGxhY2Ugd2l0aCBJRFxuICAgICAgaWYgKHRhc2sudGV4dCAhPT0gaWQpIHtcbiAgICAgICAgcmV0dXJuIHRhc2s7XG4gICAgICB9XG5cbiAgICAgIC8vIHRvZG86IHNwbGl0IGVmZmVjdCBmcm9tIG1hcHBpbmdcbiAgICAgIHVwZGF0ZUR1cmF0aW9uSW5EYWlseU5vdGUodGFzaywgdGltZXN0YW1wKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGFzayxcbiAgICAgICAgLi4udGltZXN0YW1wLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSk7XG59XG5cbmFzeW5jIGZ1bmN0aW9uIHVwZGF0ZUR1cmF0aW9uSW5EYWlseU5vdGUoXG4gIHRhc2s6IFBsYW5JdGVtLFxuICBzdGFydEFuZER1cmF0aW9uOiBUaW1lc3RhbXAsXG4pIHtcbiAgY29uc3QgZmlsZSA9IGdldChhcHBTdG9yZSkudmF1bHQuZ2V0QWJzdHJhY3RGaWxlQnlQYXRoKHRhc2subG9jYXRpb24ucGF0aCk7XG5cbiAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlNvbWV0aGluZyBpcyB3cm9uZ1wiKTtcbiAgfVxuXG4gIGNvbnN0IGNvbnRlbnRzID0gYXdhaXQgZ2V0KGFwcFN0b3JlKS52YXVsdC5yZWFkKGZpbGUpO1xuICAvLyB0b2RvOiB0aGlzIGlzIGluZWZmaWNpZW50XG4gIGNvbnN0IHVwZGF0ZWQgPSBjb250ZW50c1xuICAgIC5zcGxpdChcIlxcblwiKVxuICAgIC5tYXAoKGxpbmUsIGkpID0+IHtcbiAgICAgIGlmIChpID09PSB0YXNrLmxvY2F0aW9uLmxpbmUpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2VUaW1lc3RhbXAodGFzaywgc3RhcnRBbmREdXJhdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBsaW5lO1xuICAgIH0pXG4gICAgLmpvaW4oXCJcXG5cIik7XG5cbiAgYXdhaXQgZ2V0KGFwcFN0b3JlKS52YXVsdC5tb2RpZnkoZmlsZSwgdXBkYXRlZCk7XG59XG4iLCAiaW1wb3J0IHsgZ2V0VGltZUZyb21ZT2Zmc2V0IH0gZnJvbSBcInNyYy9zdG9yZS90aW1lbGluZS1zdG9yZVwiO1xuaW1wb3J0IHsgdXBkYXRlVGltZXN0YW1wcyB9IGZyb20gXCJzcmMvc3RvcmUvdXBkYXRlLXRpbWVzdGFtcFwiO1xuaW1wb3J0IHsgd3JpdGFibGUgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiB1c2VEcmFnKCkge1xuICBjb25zdCBkcmFnZ2luZyA9IHdyaXRhYmxlKGZhbHNlKTtcbiAgY29uc3QgcG9pbnRlcllPZmZzZXRUb1Rhc2tTdGFydCA9IHdyaXRhYmxlPG51bWJlcj4oKTtcblxuICBmdW5jdGlvbiBoYW5kbGVNb3ZlU3RhcnQoZXZlbnQ6IE1vdXNlRXZlbnQpIHtcbiAgICBkcmFnZ2luZy5zZXQodHJ1ZSk7XG4gICAgcG9pbnRlcllPZmZzZXRUb1Rhc2tTdGFydC5zZXQoZXZlbnQub2Zmc2V0WSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVNb3ZlQ2FuY2VsKCkge1xuICAgIGRyYWdnaW5nLnNldChmYWxzZSk7XG4gIH1cblxuICBhc3luYyBmdW5jdGlvbiBoYW5kbGVNb3ZlQ29uZmlybShcbiAgICBvZmZzZXQ6IG51bWJlcixcbiAgICB0ZXh0OiBzdHJpbmcsXG4gICAgLy8gdG9kbzogd2UgZG9uJ3QgbmVlZCBkdXJhdGlvbiBoZXJlXG4gICAgZHVyYXRpb25NaW51dGVzOiBudW1iZXIsXG4gICkge1xuICAgIGRyYWdnaW5nLnNldChmYWxzZSk7XG5cbiAgICBjb25zdCBuZXdTdGFydE1pbnV0ZXMgPSBnZXRUaW1lRnJvbVlPZmZzZXQob2Zmc2V0KTtcblxuICAgIGF3YWl0IHVwZGF0ZVRpbWVzdGFtcHModGV4dCwge1xuICAgICAgc3RhcnRNaW51dGVzOiBuZXdTdGFydE1pbnV0ZXMsXG4gICAgICBkdXJhdGlvbk1pbnV0ZXMsXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIHBvaW50ZXJZT2Zmc2V0VG9UYXNrU3RhcnQsXG4gICAgZHJhZ2dpbmcsXG4gICAgaGFuZGxlTW92ZVN0YXJ0LFxuICAgIGhhbmRsZU1vdmVDYW5jZWwsXG4gICAgaGFuZGxlTW92ZUNvbmZpcm0sXG4gIH07XG59XG4iLCAiaW1wb3J0IHsgc2l6ZVRvRHVyYXRpb24gfSBmcm9tIFwic3JjL3N0b3JlL3RpbWVsaW5lLXN0b3JlXCI7XG5pbXBvcnQgeyB1cGRhdGVUaW1lc3RhbXBzIH0gZnJvbSBcInNyYy9zdG9yZS91cGRhdGUtdGltZXN0YW1wXCI7XG5pbXBvcnQgeyBnZXQsIHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5leHBvcnQgZnVuY3Rpb24gdXNlUmVzaXplKCkge1xuICBjb25zdCByZXNpemluZyA9IHdyaXRhYmxlKGZhbHNlKTtcblxuICBmdW5jdGlvbiBoYW5kbGVSZXNpemVTdGFydCgpIHtcbiAgICByZXNpemluZy5zZXQodHJ1ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVSZXNpemVDYW5jZWwoKSB7XG4gICAgcmVzaXppbmcuc2V0KGZhbHNlKTtcbiAgfVxuXG4gIGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlc2l6ZUNvbmZpcm0oXG4gICAgdGV4dDogc3RyaW5nLFxuICAgIHRhc2tIZWlnaHQ6IG51bWJlcixcbiAgICAvLyB0b2RvOiBkb24ndCBuZWVkIHN0YXJ0IG1pbnV0ZXMgaGVyZVxuICAgIHN0YXJ0TWludXRlczogbnVtYmVyLFxuICApIHtcbiAgICBpZiAoIWdldChyZXNpemluZykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICByZXNpemluZy5zZXQoZmFsc2UpO1xuXG4gICAgY29uc3QgbmV3RHVyYXRpb25NaW51dGVzID0gc2l6ZVRvRHVyYXRpb24odGFza0hlaWdodCk7XG5cbiAgICBhd2FpdCB1cGRhdGVUaW1lc3RhbXBzKHRleHQsIHtcbiAgICAgIHN0YXJ0TWludXRlcyxcbiAgICAgIGR1cmF0aW9uTWludXRlczogbmV3RHVyYXRpb25NaW51dGVzLFxuICAgIH0pO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICByZXNpemluZyxcbiAgICBoYW5kbGVSZXNpemVTdGFydCxcbiAgICBoYW5kbGVSZXNpemVDb25maXJtLFxuICAgIGhhbmRsZVJlc2l6ZUNhbmNlbCxcbiAgfTtcbn1cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgUmVuZGVyZWRNYXJrZG93biBmcm9tIFwiLi9yZW5kZXJlZC1tYXJrZG93bi5zdmVsdGVcIjtcblxuICBpbXBvcnQgeyBTTkFQX1NURVBfTUlOVVRFUyB9IGZyb20gXCJzcmMvY29uc3RhbnRzXCI7XG4gIGltcG9ydCB7IHNldHRpbmdzIH0gZnJvbSBcInNyYy9zdG9yZS9zZXR0aW5nc1wiO1xuICBpbXBvcnQgdHlwZSB7IFJlYWRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuICBpbXBvcnQgeyBmYWRlIH0gZnJvbSBcInN2ZWx0ZS90cmFuc2l0aW9uXCI7XG4gIGltcG9ydCB7XG4gICAgZHVyYXRpb25Ub1NpemUsXG4gICAgcm91bmRUb1NuYXBTdGVwLFxuICAgIHRpbWVUb1RpbWVsaW5lT2Zmc2V0LFxuICB9IGZyb20gXCIuLi8uLi9zdG9yZS90aW1lbGluZS1zdG9yZVwiO1xuICBpbXBvcnQgeyB1c2VEcmFnIH0gZnJvbSBcIi4uL2hvb2tzL3VzZS1kcmFnXCI7XG4gIGltcG9ydCB7IHVzZVJlc2l6ZSB9IGZyb20gXCIuLi9ob29rcy91c2UtcmVzaXplXCI7XG5cbiAgZXhwb3J0IGxldCB0ZXh0OiBzdHJpbmc7XG4gIGV4cG9ydCBsZXQgc3RhcnRNaW51dGVzOiBudW1iZXIgfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG4gIGV4cG9ydCBsZXQgZHVyYXRpb25NaW51dGVzOiBudW1iZXI7XG4gIGV4cG9ydCBsZXQgcG9pbnRlcllPZmZzZXQ6IFJlYWRhYmxlPG51bWJlcj47XG4gIGV4cG9ydCBsZXQgaXNHaG9zdCA9IGZhbHNlO1xuXG4gIGNvbnN0IHtcbiAgICBkcmFnZ2luZyxcbiAgICBwb2ludGVyWU9mZnNldFRvVGFza1N0YXJ0LFxuICAgIGhhbmRsZU1vdmVTdGFydCxcbiAgICBoYW5kbGVNb3ZlQ2FuY2VsLFxuICAgIGhhbmRsZU1vdmVDb25maXJtLFxuICB9ID0gdXNlRHJhZygpO1xuXG4gIGNvbnN0IHtcbiAgICByZXNpemluZyxcbiAgICBoYW5kbGVSZXNpemVTdGFydCxcbiAgICBoYW5kbGVSZXNpemVDYW5jZWwsXG4gICAgaGFuZGxlUmVzaXplQ29uZmlybSxcbiAgfSA9IHVzZVJlc2l6ZSgpO1xuXG4gICQ6IGluaXRpYWxPZmZzZXQgPSBpc0dob3N0XG4gICAgPyByb3VuZFRvU25hcFN0ZXAoJHBvaW50ZXJZT2Zmc2V0KVxuICAgIDogJHRpbWVUb1RpbWVsaW5lT2Zmc2V0KHN0YXJ0TWludXRlcyk7XG5cbiAgJDogb2Zmc2V0ID0gJGRyYWdnaW5nXG4gICAgPyByb3VuZFRvU25hcFN0ZXAoJHBvaW50ZXJZT2Zmc2V0IC0gJHBvaW50ZXJZT2Zmc2V0VG9UYXNrU3RhcnQpXG4gICAgOiBpbml0aWFsT2Zmc2V0O1xuXG4gICQ6IG9mZnNldFRvUG9pbnRlciA9ICRwb2ludGVyWU9mZnNldCAtIGluaXRpYWxPZmZzZXQ7XG5cbiAgJDogaGVpZ2h0ID0gJHJlc2l6aW5nXG4gICAgPyByb3VuZFRvU25hcFN0ZXAob2Zmc2V0VG9Qb2ludGVyKSArIFNOQVBfU1RFUF9NSU5VVEVTICogJHNldHRpbmdzLnpvb21MZXZlbFxuICAgIDogJGR1cmF0aW9uVG9TaXplKGR1cmF0aW9uTWludXRlcyk7XG5cbiAgJDogY3Vyc29yID0gJGRyYWdnaW5nID8gXCJncmFiYmluZ1wiIDogXCJncmFiXCI7XG5cbiAgZnVuY3Rpb24gaGFuZGxlQ2FuY2VsKCkge1xuICAgIGhhbmRsZU1vdmVDYW5jZWwoKTtcbiAgICBoYW5kbGVSZXNpemVDYW5jZWwoKTtcbiAgfVxuPC9zY3JpcHQ+XG5cbjxzdmVsdGU6Ym9keSBvbjptb3VzZXVwPXtoYW5kbGVDYW5jZWx9IC8+XG5cbjxkaXZcbiAgY2xhc3M9XCJ0YXNrIGFic29sdXRlLXN0cmV0Y2gteFwiXG4gIGNsYXNzOmlzLWdob3N0PXtpc0dob3N0fVxuICBzdHlsZTpoZWlnaHQ9XCJ7aGVpZ2h0fXB4XCJcbiAgc3R5bGU6dHJhbnNmb3JtPVwidHJhbnNsYXRlWSh7b2Zmc2V0fXB4KVwiXG4gIHN0eWxlOmN1cnNvclxuICBvbjptb3VzZWRvd258c3RvcFByb3BhZ2F0aW9uPXtoYW5kbGVNb3ZlU3RhcnR9XG4gIG9uOm1vdXNldXA9eygpID0+XG4gICAgaGFuZGxlTW92ZUNvbmZpcm0oTWF0aC5mbG9vcihvZmZzZXQpLCB0ZXh0LCBkdXJhdGlvbk1pbnV0ZXMpfVxuICB0cmFuc2l0aW9uOmZhZGU9e3sgZHVyYXRpb246IDEwMCB9fVxuPlxuICA8UmVuZGVyZWRNYXJrZG93biB7dGV4dH0gLz5cbiAgPGRpdlxuICAgIGNsYXNzPVwicmVzaXplLWhhbmRsZSBhYnNvbHV0ZS1zdHJldGNoLXhcIlxuICAgIG9uOm1vdXNlZG93bnxzdG9wUHJvcGFnYXRpb249e2hhbmRsZVJlc2l6ZVN0YXJ0fVxuICAgIG9uOm1vdXNldXA9eygpID0+XG4gICAgICBoYW5kbGVSZXNpemVDb25maXJtKHRleHQsIGhlaWdodCwgc3RhcnRNaW51dGVzKX1cbiAgPjwvZGl2PlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnRhc2sge1xuICAgIG92ZXJmbG93OiB2aXNpYmxlO1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgYWxpZ24taXRlbXM6IGZsZXgtc3RhcnQ7XG4gICAganVzdGlmeS1jb250ZW50OiBmbGV4LXN0YXJ0O1xuXG4gICAgcGFkZGluZzogNXB4O1xuXG4gICAgZm9udC1zaXplOiB2YXIoLS1mb250LXVpLW1lZGl1bSk7XG4gICAgY29sb3I6IHZhcigtLXRleHQtbXV0ZWQpO1xuICAgIHRleHQtYWxpZ246IGxlZnQ7XG4gICAgd2hpdGUtc3BhY2U6IG5vcm1hbDtcblxuICAgIGJhY2tncm91bmQtY29sb3I6IHZhcigtLWJhY2tncm91bmQtcHJpbWFyeSk7XG4gICAgYm9yZGVyOiAxcHggc29saWQgdmFyKC0tY29sb3ItYWNjZW50KTtcbiAgICBib3JkZXItcmFkaXVzOiB2YXIoLS1yYWRpdXMtcyk7XG4gICAgYm94LXNoYWRvdzogbm9uZTtcblxuICAgIHRyYW5zaXRpb24tcHJvcGVydHk6IGhlaWdodCwgdHJhbnNmb3JtO1xuICAgIHRyYW5zaXRpb246IDAuMDVzIGxpbmVhcjtcbiAgfVxuXG4gIC5pcy1naG9zdCB7XG4gICAgb3BhY2l0eTogNjAlO1xuICB9XG5cbiAgLnRhc2s6aG92ZXIge1xuICAgIGN1cnNvcjogZ3JhYjtcbiAgfVxuXG4gIC5yZXNpemUtaGFuZGxlIHtcbiAgICBib3R0b206IC0xNXB4O1xuICAgIGhlaWdodDogMzBweDtcbiAgICBjdXJzb3I6IHMtcmVzaXplO1xuICB9XG48L3N0eWxlPlxuIiwgImltcG9ydCB7IFRGaWxlIH0gZnJvbSBcIm9ic2lkaWFuXCI7XG5pbXBvcnQgeyBhcHBTdG9yZSB9IGZyb20gXCIuLi9zdG9yZS90aW1lbGluZS1zdG9yZVwiO1xuaW1wb3J0IHsgZ2V0IH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gb3BlbkZpbGVJbkVkaXRvcihmaWxlOiBURmlsZSkge1xuICBjb25zdCBhcHAgPSBnZXQoYXBwU3RvcmUpO1xuXG4gIGNvbnN0IGxlYWYgPSBhcHAud29ya3NwYWNlLmdldExlYWYoZmFsc2UpO1xuICBhd2FpdCBsZWFmLm9wZW5GaWxlKGZpbGUpO1xuICByZXR1cm4gYXBwLndvcmtzcGFjZS5hY3RpdmVFZGl0b3I/LmVkaXRvcjtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdldEZpbGVCeVBhdGgocGF0aDogc3RyaW5nKSB7XG4gIGNvbnN0IGFwcCA9IGdldChhcHBTdG9yZSk7XG5cbiAgY29uc3QgZmlsZSA9IGFwcC52YXVsdC5nZXRBYnN0cmFjdEZpbGVCeVBhdGgocGF0aCk7XG5cbiAgaWYgKCEoZmlsZSBpbnN0YW5jZW9mIFRGaWxlKSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIG9wZW4gZmlsZTogJHtwYXRofWApO1xuICB9XG5cbiAgcmV0dXJuIGZpbGU7XG59XG4iLCAiaW1wb3J0IHR5cGUgeyBFZGl0b3IgfSBmcm9tIFwib2JzaWRpYW5cIjtcblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFRleHQoZWRpdG9yOiBFZGl0b3IsIHRleHQ6IHN0cmluZykge1xuICBjb25zdCBzdGFydE9mZnNldCA9IGVkaXRvci5nZXRWYWx1ZSgpLmxhc3RJbmRleE9mKHRleHQpO1xuICBjb25zdCBlbmRPZmZzZXQgPSBzdGFydE9mZnNldCArIHRleHQubGVuZ3RoO1xuXG4gIGVkaXRvci5zZXRTZWxlY3Rpb24oXG4gICAgZWRpdG9yLm9mZnNldFRvUG9zKHN0YXJ0T2Zmc2V0KSxcbiAgICBlZGl0b3Iub2Zmc2V0VG9Qb3MoZW5kT2Zmc2V0KSxcbiAgKTtcbn1cbiIsICJpbXBvcnQgeyBnZXQgfSBmcm9tIFwic3ZlbHRlL3N0b3JlXCI7XG5pbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCIuL3N0b3JlL3NldHRpbmdzXCI7XG5pbXBvcnQgeyBhcHBTdG9yZSB9IGZyb20gXCIuL3N0b3JlL3RpbWVsaW5lLXN0b3JlXCI7XG5pbXBvcnQgeyBnZXRGaWxlQnlQYXRoLCBvcGVuRmlsZUluRWRpdG9yIH0gZnJvbSBcIi4vdXRpbC9vYnNpZGlhblwiO1xuaW1wb3J0IHsgcmVwbGFjZVRpbWVzdGFtcCB9IGZyb20gXCIuL3RpbWVzdGFtcC90aW1lc3RhbXBcIjtcbmltcG9ydCB7IGdldEhlYWRpbmdCeVRleHQsIGdldExpc3RJdGVtc1VuZGVySGVhZGluZyB9IGZyb20gXCIuL3BhcnNlci9wYXJzZXJcIjtcbmltcG9ydCB7IHNlbGVjdFRleHQgfSBmcm9tIFwiLi91dGlsL2VkaXRvclwiO1xuaW1wb3J0IHR5cGUgeyBQbGFuSXRlbSB9IGZyb20gXCIuL3R5cGVzXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBjcmVhdGVQbGFubmVySGVhZGluZygpIHtcbiAgY29uc3QgeyBwbGFubmVySGVhZGluZywgcGxhbm5lckhlYWRpbmdMZXZlbCB9ID0gZ2V0KHNldHRpbmdzKTtcblxuICBjb25zdCBoZWFkaW5nVG9rZW5zID0gXCIjXCIucmVwZWF0KHBsYW5uZXJIZWFkaW5nTGV2ZWwpO1xuXG4gIHJldHVybiBgJHtoZWFkaW5nVG9rZW5zfSAke3BsYW5uZXJIZWFkaW5nfWA7XG59XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBhcHBlbmRUb1BsYW4ocGF0aDogc3RyaW5nLCBwbGFuSXRlbTogUGxhbkl0ZW0pIHtcbiAgY29uc3QgYXBwID0gZ2V0KGFwcFN0b3JlKTtcbiAgY29uc3QgeyBwbGFubmVySGVhZGluZyB9ID0gZ2V0KHNldHRpbmdzKTtcblxuICBjb25zdCBmaWxlID0gYXdhaXQgZ2V0RmlsZUJ5UGF0aChwYXRoKTtcbiAgY29uc3QgbWV0YWRhdGEgPSBhcHAubWV0YWRhdGFDYWNoZS5nZXRGaWxlQ2FjaGUoZmlsZSk7XG4gIGNvbnN0IGVkaXRvciA9IGF3YWl0IG9wZW5GaWxlSW5FZGl0b3IoZmlsZSk7XG5cbiAgbGV0IHJlc3VsdCA9IHJlcGxhY2VUaW1lc3RhbXAocGxhbkl0ZW0sIHsgLi4ucGxhbkl0ZW0gfSk7XG5cbiAgY29uc3QgaGVhZGluZ0xpbmUgPSBnZXRIZWFkaW5nQnlUZXh0KG1ldGFkYXRhLCBwbGFubmVySGVhZGluZyk7XG5cbiAgbGV0IGxpbmUgPSBlZGl0b3IubGFzdExpbmUoKTtcblxuICBpZiAoIWhlYWRpbmdMaW5lKSB7XG4gICAgcmVzdWx0ID0gYCR7Y3JlYXRlUGxhbm5lckhlYWRpbmcoKX1cXG5cXG4ke3Jlc3VsdH1gO1xuICB9IGVsc2Uge1xuICAgIGxpbmUgPSBoZWFkaW5nTGluZS5wb3NpdGlvbi5zdGFydC5saW5lO1xuICB9XG5cbiAgY29uc3QgbGlzdEl0ZW1zID0gZ2V0TGlzdEl0ZW1zVW5kZXJIZWFkaW5nKG1ldGFkYXRhLCBwbGFubmVySGVhZGluZyk7XG5cbiAgaWYgKGxpc3RJdGVtcz8ubGVuZ3RoID4gMCkge1xuICAgIGNvbnN0IGxhc3RMaXN0SXRlbSA9IGxpc3RJdGVtc1tsaXN0SXRlbXMubGVuZ3RoIC0gMV07XG5cbiAgICBsaW5lID0gbGFzdExpc3RJdGVtLnBvc2l0aW9uLnN0YXJ0LmxpbmU7XG4gIH0gZWxzZSBpZiAoaGVhZGluZ0xpbmUpIHtcbiAgICByZXN1bHQgPSBgXFxuJHtyZXN1bHR9YFxuICB9XG5cbiAgY29uc3QgY2ggPSBlZGl0b3IuZ2V0TGluZShsaW5lKS5sZW5ndGg7XG5cbiAgZWRpdG9yLnJlcGxhY2VSYW5nZShgXFxuJHtyZXN1bHR9YCwgeyBsaW5lLCBjaCB9KTtcblxuICBzZWxlY3RUZXh0KGVkaXRvciwgcGxhbkl0ZW0udGV4dCk7XG59XG4iLCAiaW1wb3J0IHsgY3JlYXRlUGxhbkl0ZW1Gcm9tVGltZWxpbmUgfSBmcm9tIFwic3JjL3BhcnNlci9wYXJzZXJcIjtcclxuaW1wb3J0IHsgYXBwZW5kVG9QbGFuIH0gZnJvbSBcInNyYy9wbGFuXCI7XHJcbmltcG9ydCB7IHRhc2tzIH0gZnJvbSBcInNyYy9zdG9yZS90aW1lbGluZS1zdG9yZVwiO1xyXG5pbXBvcnQgeyBnZXREYWlseU5vdGVGb3JUb2RheSB9IGZyb20gXCJzcmMvdXRpbC9kYWlseS1ub3Rlc1wiO1xyXG5pbXBvcnQgeyBnZXQsIHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIHVzZUNyZWF0ZSgpIHtcclxuICBjb25zdCBjcmVhdGluZyA9IHdyaXRhYmxlKGZhbHNlKTtcclxuXHJcbiAgZnVuY3Rpb24gc3RhcnRDcmVhdGlvbigpIHtcclxuICAgIGNyZWF0aW5nLnNldCh0cnVlKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNhbmNlbENyZWF0aW9uKCkge1xyXG4gICAgY3JlYXRpbmcuc2V0KGZhbHNlKTtcclxuICB9XHJcblxyXG4gIGFzeW5jIGZ1bmN0aW9uIGNvbmZpcm1DcmVhdGlvbihwb2ludGVyWU9mZnNldDogbnVtYmVyKSB7XHJcbiAgICAvLyB0b2RvOiBvdXQgb2YgcGxhY2VcclxuICAgIGlmICghZ2V0KGNyZWF0aW5nKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgY3JlYXRpbmcuc2V0KGZhbHNlKTtcclxuXHJcbiAgICBjb25zdCBuZXdQbGFuSXRlbSA9IGNyZWF0ZVBsYW5JdGVtRnJvbVRpbWVsaW5lKHBvaW50ZXJZT2Zmc2V0KTtcclxuXHJcbiAgICB0YXNrcy51cGRhdGUoKHByZXZpb3VzKSA9PiBbLi4ucHJldmlvdXMsIG5ld1BsYW5JdGVtXSk7XHJcblxyXG4gICAgYXdhaXQgYXBwZW5kVG9QbGFuKGdldERhaWx5Tm90ZUZvclRvZGF5KCkucGF0aCwgbmV3UGxhbkl0ZW0pO1xyXG4gIH1cclxuXHJcbiAgcmV0dXJuIHtcclxuICAgIGNyZWF0aW5nLFxyXG4gICAgc3RhcnRDcmVhdGlvbixcclxuICAgIGNhbmNlbENyZWF0aW9uLFxyXG4gICAgY29uZmlybUNyZWF0aW9uLFxyXG4gIH07XHJcbn1cclxuIiwgIjxzY3JpcHQgbGFuZz1cInRzXCI+XG4gIGltcG9ydCB7IHdyaXRhYmxlIH0gZnJvbSBcInN2ZWx0ZS9zdG9yZVwiO1xuICBpbXBvcnQgVGFzayBmcm9tIFwiLi90YXNrLnN2ZWx0ZVwiO1xuICBpbXBvcnQgeyB0YXNrcyB9IGZyb20gXCIuLi8uLi9zdG9yZS90aW1lbGluZS1zdG9yZVwiO1xuICBpbXBvcnQgeyB1c2VDcmVhdGUgfSBmcm9tIFwiLi4vaG9va3MvdXNlLWNyZWF0ZVwiO1xuXG4gIGNvbnN0IGNhbmNlbE1lc3NhZ2UgPSBcIlJlbGVhc2Ugb3V0c2lkZSB0aW1lbGluZSB0byBjYW5jZWxcIjtcbiAgY29uc3QgZGVmYXVsdER1cmF0aW9uRm9yTmV3VGFzayA9IDMwO1xuXG4gIGNvbnN0IHsgY3JlYXRpbmcsIHN0YXJ0Q3JlYXRpb24sIGNhbmNlbENyZWF0aW9uLCBjb25maXJtQ3JlYXRpb24gfSA9XG4gICAgdXNlQ3JlYXRlKCk7XG5cbiAgY29uc3QgcG9pbnRlcllPZmZzZXQgPSB3cml0YWJsZTxudW1iZXI+KCk7XG4gIGxldCBlbDogSFRNTERpdkVsZW1lbnQ7XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2Vtb3ZlKGV2ZW50OiBNb3VzZUV2ZW50KSB7XG4gICAgcG9pbnRlcllPZmZzZXQuc2V0KGV2ZW50LmNsaWVudFkgLSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApO1xuICB9XG48L3NjcmlwdD5cblxuPCEtLSBUT0RPOiB1c2Ugc3RvcmUgdG8gYnJvYWRjYXN0IHRoaXMgLS0+XG48c3ZlbHRlOmRvY3VtZW50IG9uOm1vdXNldXA9e2NhbmNlbENyZWF0aW9ufSAvPlxuXG48ZGl2XG4gIGJpbmQ6dGhpcz17ZWx9XG4gIGNsYXNzPVwidGFzay1jb250YWluZXIgYWJzb2x1dGUtc3RyZXRjaC14XCJcbiAgb246bW91c2Vtb3ZlPXtoYW5kbGVNb3VzZW1vdmV9XG4gIG9uOm1vdXNlZG93bj17c3RhcnRDcmVhdGlvbn1cbiAgb246bW91c2V1cD17KCkgPT4gY29uZmlybUNyZWF0aW9uKCRwb2ludGVyWU9mZnNldCl9XG4+XG4gIHsjZWFjaCAkdGFza3MgYXMgdGFza1Byb3BzICh0YXNrUHJvcHMudGV4dCl9XG4gICAgPFRhc2sgey4uLnRhc2tQcm9wc30ge3BvaW50ZXJZT2Zmc2V0fSAvPlxuICB7L2VhY2h9XG4gIHsjaWYgJGNyZWF0aW5nfVxuICAgIDxUYXNrXG4gICAgICBpc0dob3N0XG4gICAgICB0ZXh0PXtjYW5jZWxNZXNzYWdlfVxuICAgICAgZHVyYXRpb25NaW51dGVzPXtkZWZhdWx0RHVyYXRpb25Gb3JOZXdUYXNrfVxuICAgICAge3BvaW50ZXJZT2Zmc2V0fVxuICAgIC8+XG4gIHsvaWZ9XG48L2Rpdj5cblxuPHN0eWxlPlxuICAudGFzay1jb250YWluZXIge1xuICAgIHRvcDogMDtcbiAgICBib3R0b206IDA7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xuICAgIG1hcmdpbi1yaWdodDogMTBweDtcbiAgICBtYXJnaW4tbGVmdDogMjBweDtcbiAgfVxuPC9zdHlsZT5cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBleHBvcnQgbGV0IGlzQWN0aXZlID0gZmFsc2U7XG48L3NjcmlwdD5cblxuPCEtLSBzdmVsdGUtaWdub3JlIGExMXktY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cyAtLT5cbjxkaXZcbiAgYXJpYS1sYWJlbD1cIlNldHRpbmdzXCJcbiAgY2xhc3M9XCJjbGlja2FibGUtaWNvbiBpcy1hY3RpdmVcIlxuICBjbGFzczppcy1hY3RpdmU9e2lzQWN0aXZlfVxuICBvbjpjbGlja1xuPlxuICA8c3ZnXG4gICAgY2xhc3M9XCJzdmctaWNvbiBsdWNpZGUtc2xpZGVycy1ob3Jpem9udGFsXCJcbiAgICBmaWxsPVwibm9uZVwiXG4gICAgaGVpZ2h0PVwiMjRcIlxuICAgIHN0cm9rZT1cImN1cnJlbnRDb2xvclwiXG4gICAgc3Ryb2tlLWxpbmVjYXA9XCJyb3VuZFwiXG4gICAgc3Ryb2tlLWxpbmVqb2luPVwicm91bmRcIlxuICAgIHN0cm9rZS13aWR0aD1cIjJcIlxuICAgIHZpZXdCb3g9XCIwIDAgMjQgMjRcIlxuICAgIHdpZHRoPVwiMjRcIlxuICAgIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIlxuICA+XG4gICAgPGxpbmUgeDE9XCIyMVwiIHgyPVwiMTRcIiB5MT1cIjRcIiB5Mj1cIjRcIj48L2xpbmU+XG4gICAgPGxpbmUgeDE9XCIxMFwiIHgyPVwiM1wiIHkxPVwiNFwiIHkyPVwiNFwiPjwvbGluZT5cbiAgICA8bGluZSB4MT1cIjIxXCIgeDI9XCIxMlwiIHkxPVwiMTJcIiB5Mj1cIjEyXCI+PC9saW5lPlxuICAgIDxsaW5lIHgxPVwiOFwiIHgyPVwiM1wiIHkxPVwiMTJcIiB5Mj1cIjEyXCI+PC9saW5lPlxuICAgIDxsaW5lIHgxPVwiMjFcIiB4Mj1cIjE2XCIgeTE9XCIyMFwiIHkyPVwiMjBcIj48L2xpbmU+XG4gICAgPGxpbmUgeDE9XCIxMlwiIHgyPVwiM1wiIHkxPVwiMjBcIiB5Mj1cIjIwXCI+PC9saW5lPlxuICAgIDxsaW5lIHgxPVwiMTRcIiB4Mj1cIjE0XCIgeTE9XCIyXCIgeTI9XCI2XCI+PC9saW5lPlxuICAgIDxsaW5lIHgxPVwiOFwiIHgyPVwiOFwiIHkxPVwiMTBcIiB5Mj1cIjE0XCI+PC9saW5lPlxuICAgIDxsaW5lIHgxPVwiMTZcIiB4Mj1cIjE2XCIgeTE9XCIxOFwiIHkyPVwiMjJcIj48L2xpbmU+XG4gIDwvc3ZnPlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLmNsaWNrYWJsZS1pY29uIHtcbiAgICBmbGV4LWJhc2lzOiB2YXIoLS1pbnB1dC1oZWlnaHQpO1xuICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcbiAgfVxuPC9zdHlsZT5cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgU2V0dGluZ3NCdXR0b24gZnJvbSBcIi4vc2V0dGluZ3MtYnV0dG9uLnN2ZWx0ZVwiO1xuICBpbXBvcnQgeyBvbk1vdW50IH0gZnJvbSBcInN2ZWx0ZVwiO1xuICBpbXBvcnQgeyBzZXR0aW5ncyB9IGZyb20gXCJzcmMvc3RvcmUvc2V0dGluZ3NcIjtcblxuICBsZXQgc2V0dGluZ3NWaXNpYmxlID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gdG9nZ2xlU2V0dGluZ3MoKSB7XG4gICAgc2V0dGluZ3NWaXNpYmxlID0gIXNldHRpbmdzVmlzaWJsZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGdldEZvcm1hdHRlZERhdGUoKSB7XG4gICAgcmV0dXJuIHdpbmRvdy5tb21lbnQoKS5mb3JtYXQoJHNldHRpbmdzLnRpbWVsaW5lRGF0ZUZvcm1hdCk7XG4gIH1cblxuICBsZXQgZGF0ZSA9IGdldEZvcm1hdHRlZERhdGUoKTtcblxuICBvbk1vdW50KCgpID0+IHtcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgIGRhdGUgPSBnZXRGb3JtYXR0ZWREYXRlKCk7XG4gICAgfSwgNTAwMCk7XG5cbiAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbChpbnRlcnZhbCk7XG4gIH0pO1xuPC9zY3JpcHQ+XG5cbjxkaXYgY2xhc3M9XCJjb250cm9sc1wiPlxuICA8ZGl2IGNsYXNzPVwiaGVhZGVyXCI+XG4gICAgPHNwYW4gY2xhc3M9XCJkYXRlXCI+e2RhdGV9PC9zcGFuPlxuICAgIDxTZXR0aW5nc0J1dHRvbiBpc0FjdGl2ZT17c2V0dGluZ3NWaXNpYmxlfSBvbjpjbGljaz17dG9nZ2xlU2V0dGluZ3N9IC8+XG4gIDwvZGl2PlxuICB7I2lmIHNldHRpbmdzVmlzaWJsZX1cbiAgICA8ZGl2IGNsYXNzPVwic2V0dGluZ3NcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJzZXR0aW5nLWl0ZW1cIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNldHRpbmctaXRlbS1pbmZvXCI+XG4gICAgICAgICAgPGRpdiBjbGFzcz1cInNldHRpbmctaXRlbS1uYW1lXCI+Wm9vbTwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNldHRpbmctaXRlbS1jb250cm9sXCI+XG4gICAgICAgICAgPHNlbGVjdCBiaW5kOnZhbHVlPXskc2V0dGluZ3Muem9vbUxldmVsfSBjbGFzcz1cImRyb3Bkb3duXCI+XG4gICAgICAgICAgICB7I2VhY2ggW1wiMVwiLCBcIjJcIiwgXCIzXCIsIFwiNFwiXSBhcyBsZXZlbH1cbiAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT17bGV2ZWx9PntsZXZlbH08L29wdGlvbj5cbiAgICAgICAgICAgIHsvZWFjaH1cbiAgICAgICAgICA8L3NlbGVjdD5cbiAgICAgICAgPC9kaXY+XG4gICAgICA8L2Rpdj5cblxuICAgICAgPGRpdiBjbGFzcz1cInNldHRpbmctaXRlbSBtb2QtdG9nZ2xlXCI+XG4gICAgICAgIDxkaXYgY2xhc3M9XCJzZXR0aW5nLWl0ZW0taW5mb1wiPlxuICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZXR0aW5nLWl0ZW0tbmFtZVwiPkF1dG8tc2Nyb2xsIHRvIG5vdzwvZGl2PlxuICAgICAgICA8L2Rpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cInNldHRpbmctaXRlbS1jb250cm9sXCI+XG4gICAgICAgICAgPCEtLSBzdmVsdGUtaWdub3JlIGExMXktY2xpY2stZXZlbnRzLWhhdmUta2V5LWV2ZW50cyAtLT5cbiAgICAgICAgICA8ZGl2XG4gICAgICAgICAgICBjbGFzcz1cImNoZWNrYm94LWNvbnRhaW5lciBtb2Qtc21hbGxcIlxuICAgICAgICAgICAgY2xhc3M6aXMtZW5hYmxlZD17JHNldHRpbmdzLmNlbnRlck5lZWRsZX1cbiAgICAgICAgICAgIG9uOmNsaWNrPXsoKSA9PiB7XG4gICAgICAgICAgICAgICRzZXR0aW5ncy5jZW50ZXJOZWVkbGUgPSAhJHNldHRpbmdzLmNlbnRlck5lZWRsZTtcbiAgICAgICAgICAgIH19XG4gICAgICAgICAgPlxuICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIHRhYmluZGV4PVwiMFwiIC8+XG4gICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gIHsvaWZ9XG48L2Rpdj5cblxuPHN0eWxlPlxuICAuZGF0ZSB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBmbGV4OiAxIDAgMDtcbiAgICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcblxuICAgIGZvbnQtc2l6ZTogMS4yZW07XG4gICAgY29sb3I6IHZhcigtLXRleHQtbXV0ZWQpO1xuICB9XG5cbiAgLnNldHRpbmdzIHtcbiAgICBtYXJnaW46IHZhcigtLXNpemUtNC0xKSB2YXIoLS1zaXplLTQtNCk7XG4gIH1cblxuICAuc2V0dGluZy1pdGVtIHtcbiAgICBwYWRkaW5nOiB2YXIoLS1zaXplLTItMykgMDtcbiAgICBib3JkZXI6IG5vbmU7XG4gIH1cblxuICAuc2V0dGluZy1pdGVtLW5hbWUge1xuICAgIGZvbnQtc2l6ZTogdmFyKC0tZm9udC11aS1zbWFsbCk7XG4gIH1cblxuICAuY29udHJvbHMge1xuICAgIGRpc3BsYXk6IGZsZXg7XG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcbiAgICBib3JkZXItYm90dG9tOiAxcHggc29saWQgdmFyKC0tYmFja2dyb3VuZC1tb2RpZmllci1ib3JkZXIpO1xuICB9XG5cbiAgLmhlYWRlciB7XG4gICAgZGlzcGxheTogZmxleDtcbiAgICBtYXJnaW46IHZhcigtLXNpemUtNC0yKTtcbiAgfVxuPC9zdHlsZT5cbiIsICI8c2NyaXB0IGxhbmc9XCJ0c1wiPlxuICBpbXBvcnQgUnVsZXIgZnJvbSBcIi4vcnVsZXIuc3ZlbHRlXCI7XG4gIGltcG9ydCBDb2x1bW4gZnJvbSBcIi4vY29sdW1uLnN2ZWx0ZVwiO1xuICBpbXBvcnQgTmVlZGxlIGZyb20gXCIuL25lZWRsZS5zdmVsdGVcIjtcbiAgaW1wb3J0IFRhc2tDb250YWluZXIgZnJvbSBcIi4vdGFzay1jb250YWluZXIuc3ZlbHRlXCI7XG4gIGltcG9ydCBDb250cm9scyBmcm9tIFwiLi9jb250cm9scy5zdmVsdGVcIjtcbiAgaW1wb3J0IHsgdmlzaWJsZUhvdXJzIH0gZnJvbSBcIi4uLy4uL3N0b3JlL3RpbWVsaW5lLXN0b3JlXCI7XG5cbiAgbGV0IHVzZXJIb3ZlcnNPdmVyU2Nyb2xsZXIgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBoYW5kbGVNb3VzZUVudGVyKCkge1xuICAgIHVzZXJIb3ZlcnNPdmVyU2Nyb2xsZXIgPSB0cnVlO1xuICB9XG5cbiAgZnVuY3Rpb24gaGFuZGxlTW91c2VMZWF2ZSgpIHtcbiAgICB1c2VySG92ZXJzT3ZlclNjcm9sbGVyID0gZmFsc2U7XG4gIH1cbjwvc2NyaXB0PlxuXG48Q29udHJvbHMgLz5cbjxkaXZcbiAgY2xhc3M9XCJzY3JvbGxlclwiXG4gIG9uOm1vdXNlZW50ZXI9e2hhbmRsZU1vdXNlRW50ZXJ9XG4gIG9uOm1vdXNlbGVhdmU9e2hhbmRsZU1vdXNlTGVhdmV9XG4+XG4gIDxkaXYgY2xhc3M9XCJzY2FsZS13aXRoLWRheXNcIj5cbiAgICA8UnVsZXIgdmlzaWJsZUhvdXJzPXskdmlzaWJsZUhvdXJzfSAvPlxuICAgIDxDb2x1bW4gdmlzaWJsZUhvdXJzPXskdmlzaWJsZUhvdXJzfT5cbiAgICAgIDxOZWVkbGUgc2Nyb2xsQmxvY2tlZEJ5VXNlcj17dXNlckhvdmVyc092ZXJTY3JvbGxlcn0gLz5cbiAgICAgIDxUYXNrQ29udGFpbmVyIC8+XG4gICAgPC9Db2x1bW4+XG4gIDwvZGl2PlxuPC9kaXY+XG5cbjxzdHlsZT5cbiAgLnNjcm9sbGVyIHtcbiAgICBvdmVyZmxvdzogYXV0bztcbiAgICBoZWlnaHQ6IDEwMCU7XG4gIH1cblxuICAuc2NhbGUtd2l0aC1kYXlzIHtcbiAgICBkaXNwbGF5OiBmbGV4O1xuICB9XG48L3N0eWxlPlxuIl0sCiAgIm1hcHBpbmdzIjogIjs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQUE7QUFBQTtBQUVBLFdBQU8sZUFBZSxTQUFTLGNBQWMsRUFBRSxPQUFPLEtBQUssQ0FBQztBQUU1RCxRQUFJLFdBQVcsUUFBUSxVQUFVO0FBRWpDLFFBQU0sNEJBQTRCO0FB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QUFDOUQsVUFBTSxXQUFXLEtBQUssSUFBSSxjQUFjLGFBQWEsU0FBUztBQUU5RCxXQUFPO0FBQUEsTUFDTDtBQUFBLE1BQ0E7QUFBQSxNQUNBLEtBQUssU0FBUztBQUFBLE1BQ2QsVUFBVTtBQUFBLElBQ1o7QUFBQSxFQUNGO0FBQUEsRUFFQSxNQUFjLFdBQVc7QUFDdkIsU0FBSyxxQkFBcUI7QUFDMUIsVUFBTSxLQUFLLElBQUksVUFBVSxhQUFhLEtBQUssRUFBRSxhQUFhO0FBQUEsTUFDeEQsTUFBTTtBQUFBLE1BQ04sUUFBUTtBQUFBLElBQ1YsQ0FBQztBQUFBLEVBQ0g7QUFBQSxFQUVRLHVCQUF1QjtBQUM3QixTQUFLLElBQUksVUFDTixnQkFBZ0Isa0JBQWtCLEVBQ2xDLFFBQVEsQ0FBQyxTQUFTLEtBQUssT0FBTyxDQUFDO0FBQUEsRUFDcEM7QUFDRjsiLAogICJuYW1lcyI6IFsiZm9ybWF0IiwgImZvbGRlciIsICJ0ZW1wbGF0ZSIsICJzZXR0aW5ncyIsICJjcmVhdGVEYWlseU5vdGUiLCAibW9tZW50IiwgIm5vdyIsICJnZXREYWlseU5vdGUiLCAiZ2V0QWxsRGFpbHlOb3RlcyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiaW1wb3J0X29ic2lkaWFuX2RhaWx5X25vdGVzX2ludGVyZmFjZSIsICJub3ciLCAiZWxlbWVudCIsICJfYSIsICJlbGVtZW50IiwgInRleHQiLCAiZWxlbWVudCIsICJoYXNoIiwgImRldGFjaCIsICJpbml0IiwgInRpY2siLCAibm93IiwgImNyZWF0ZV9lYWNoX2Jsb2NrIiwgImluc2VydCIsICJ1cGRhdGUiLCAiaW5zdGFuY2UiLCAiY3JlYXRlX2ZyYWdtZW50IiwgImFwcGVuZF9zdHlsZXMiLCAiYXR0ciIsICJ1cGRhdGUiLCAic3Vic2NyaWJlIiwgInJ1biIsICJtb21lbnQiLCAibWludXRlcyIsICJob3VycyIsICJtaW51dGVzIiwgIm1vbWVudCIsICJ0YXNrcyIsICJtaW51dGVzIiwgImhlYWRpbmciLCAidGV4dCIsICJzZXR0aW5ncyIsICJzZXR0aW5ncyIsICJ0ZXh0IiwgIm5vdyIsICJpbXBvcnRfb2JzaWRpYW4iLCAiY3R4IiwgInZpc2libGVIb3VycyIsICJjdHgiLCAidmlzaWJsZUhvdXJzIiwgImN0eCIsICJ0ZXh0IiwgImltcG9ydF9vYnNpZGlhbiIsICJ0YXNrcyIsICJ0ZXh0IiwgInRleHQiLCAiY3R4IiwgInRleHQiLCAiaW1wb3J0X29ic2lkaWFuIiwgInRleHQiLCAidGFza3MiLCAiY3R4IiwgImN0eCIsICJjdHgiLCAiY3JlYXRlX2lmX2Jsb2NrIiwgImN0eCIsICJzZXR0aW5ncyIsICJ0YXNrcyJdCn0K
